<?xml version="1.0"?>
<root><ModuleHolder ModuleName="--PreInstall" File=""><BlockHolder BlockName="--body" BlockCode="

  create or replace function  raise_application_error    ( code integer, message varchar(255)) returns void as $$
begin
RAISE EXCEPTION 'Error-% %',code,message;
RETURN;
End; $$ language 'plpgsql';
GO
  CREATE OR REPLACE  FUNCTION NEWID() returns uuid
  as $$
  begin
  return uuid_generate_v1();
  end;
$$ language 'plpgsql'; 
GO


"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Tables" File=""><BlockHolder BlockName="--kernel" BlockCode=" 

-- Kernel Tables --
drop table sysoptions
;
GO
create table sysoptions(
sysoptionsID uuid primary key,
Name varchar(255) null,
TheValue varchar(255) null,
OptionType varchar(255) null
)
;
GO
drop table typelist
;
GO
create  table typelist(
typelistID uuid primary key  ,
Name varchar(255) not null,
SecurityStyleID uuid null, 
RegisterProc varchar(255) null,
DeleteProc varchar(255) null,
HCLProc varchar(255) null ,
PropagateProc varchar(255) null 
)
;
GO
create table Instance(
InstanceID uuid not null primary key,
LockUserID uuid null, 
LockSessionID uuid null, 
SecurityStyleID uuid null, 
Name varchar(255) null,
ObjType varchar(255) null
)
;
GO
alter table instance add OwnerPartName varchar(255) null
;
GO
alter table instance add OwnerRowID uuid null
;
GO
alter  table instance add status uuid null
;
GO
alter  table instance add archived numeric null
;
GO
drop table QueryResult
;
GO
CREATE TABLE QueryResult (
  QueryResultid uuid NOT NULL ,
  result uuid NULL 
)
;
GO
drop table RPRESULT
;
GO
CREATE TABLE RPRESULT (
  RPRESULTID uuid NOT NULL ,
  PARENTLEVEL numeric NOT NULL ,
  PARTNAME varchar (255) NULL ,
  THEROWID uuid NULL 
)
;
GO
drop table PG_Pager
;
GO
   CREATE TABLE PG_Pager (
              PagerID uuid NOT NULL ,
              ViewID uuid NOT NULL ,
              Sequence serial  NOT NULL ,
              SessionID uuid NULL ,
              Primary key
              (  PagerID, ViewID, Sequence  )
           );
GO


"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--body" BlockCode=" 

/*Отложенное событие*/
create table MTZ2JOB_DEF/*Описание отложенного события*/ (
InstanceID uuid ,
MTZ2JOB_DEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ2JOB_DEF add 
EventDate
 timestamp null /* Отложено до */
;
GO
alter  table MTZ2JOB_DEF add 
EvenType
 VARCHAR (255) null /* Тип события */
;
GO
alter  table MTZ2JOB_DEF add 
ThruObject
 uuid null /* Объект - причина события */
;
GO
alter  table MTZ2JOB_DEF add 
ThruState
 uuid null /* Состояние - причина */
;
GO
alter  table MTZ2JOB_DEF add 
NextState
 uuid null /* Состояние после обработки */
;
GO
alter  table MTZ2JOB_DEF add 
ProcessDate
 timestamp null /* Момент обработки */
;
GO
alter  table MTZ2JOB_DEF add 
Processed
 INTEGER null 
 check (Processed in ( -1/* Да */
, 0/* Нет */ )) /* Обработан */
;
GO


/*Группа полей фильтра*/
create table FilterFieldGroup/*Группа полей фильтра*/ (
InstanceID uuid ,
FilterFieldGroupid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FilterFieldGroup add 
sequence
 integer null /* Последовательность */
;
GO
alter  table FilterFieldGroup add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table FilterFieldGroup add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table FilterFieldGroup add 
AllowIgnore
 INTEGER null 
 check (AllowIgnore in ( -1/* Да */
, 0/* Нет */ )) /* Можно отключать */
;
GO


/*Поле фильтра*/
create table FileterField/*Поле фильтра*/ (
ParentStructRowID uuid not null,
FileterFieldid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FileterField add 
sequence
 integer null /* Последовательность */
;
GO
alter  table FileterField add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table FileterField add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table FileterField add 
FieldType
 uuid null /* Тип поля */
;
GO
alter  table FileterField add 
FieldSize
 integer null /* Размер */
;
GO
alter  table FileterField add 
RefType
 INTEGER null 
 check (RefType in ( 2/* На строку раздела */
, 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 1/* На объект  */ )) /* Тип ссылки */
;
GO
alter  table FileterField add 
RefToType
 uuid null /* Тип, куда ссылаемся */
;
GO
alter  table FileterField add 
RefToPart
 uuid null /* Раздел, куда ссылаемся */
;
GO
alter  table FileterField add 
ValueArray
 INTEGER null 
 check (ValueArray in ( -1/* Да */
, 0/* Нет */ )) /* Массив значений */
;
GO


/*Фильтр*/
create table Filters/*Фильтр*/ (
InstanceID uuid ,
Filtersid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Filters add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table Filters add 
TheCaption
 VARCHAR (80) null /* Заголовок */
;
GO
alter  table Filters add 
TheComment
 TEXT null /* Описание */
;
GO


/*Суть сообщения*/
create table SrvMessageInfo/*Суть сообщения*/ (
InstanceID uuid ,
SrvMessageInfoid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table SrvMessageInfo add 
ForUser
 uuid null /* Для пользователя */
;
GO
alter  table SrvMessageInfo add 
msgDate
 timestamp null /* Дата */
;
GO
alter  table SrvMessageInfo add 
MsgInfo
 TEXT null /* Текст сообщения */
;
GO
alter  table SrvMessageInfo add 
TheDocument
 uuid null /* Документ */
;
GO
alter  table SrvMessageInfo add 
ReadTime
 timestamp null /* Время прочтения */
;
GO


/*Колонки журнала*/
create table JournalColumn/*Колонки журнала*/ (
InstanceID uuid ,
JournalColumnid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table JournalColumn add 
sequence
 integer null /* Последовательность */
;
GO
alter  table JournalColumn add 
name
 VARCHAR (255) null /* Название */
;
GO
alter  table JournalColumn add 
ColumnAlignment
 integer null 
 check (ColumnAlignment in ( 4/* Center Center */
, 3/* Center Top */
, 6/* Right Top */
, 8/* Right Bottom */
, 2/* Left Bottom */
, 7/* Right Center */
, 5/* Center Bottom */
, 1/* Left Center */
, 0/* Left Top */ )) /* Выравнивание */
;
GO
alter  table JournalColumn add 
ColSort
 INTEGER null 
 check (ColSort in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Сортировка колонки */
;
GO
alter  table JournalColumn add 
GroupAggregation
 INTEGER null 
 check (GroupAggregation in ( 5/* MAX */
, 1/* AVG */
, 3/* SUM */
, 2/* COUNT */
, 4/* MIN */
, 6/* CUSTOM */
, 0/* none */ )) /* Аггрегация при группировке */
;
GO


/*Состав колонки*/
create table JColumnSource/*Состав колонки*/ (
ParentStructRowID uuid not null,
JColumnSourceid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table JColumnSource add 
SrcPartView
 uuid null /* Представление */
;
GO
alter  table JColumnSource add 
ViewField
 VARCHAR (255) null /* Поле представления */
;
GO


/*Журнал*/
create table Journal/*Журнал*/ (
InstanceID uuid ,
Journalid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Journal add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table Journal add 
the_Alias
 VARCHAR (32) null /* Псевдоним */
;
GO
alter  table Journal add 
TheComment
 TEXT null /* Описание */
;
GO


/*Источники журнала*/
create table JournalSrc/*Источники журнала*/ (
InstanceID uuid ,
JournalSrcid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table JournalSrc add 
PartView
 uuid null /* Представление */
;
GO
alter  table JournalSrc add 
OnRun
 INTEGER null 
 check (OnRun in ( 2/* Открыть документ */
, 1/* Открыть строку */
, 0/* Ничего не делать */ )) /* При открытии */
;
GO
alter  table JournalSrc add 
OpenMode
 VARCHAR (1) null /* Режим открытия */
;
GO
alter  table JournalSrc add 
ViewAlias
 VARCHAR (255) null /* Псевдоним представления */
;
GO


/*Дейсвие при смене*/
create table StateAction/*Дейсвие при смене*/ (
InstanceID uuid ,
StateActionid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table StateAction add 
OnDocStatus
 uuid null /* При входе в состояие */
;
GO
alter  table StateAction add 
NewSecurityStyle
 uuid null /* Установить стиль защиты */
;
GO
alter  table StateAction add 
ClearSecurity
 INTEGER null 
 check (ClearSecurity in ( -1/* Да */
, 0/* Нет */ )) /* Сбросить стиль защиты */
;
GO
alter  table StateAction add 
LibraryFile
 VARCHAR (255) null /* Библиотека-обработчик */
;
GO
alter  table StateAction add 
ActionClass
 VARCHAR (255) null /* Класс для обработки */
;
GO
alter  table StateAction add 
ActionScript
 TEXT null /* Скрипт для исполнения */
;
GO


/*Очередь заблокированных объектов*/
create table REPD_LOCKED/*Очередь заблокированных объектов*/ (
InstanceID uuid ,
REPD_LOCKEDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_LOCKED add 
LastTry
 timestamp null /* Последняя разработка */
;
GO
alter  table REPD_LOCKED add 
SourceFile
 VARCHAR (2048) null /* Файл данных */
;
GO
alter  table REPD_LOCKED add 
ReplicaRowID
 uuid null /* Идентификатор строки реплики */
;
GO
alter  table REPD_LOCKED add 
FirstTry
 timestamp null /* Первая обработка */
;
GO
alter  table REPD_LOCKED add 
StructType
 VARCHAR (255) null /* Тип строки */
;
GO
alter  table REPD_LOCKED add 
ObjectType
 VARCHAR (255) null /* Тип объекта */
;
GO
alter  table REPD_LOCKED add 
The_RowID
 uuid null /* Идетнификатор строки */
;
GO
alter  table REPD_LOCKED add 
The_InstanceID
 uuid null /* Объект */
;
GO
alter  table REPD_LOCKED add 
ReplicaPackID
 uuid null /* ReplicaPackID */
;
GO
alter  table REPD_LOCKED add 
PartCount
 integer null /* PartCount */
;
GO
alter  table REPD_LOCKED add 
PartNumber
 integer null /* PartNumber */
;
GO


/*Запрос данных на объект\ строку*/
create table REPD_RequestQuery/*Запрос данных на объект\ строку*/ (
InstanceID uuid ,
REPD_RequestQueryid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_RequestQuery add 
TheRowID
 uuid null /* TheRowID */
;
GO
alter  table REPD_RequestQuery add 
ReqPartName
 VARCHAR (255) null /* ReqPartName */
;
GO
alter  table REPD_RequestQuery add 
ObjectID
 uuid null /* ObjectID */
;
GO
alter  table REPD_RequestQuery add 
SourceSrv
 uuid null /* SourceSrv */
;
GO
alter  table REPD_RequestQuery add 
SendRecord
 uuid null /* SendRecord */
;
GO
alter  table REPD_RequestQuery add 
DestSrv
 uuid null /* DestSrv */
;
GO
alter  table REPD_RequestQuery add 
Provider
 uuid null /* Provider */
;
GO
alter  table REPD_RequestQuery add 
ReqTypeName
 VARCHAR (255) null /* ReqTypeName */
;
GO


/*Результат запроса*/
create table REPD_ResQueryRcv/*Результат запроса*/ (
ParentStructRowID uuid not null,
REPD_ResQueryRcvid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_ResQueryRcv add 
ReceiveRec
 uuid null /* ReceiveRec */
;
GO


/*Провайдер репликациии*/
create table REPD_PROV/*Провайдер репликациии*/ (
InstanceID uuid ,
REPD_PROVid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_PROV add 
AssemblyName
 VARCHAR (255) null /* AssemblyName */
;
GO
alter  table REPD_PROV add 
ClassName
 VARCHAR (255) null /* ClassName */
;
GO
alter  table REPD_PROV add 
Name
 VARCHAR (255) null /* Name */
;
GO


/*Узлы репликации*/
create table REPD_SRV/*Узлы репликации*/ (
InstanceID uuid ,
REPD_SRVid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_SRV add 
Obj3
 uuid null /* Obj3 */
;
GO
alter  table REPD_SRV add 
name
 VARCHAR (255) null /* Название */
;
GO
alter  table REPD_SRV add 
Obj2
 uuid null /* Obj2 */
;
GO
alter  table REPD_SRV add 
Obj1
 uuid null /* Obj1 */
;
GO


/*Получатели реплик*/
create table REPD_SNDTO/*Получатели реплик*/ (
ParentStructRowID uuid not null,
REPD_SNDTOid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_SNDTO add 
DestSrv
 uuid null /* DestSrv */
;
GO
alter  table REPD_SNDTO add 
LastScan
 timestamp null /* Last scan */
;
GO
alter  table REPD_SNDTO add 
Config
 TEXT null /* Config */
;
GO
alter  table REPD_SNDTO add 
LastReceive
 timestamp null /* Last Receive */
;
GO
alter  table REPD_SNDTO add 
Provider
 uuid null /* Provider */
;
GO
alter  table REPD_SNDTO add 
Work_Start
 time null /* Начало работы (время) */
;
GO
alter  table REPD_SNDTO add 
Work_End
 time null /* Окончание работы (время) */
;
GO
alter  table REPD_SNDTO add 
The_Interval
 integer null /* Интервал */
;
GO
alter  table REPD_SNDTO add 
IsActive
 INTEGER null 
 check (IsActive in ( -1/* Да */
, 0/* Нет */ )) /* Активен */
;
GO
alter  table REPD_SNDTO add 
LastApproveLog
 timestamp null /* Последнее подтверждение (лог) */
;
GO


/*Константы к запросу*/
create table REPD_CONST/**/ (
ParentStructRowID uuid not null,
REPD_CONSTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_CONST add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table REPD_CONST add 
TheValue
 VARCHAR (255) null /* Значение */
;
GO


/*Тип репликации документов*/
create table REPD_REPTYPE/*Описание типа репликации документов для узла*/ (
ParentStructRowID uuid not null,
REPD_REPTYPEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_REPTYPE add 
ReplicaType
 INTEGER null 
 check (ReplicaType in ( 0/* Весь документ */
, 2/* Локальный */
, 1/* Построчно */ )) /* Тип репликации */
;
GO
alter  table REPD_REPTYPE add 
TheObjectType
 uuid null /* Тип объекта */
;
GO
alter  table REPD_REPTYPE add 
UseFilter
 INTEGER null 
 check (UseFilter in ( -1/* Да */
, 0/* Нет */ )) /* Фильтровать по условию */
;
GO
alter  table REPD_REPTYPE add 
RepConditonQRY
 TEXT null /* Условие репликации */
;
GO


/*Очередь отсылки*/
create table REPD_SendQ/*Очередь отсылки*/ (
InstanceID uuid ,
REPD_SendQid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_SendQ add 
SourceSrv
 uuid null /* SourceSrv */
;
GO
alter  table REPD_SendQ add 
Config
 TEXT null /* Config */
;
GO
alter  table REPD_SendQ add 
SentDate
 timestamp null /* SentDate */
;
GO
alter  table REPD_SendQ add 
DestSrv
 uuid null /* DestSrv */
;
GO
alter  table REPD_SendQ add 
Provider
 uuid null /* Provider */
;
GO
alter  table REPD_SendQ add 
Acknowelge
 INTEGER null 
 check (Acknowelge in ( -1/* Да */
, 0/* Нет */ )) /* Acknowelge */
;
GO
alter  table REPD_SendQ add 
SendSize
 integer null /* SendSize */
;
GO
alter  table REPD_SendQ add 
CheckDate
 timestamp null /* CheckDate */
;
GO
alter  table REPD_SendQ add 
ReplicaPackID
 uuid null /* ReplicaPackID */
;
GO
alter  table REPD_SendQ add 
FileName
 VARCHAR (1024) null /* FileName */
;
GO
alter  table REPD_SendQ add 
PartCount
 integer null /* Количество частей */
;
GO
alter  table REPD_SendQ add 
PartNumber
 integer null /* Часть */
;
GO
alter  table REPD_SendQ add 
Sent
 integer null 
 check (Sent in ( 1/* Да */
, 0/* Нет */ )) /* Sent */
;
GO
alter  table REPD_SendQ add 
ReplicatorPointer
 timestamp null /* Указатель репликации */
;
GO


/*Очередь полученых реплик*/
create table REPD_RecvQ/*Очередь полученых реплик*/ (
InstanceID uuid ,
REPD_RecvQid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table REPD_RecvQ add 
TheRowID
 uuid null /* TheRowID */
;
GO
alter  table REPD_RecvQ add 
Received
 timestamp null /* Received */
;
GO
alter  table REPD_RecvQ add 
Provider
 uuid null /* Provider */
;
GO
alter  table REPD_RecvQ add 
RecvSize
 integer null /* RecvSize */
;
GO
alter  table REPD_RecvQ add 
SourceSrv
 uuid null /* SourceSrv */
;
GO
alter  table REPD_RecvQ add 
DestSrv
 uuid null /* DestSrv */
;
GO
alter  table REPD_RecvQ add 
Acknowelge
 INTEGER null 
 check (Acknowelge in ( -1/* Да */
, 0/* Нет */ )) /* Acknowelge */
;
GO
alter  table REPD_RecvQ add 
ReplicaPackID
 uuid null /* ReplicaPackID */
;
GO
alter  table REPD_RecvQ add 
PartCount
 integer null /* Количество частей */
;
GO
alter  table REPD_RecvQ add 
PartNumber
 integer null /* Часть */
;
GO
alter  table REPD_RecvQ add 
FileName
 VARCHAR (1024) null /* FileName */
;
GO
alter  table REPD_RecvQ add 
Completed
 INTEGER null 
 check (Completed in ( -1/* Да */
, 0/* Нет */ )) /* Completed */
;
GO


/*Описание*/
create table invi_DEF/*Описание*/ (
InstanceID uuid ,
invi_DEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table invi_DEF add 
OrderNum
 VARCHAR (30) null /* Номер приказа */
;
GO
alter  table invi_DEF add 
StartDate
 date null /* Дата начала инвентаризации */
;
GO
alter  table invi_DEF add 
EndDate
 date null /* Дата завершения инвентаризации */
;
GO
alter  table invi_DEF add 
TheOrg
 uuid null /* Юр. лицо */
;
GO
alter  table invi_DEF add 
DIrection
 uuid null /* Дирекция */
;
GO
alter  table invi_DEF add 
Uprev
 uuid null /* Управление */
;
GO
alter  table invi_DEF add 
Otdel
 uuid null /* Отдел */
;
GO
alter  table invi_DEF add 
TheOwner
 uuid null /* Владелец */
;
GO
alter  table invi_DEF add 
Building
 uuid null /* Здание */
;
GO
alter  table invi_DEF add 
TheFlow
 VARCHAR (5) null /* Этаж */
;
GO
alter  table invi_DEF add 
TheRoom
 VARCHAR (10) null /* Комната */
;
GO
alter  table invi_DEF add 
TheWorkPlace
 VARCHAR (10) null /* Рабочее место */
;
GO
alter  table invi_DEF add 
MatOtv
 uuid null /* МОЛ */
;
GO
alter  table invi_DEF add 
Info
 TEXT null /* Примечания */
;
GO


/*Состав комисии*/
create table INVI_PERSONS/*Состав инвентаризационной комисии*/ (
InstanceID uuid ,
INVI_PERSONSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_PERSONS add 
ThePosition
 VARCHAR (255) null /* Должность */
;
GO
alter  table INVI_PERSONS add 
FamiliName
 VARCHAR (100) null /* Фамилия */
;
GO
alter  table INVI_PERSONS add 
Name
 VARCHAR (100) null /* Имя */
;
GO
alter  table INVI_PERSONS add 
SurName
 VARCHAR (100) null /* Отчество */
;
GO


/*Неверные штрихкоды*/
create table INVI_BAD/*Неверно наклеенные штрихкоды*/ (
InstanceID uuid ,
INVI_BADid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_BAD add 
SHCode
 VARCHAR (30) null /* Штрихкод */
;
GO
alter  table INVI_BAD add 
Info
 TEXT null /* Описание объекта */
;
GO


/*Требуют замены*/
create table INVI_CHNG/*Нечитаемые, или испорченные штрихкоды*/ (
InstanceID uuid ,
INVI_CHNGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_CHNG add 
SHCode
 VARCHAR (30) null /* Штрихкод */
;
GO


/*Объекты инвентаризации*/
create table INVI_OBJ/*Объекты инвентаризации*/ (
InstanceID uuid ,
INVI_OBJid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_OBJ add 
TheOS
 uuid null /* Основное средство */
;
GO


/*Отметки об инвентаризации*/
create table INVI_DONE/*Отметки об инвентаризации*/ (
InstanceID uuid ,
INVI_DONEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_DONE add 
CheckDate
 timestamp null /* Дата проверки */
;
GO
alter  table INVI_DONE add 
TheOS
 uuid null /* Основное средство */
;
GO
alter  table INVI_DONE add 
OSStatus
 uuid null /* Состояние */
;
GO


/*Неучтенные объекты*/
create table INVI_UNK/*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
InstanceID uuid ,
INVI_UNKid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVI_UNK add 
TheRoom
 VARCHAR (80) null /* Помещение */
;
GO
alter  table INVI_UNK add 
Info
 TEXT null /* Описание объекта */
;
GO


/*Описание расширения Журнал*/
create table STDJournlaExtInfo/**/ (
InstanceID uuid ,
STDJournlaExtInfoid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table STDJournlaExtInfo add 
TheName
 VARCHAR (255) null /* Название */
;
GO
alter  table STDJournlaExtInfo add 
TheJournalRef
 uuid null /* Журнал */
;
GO


/*Параметры*/
create table STDJournalExtParam/**/ (
InstanceID uuid ,
STDJournalExtParamid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table STDJournalExtParam add 
FieldName
 VARCHAR (255) null /* Поле (значение) */
;
GO
alter  table STDJournalExtParam add 
ParamName
 VARCHAR (80) null /* Параметр */
;
GO
alter  table STDJournalExtParam add 
TargetPlatform
 uuid null /* Целевая платформа */
;
GO


/*Фильтры журнала*/
create table STDJournalExtFlt/**/ (
InstanceID uuid ,
STDJournalExtFltid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table STDJournalExtFlt add 
ViewSource
 VARCHAR (255) null /* Источник журнала */
;
GO


/*Параметры фильтра*/
create table STDJournalExtField/**/ (
ParentStructRowID uuid not null,
STDJournalExtFieldid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table STDJournalExtField add 
ViewField
 VARCHAR (255) null /* Колонка журнала */
;
GO
alter  table STDJournalExtField add 
FieldSource
 VARCHAR (255) null /* Поле */
;
GO
alter  table STDJournalExtField add 
TargetPlatform
 uuid null /* Целевая платформа */
;
GO
alter  table STDJournalExtField add 
ConstantValue
 VARCHAR (255) null /* Значение */
;
GO
alter  table STDJournalExtField add 
ConditionType
 INTEGER null 
 check (ConditionType in ( 2/* &lt;&gt; */
, 3/* &gt; */
, 1/* = */
, 4/* &gt;= */
, 7/* &lt;= */
, 8/* like */
, 6/* &lt; */
, 0/* none */ )) /* Условие */
;
GO


/*Тип поля*/
create table FIELDTYPE/*Типы полей, перечисления, интервалы*/ (
InstanceID uuid ,
FIELDTYPEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDTYPE add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table FIELDTYPE add 
TypeStyle
 INTEGER null 
 check (TypeStyle in ( 3/* Интервал */
, 5/* Элемент оформления */
, 0/* Скалярный тип */
, 4/* Ссылка */
, 2/* Перечисление */
, 1/* Выражение */ )) /* Трактовка */
;
GO
alter  table FIELDTYPE add 
the_Comment
 TEXT null /* Описание */
;
GO
alter  table FIELDTYPE add 
AllowSize
 INTEGER null 
 check (AllowSize in ( -1/* Да */
, 0/* Нет */ )) /* Нужен размер */
;
GO
alter  table FIELDTYPE add 
Minimum
 VARCHAR (64) null /* Минимум */
;
GO
alter  table FIELDTYPE add 
Maximum
 VARCHAR (64) null /* Максимум */
;
GO
alter  table FIELDTYPE add 
AllowLikeSearch
 INTEGER null 
 check (AllowLikeSearch in ( -1/* Да */
, 0/* Нет */ )) /* Поиск текста */
;
GO
alter  table FIELDTYPE add 
GridSortType
 INTEGER null 
 check (GridSortType in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Вариант сортировки в табличном представлении */
;
GO


/*Отображение*/
create table FIELDTYPEMAP/*Отображение типа поля на физический тип хранения*/ (
ParentStructRowID uuid not null,
FIELDTYPEMAPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDTYPEMAP add 
Target
 uuid null /* Платформа */
;
GO
alter  table FIELDTYPEMAP add 
StoageType
 VARCHAR (255) null /* Тип хранения */
;
GO
alter  table FIELDTYPEMAP add 
FixedSize
 integer null /* Размер */
;
GO


/*Зачения*/
create table ENUMITEM/*Для описания Enum типов*/ (
ParentStructRowID uuid not null,
ENUMITEMid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ENUMITEM add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table ENUMITEM add 
NameValue
 integer null /* Значение */
;
GO
alter  table ENUMITEM add 
NameInCode
 VARCHAR (100) null /* Название в коде */
;
GO


/*Методы и процедуры*/
create table SHAREDMETHOD/*Методы и процедуры*/ (
InstanceID uuid ,
SHAREDMETHODid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table SHAREDMETHOD add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table SHAREDMETHOD add 
the_Comment
 TEXT null /* Описание метода */
;
GO
alter  table SHAREDMETHOD add 
ReturnType
 uuid null /* Возвращаемый тип */
;
GO


/*Реализация*/
create table SCRIPT/*Код метода на понятном конкретному генератору языке*/ (
ParentStructRowID uuid not null,
SCRIPTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table SCRIPT add 
Target
 uuid null /* Целевая платформа */
;
GO
alter  table SCRIPT add 
Code
 TEXT null /* Скрипт */
;
GO


/*Параметры*/
create table PARAMETERS/*Параметры метода*/ (
ParentStructRowID uuid not null,
PARAMETERSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table PARAMETERS add 
sequence
 integer null /* Последовательность */
;
GO
alter  table PARAMETERS add 
Name
 VARCHAR (80) null /* Имя */
;
GO
alter  table PARAMETERS add 
Caption
 VARCHAR (80) null /* Заголовок */
;
GO
alter  table PARAMETERS add 
TypeOfParm
 uuid null /* Тип данных */
;
GO
alter  table PARAMETERS add 
DataSize
 integer null /* Размер */
;
GO
alter  table PARAMETERS add 
AllowNull
 INTEGER null 
 check (AllowNull in ( -1/* Да */
, 0/* Нет */ )) /* Можно не задавать */
;
GO
alter  table PARAMETERS add 
OutParam
 INTEGER null 
 check (OutParam in ( -1/* Да */
, 0/* Нет */ )) /* Возвращает значение */
;
GO
alter  table PARAMETERS add 
ReferenceType
 INTEGER null 
 check (ReferenceType in ( 2/* На строку раздела */
, 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 1/* На объект  */ )) /* Тип ссылки */
;
GO
alter  table PARAMETERS add 
RefToType
 uuid null /* Ссылка на тип */
;
GO
alter  table PARAMETERS add 
RefToPart
 uuid null /* Ссылка на раздел */
;
GO


/*Тип объекта*/
create table OBJECTTYPE/*Тип объекта (карточки)*/ (
InstanceID uuid ,
OBJECTTYPEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table OBJECTTYPE add 
Package
 uuid null /* Приложение */
;
GO
alter  table OBJECTTYPE add 
the_Comment
 VARCHAR (255) null /* Название */
;
GO
alter  table OBJECTTYPE add 
Name
 VARCHAR (14) null /* Код */
;
GO
alter  table OBJECTTYPE add 
IsSingleInstance
 INTEGER null 
 check (IsSingleInstance in ( -1/* Да */
, 0/* Нет */ )) /* Допускается только один объект */
;
GO
alter  table OBJECTTYPE add 
ChooseView
 uuid null /* Представление для выбора */
;
GO
alter  table OBJECTTYPE add 
OnRun
 uuid null /* При запуске */
;
GO
alter  table OBJECTTYPE add 
OnCreate
 uuid null /* При создании */
;
GO
alter  table OBJECTTYPE add 
OnDelete
 uuid null /* При удалении */
;
GO
alter  table OBJECTTYPE add 
AllowRefToObject
 INTEGER null 
 check (AllowRefToObject in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при выборе ссылки */
;
GO
alter  table OBJECTTYPE add 
AllowSearch
 INTEGER null 
 check (AllowSearch in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при поиске */
;
GO
alter  table OBJECTTYPE add 
ReplicaType
 INTEGER null 
 check (ReplicaType in ( 0/* Весь документ */
, 2/* Локальный */
, 1/* Построчно */ )) /* Тип репликации */
;
GO
alter  table OBJECTTYPE add 
TheComment
 TEXT null /* Описание */
;
GO


/*Раздел*/
create table PART/*Раздел объекта*/ (
ParentStructRowID uuid not null,
PARTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
,ParentRowid uuid 
)
;
GO
alter  table PART add 
Sequence
 integer null /* № п/п */
;
GO
alter  table PART add 
PartType
 INTEGER null 
 check (PartType in ( 3/* Расширение */
, 1/* Коллекция */
, 0/* Строка */
, 2/* Дерево */
, 4/* Расширение с данными */ )) /* Тип структры  */
;
GO
alter  table PART add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table PART add 
Name
 VARCHAR (20) null /* Название */
;
GO
alter  table PART add 
the_Comment
 TEXT null /* Описание */
;
GO
alter  table PART add 
NoLog
 INTEGER null 
 check (NoLog in ( -1/* Да */
, 0/* Нет */ )) /* Не записывать в журнал */
;
GO
alter  table PART add 
ManualRegister
 INTEGER null 
 check (ManualRegister in ( -1/* Да */
, 0/* Нет */ )) /* Исключить из индексирования */
;
GO
alter  table PART add 
OnCreate
 uuid null /* При создании */
;
GO
alter  table PART add 
OnSave
 uuid null /* При сохранении */
;
GO
alter  table PART add 
OnRun
 uuid null /* При открытии */
;
GO
alter  table PART add 
OnDelete
 uuid null /* При удалении */
;
GO
alter  table PART add 
AddBehaivor
 INTEGER null 
 check (AddBehaivor in ( 0/* AddForm */
, 2/* RunAction */
, 1/* RefreshOnly */ )) /* Поведение при добавлении */
;
GO
alter  table PART add 
ExtenderObject
 uuid null /* Объект расширения */
;
GO
alter  table PART add 
shablonBrief
 VARCHAR (100) null /* Шаблон для краткого отображения */
;
GO
alter  table PART add 
ruleBrief
 VARCHAR (500) null /* Правило составления BRIEF поля */
;
GO
alter  table PART add 
IsJormalChange
 INTEGER null 
 check (IsJormalChange in ( -1/* Да */
, 0/* Нет */ )) /* Вести журнал изменений */
;
GO


/*Методы раздела*/
create table PARTMENU/*Методы уровня раздела*/ (
ParentStructRowID uuid not null,
PARTMENUid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table PARTMENU add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table PARTMENU add 
Caption
 VARCHAR (80) null /* Заголовок */
;
GO
alter  table PARTMENU add 
ToolTip
 VARCHAR (80) null /* Подсказка */
;
GO
alter  table PARTMENU add 
the_Action
 uuid null /* Метод */
;
GO
alter  table PARTMENU add 
IsMenuItem
 INTEGER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
;
GO
alter  table PARTMENU add 
IsToolBarButton
 INTEGER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
;
GO
alter  table PARTMENU add 
HotKey
 VARCHAR (20) null /* Горячая клавиша */
;
GO


/*Отображение параметров*/
create table PARTPARAMMAP/*отображение значений полей раздела на параметры метода*/ (
ParentStructRowID uuid not null,
PARTPARAMMAPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table PARTPARAMMAP add 
FieldName
 VARCHAR (255) null /* Поле (значение) */
;
GO
alter  table PARTPARAMMAP add 
ParamName
 VARCHAR (80) null /* Параметр */
;
GO
alter  table PARTPARAMMAP add 
NoEdit
 INTEGER null 
 check (NoEdit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
;
GO


/*Поле*/
create table FIELD/*Поле*/ (
ParentStructRowID uuid not null,
FIELDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELD add 
Sequence
 integer null /* № п/п */
;
GO
alter  table FIELD add 
Caption
 VARCHAR (80) null /* Надпись */
;
GO
alter  table FIELD add 
Name
 VARCHAR (64) null /* Имя поля */
;
GO
alter  table FIELD add 
FieldType
 uuid null /* Тип поля */
;
GO
alter  table FIELD add 
IsBrief
 INTEGER null 
 check (IsBrief in ( -1/* Да */
, 0/* Нет */ )) /* Краткая информация */
;
GO
alter  table FIELD add 
AllowNull
 INTEGER null 
 check (AllowNull in ( -1/* Да */
, 0/* Нет */ )) /* Может быть пустым */
;
GO
alter  table FIELD add 
DataSize
 integer null /* Размер поля */
;
GO
alter  table FIELD add 
ReferenceType
 INTEGER null 
 check (ReferenceType in ( 2/* На строку раздела */
, 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 1/* На объект  */ )) /* Тип ссылки */
;
GO
alter  table FIELD add 
RefToType
 uuid null /* Ссылка на тип */
;
GO
alter  table FIELD add 
RefToPart
 uuid null /* Ссылка на раздел */
;
GO
alter  table FIELD add 
InternalReference
 INTEGER null 
 check (InternalReference in ( -1/* Да */
, 0/* Нет */ )) /* Ссылка в пределах объекта */
;
GO
alter  table FIELD add 
CreateRefOnly
 INTEGER null 
 check (CreateRefOnly in ( -1/* Да */
, 0/* Нет */ )) /* Только создание объекта */
;
GO
alter  table FIELD add 
IsAutoNumber
 INTEGER null 
 check (IsAutoNumber in ( -1/* Да */
, 0/* Нет */ )) /* Автонумерация */
;
GO
alter  table FIELD add 
TheNumerator
 uuid null /* Нумератор */
;
GO
alter  table FIELD add 
ZoneTemplate
 VARCHAR (255) null /* Шаблон зоны нумерации */
;
GO
alter  table FIELD add 
NumberDateField
 uuid null /* Поле для расчета даты */
;
GO
alter  table FIELD add 
TheComment
 TEXT null /* Описание */
;
GO
alter  table FIELD add 
shablonBrief
 VARCHAR (100) null /* Шаблон для краткого отображения */
;
GO
alter  table FIELD add 
theNameClass
 VARCHAR (100) null /* Имя класса для мастера строк */
;
GO
alter  table FIELD add 
TheMask
 VARCHAR (64) null /* Маска */
;
GO


/*Логика поля на форме*/
create table FIELDVALIDATOR/*Логика взаимосвязей на форме при изменении поля*/ (
ParentStructRowID uuid not null,
FIELDVALIDATORid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDVALIDATOR add 
Target
 uuid null /* Платформа */
;
GO
alter  table FIELDVALIDATOR add 
Code
 TEXT null /* Скрипт */
;
GO


/*Методы поля*/
create table FIELDMENU/*Методы, ассоциированные с полем*/ (
ParentStructRowID uuid not null,
FIELDMENUid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDMENU add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table FIELDMENU add 
Caption
 VARCHAR (80) null /* Заголовок */
;
GO
alter  table FIELDMENU add 
ToolTip
 VARCHAR (80) null /* Подсказка */
;
GO
alter  table FIELDMENU add 
ActionID
 uuid null /* Идентификатор вызываемого метода */
;
GO
alter  table FIELDMENU add 
IsMenuItem
 INTEGER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* В меню */
;
GO
alter  table FIELDMENU add 
IsToolBarButton
 INTEGER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
;
GO
alter  table FIELDMENU add 
HotKey
 VARCHAR (20) null /* Горячая клавиша */
;
GO


/*Отображение параметров*/
create table FIELDPARAMMAP/*Отображение значений на параметры метода*/ (
ParentStructRowID uuid not null,
FIELDPARAMMAPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDPARAMMAP add 
FieldName
 VARCHAR (255) null /* Поле (значение) */
;
GO
alter  table FIELDPARAMMAP add 
ParamName
 VARCHAR (80) null /* Параметр */
;
GO
alter  table FIELDPARAMMAP add 
NoEdit
 INTEGER null 
 check (NoEdit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
;
GO


/*Интерфейсы расширения*/
create table FldExtenders/**/ (
ParentStructRowID uuid not null,
FldExtendersid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FldExtenders add 
TheName
 VARCHAR (255) null /* Название */
;
GO
alter  table FldExtenders add 
TargetPlatform
 uuid null /* Целевая платформа */
;
GO
alter  table FldExtenders add 
TheObject
 VARCHAR (255) null /* Объект */
;
GO
alter  table FldExtenders add 
TheConfig
 VARCHAR (512) null /* Конфиг */
;
GO


/*Значение по умолчанию*/
create table FIELDEXPRESSION/*Выражение для вычисления поля
или значение по умолчанию*/ (
ParentStructRowID uuid not null,
FIELDEXPRESSIONid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDEXPRESSION add 
Target
 uuid null /* Платформа */
;
GO
alter  table FIELDEXPRESSION add 
Code
 TEXT null /* Скрипт */
;
GO


/*Динамический фильтр*/
create table DINAMICFILTERSCRIPT/*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
ParentStructRowID uuid not null,
DINAMICFILTERSCRIPTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table DINAMICFILTERSCRIPT add 
Target
 uuid null /* Целевая платформа */
;
GO
alter  table DINAMICFILTERSCRIPT add 
Code
 TEXT null /* Скрипт */
;
GO


/*Описание источника данных*/
create table FIELDSRCDEF/*Описание источника данных для полей типа ReferenceSQL */ (
ParentStructRowID uuid not null,
FIELDSRCDEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDSRCDEF add 
Provider
 VARCHAR (128) null /* Провайдер */
;
GO
alter  table FIELDSRCDEF add 
ConnectionString
 VARCHAR (512) null /* Строка соединения с источником */
;
GO
alter  table FIELDSRCDEF add 
DataSource
 VARCHAR (512) null /* Источник данных */
;
GO
alter  table FIELDSRCDEF add 
IDField
 VARCHAR (128) null /* ID */
;
GO
alter  table FIELDSRCDEF add 
BriefString
 VARCHAR (512) null /* Источник краткой информации */
;
GO
alter  table FIELDSRCDEF add 
FilterString
 VARCHAR (512) null /* Фильтр источника данных */
;
GO
alter  table FIELDSRCDEF add 
SortField
 VARCHAR (512) null /* Сортировка источника данных */
;
GO
alter  table FIELDSRCDEF add 
DescriptionString
 TEXT null /* Примечания */
;
GO
alter  table FIELDSRCDEF add 
DontShowDialog
 integer null 
 check (DontShowDialog in ( 1/* Да */
, 0/* Нет */ )) /* Не показывать форму выбора */
;
GO


/*Представление*/
create table PARTVIEW/*Вариант представления, который может использоваться для создания журнала*/ (
ParentStructRowID uuid not null,
PARTVIEWid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table PARTVIEW add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table PARTVIEW add 
the_Alias
 VARCHAR (64) null /* Псевдоним */
;
GO
alter  table PARTVIEW add 
ForChoose
 INTEGER null 
 check (ForChoose in ( -1/* Да */
, 0/* Нет */ )) /* Для поиска */
;
GO
alter  table PARTVIEW add 
FilterField0
 VARCHAR (255) null /* Поле - фильтр 0 */
;
GO
alter  table PARTVIEW add 
FilterField1
 VARCHAR (255) null /* Поле - фильтр 1 */
;
GO
alter  table PARTVIEW add 
FilterField2
 VARCHAR (255) null /* Поле - фильтр 2 */
;
GO
alter  table PARTVIEW add 
FilterField3
 VARCHAR (255) null /* Поле - фильтр 3 */
;
GO


/*Колонка*/
create table ViewColumn/*Колонка пердставления*/ (
ParentStructRowID uuid not null,
ViewColumnid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ViewColumn add 
sequence
 integer null /* №  */
;
GO
alter  table ViewColumn add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table ViewColumn add 
the_Alias
 VARCHAR (64) null /* Псвдоним */
;
GO
alter  table ViewColumn add 
FromPart
 uuid null /* Раздел */
;
GO
alter  table ViewColumn add 
Field
 uuid null /* Поле */
;
GO
alter  table ViewColumn add 
Aggregation
 INTEGER null 
 check (Aggregation in ( 5/* MAX */
, 1/* AVG */
, 3/* SUM */
, 2/* COUNT */
, 4/* MIN */
, 6/* CUSTOM */
, 0/* none */ )) /* Агрегация */
;
GO
alter  table ViewColumn add 
Expression
 TEXT null /* Формула */
;
GO
alter  table ViewColumn add 
ForCombo
 INTEGER null 
 check (ForCombo in ( -1/* Да */
, 0/* Нет */ )) /* Для комбо */
;
GO


/*Связанные представления*/
create table PARTVIEW_LNK/**/ (
ParentStructRowID uuid not null,
PARTVIEW_LNKid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table PARTVIEW_LNK add 
TheView
 uuid null /* Представление */
;
GO
alter  table PARTVIEW_LNK add 
TheJoinSource
 uuid null /* Связь: Поле для join источник */
;
GO
alter  table PARTVIEW_LNK add 
RefType
 integer null 
 check (RefType in ( 2/* Ссылка на строку */
, 1/* Ссылка на объект */
, 3/* Связка InstanceID (в передлах объекта) */
, 4/* Связка ParentStructRowID  (в передлах объекта) */
, 0/* Нет */ )) /* Связывать как */
;
GO
alter  table PARTVIEW_LNK add 
TheJoinDestination
 uuid null /* Свзяь: Поле для join приемник */
;
GO
alter  table PARTVIEW_LNK add 
HandJoin
 VARCHAR (255) null /* Ручной join */
;
GO
alter  table PARTVIEW_LNK add 
SEQ
 integer null /* Порядок */
;
GO


/*Интерфейсы расширения*/
create table ExtenderInterface/**/ (
ParentStructRowID uuid not null,
ExtenderInterfaceid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ExtenderInterface add 
TheName
 VARCHAR (255) null /* Название */
;
GO
alter  table ExtenderInterface add 
TargetPlatform
 uuid null /* Целевая платформа */
;
GO
alter  table ExtenderInterface add 
TheObject
 VARCHAR (255) null /* Объект */
;
GO
alter  table ExtenderInterface add 
TheConfig
 VARCHAR (512) null /* Конфиг */
;
GO


/*Логика на форме*/
create table VALIDATOR/*Действия в впроцессе редактирования*/ (
ParentStructRowID uuid not null,
VALIDATORid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table VALIDATOR add 
Target
 uuid null /* Целевая платформа */
;
GO
alter  table VALIDATOR add 
Code
 TEXT null /* Скрипт */
;
GO


/*Ограничение уникальности*/
create table UNIQUECONSTRAINT/*Ограничение уникальности*/ (
ParentStructRowID uuid not null,
UNIQUECONSTRAINTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table UNIQUECONSTRAINT add 
Name
 VARCHAR (80) null /* Название */
;
GO
alter  table UNIQUECONSTRAINT add 
PerParent
 INTEGER null 
 check (PerParent in ( -1/* Да */
, 0/* Нет */ )) /* По родителю */
;
GO
alter  table UNIQUECONSTRAINT add 
TheComment
 TEXT null /* Описание */
;
GO


/*Поля ограничения*/
create table CONSTRAINTFIELD/*Поля ограничения*/ (
ParentStructRowID uuid not null,
CONSTRAINTFIELDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table CONSTRAINTFIELD add 
TheField
 uuid null /* Поле */
;
GO


/*Проверка правильности*/
create table INSTANCEVALIDATOR/*Проверка правильности для объекта в целом*/ (
ParentStructRowID uuid not null,
INSTANCEVALIDATORid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INSTANCEVALIDATOR add 
Target
 uuid null /* Платформа */
;
GO
alter  table INSTANCEVALIDATOR add 
Code
 TEXT null /* Скрипт */
;
GO


/*Состояния*/
create table OBJSTATUS/*Возможные логические состояния документа*/ (
ParentStructRowID uuid not null,
OBJSTATUSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table OBJSTATUS add 
name
 VARCHAR (80) null /* Название */
;
GO
alter  table OBJSTATUS add 
isStartup
 INTEGER null 
 check (isStartup in ( -1/* Да */
, 0/* Нет */ )) /* Начальное */
;
GO
alter  table OBJSTATUS add 
IsArchive
 INTEGER null 
 check (IsArchive in ( -1/* Да */
, 0/* Нет */ )) /* Архивное */
;
GO
alter  table OBJSTATUS add 
the_comment
 TEXT null /* Описание */
;
GO


/*Разрешенные переходы*/
create table NEXTSTATE/*Матрица переходов */ (
ParentStructRowID uuid not null,
NEXTSTATEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table NEXTSTATE add 
TheState
 uuid null /* Разрешенное состояние */
;
GO


/*Режим работы*/
create table OBJECTMODE/*Режим работы*/ (
ParentStructRowID uuid not null,
OBJECTMODEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table OBJECTMODE add 
Name
 VARCHAR (5) null /* Название режима */
;
GO
alter  table OBJECTMODE add 
DefaultMode
 INTEGER null 
 check (DefaultMode in ( -1/* Да */
, 0/* Нет */ )) /* Этот режим является основным режимом работы объекта */
;
GO
alter  table OBJECTMODE add 
TheComment
 TEXT null /* Описание */
;
GO


/*Органичения разделов*/
create table STRUCTRESTRICTION/*Ораничения на доступ к разделу документа*/ (
ParentStructRowID uuid not null,
STRUCTRESTRICTIONid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table STRUCTRESTRICTION add 
Struct
 uuid null /* структура, доступ к которой ограничен */
;
GO
alter  table STRUCTRESTRICTION add 
AllowRead
 INTEGER null 
 check (AllowRead in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
;
GO
alter  table STRUCTRESTRICTION add 
AllowAdd
 INTEGER null 
 check (AllowAdd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавлять */
;
GO
alter  table STRUCTRESTRICTION add 
AllowEdit
 INTEGER null 
 check (AllowEdit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено изменять */
;
GO
alter  table STRUCTRESTRICTION add 
AllowDelete
 INTEGER null 
 check (AllowDelete in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удалять */
;
GO


/*Ограничения полей*/
create table FIELDRESTRICTION/*Ограничения на доступ к полям раздела*/ (
ParentStructRowID uuid not null,
FIELDRESTRICTIONid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table FIELDRESTRICTION add 
ThePart
 uuid null /* Структура, которой принадлежит поле */
;
GO
alter  table FIELDRESTRICTION add 
TheField
 uuid null /* Поле, на которое накладывается ограничение */
;
GO
alter  table FIELDRESTRICTION add 
AllowRead
 INTEGER null 
 check (AllowRead in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
;
GO
alter  table FIELDRESTRICTION add 
AllowModify
 INTEGER null 
 check (AllowModify in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена модификация */
;
GO
alter  table FIELDRESTRICTION add 
MandatoryField
 integer null 
 check (MandatoryField in ( 0/* Нет */
, -1/* Не существенно */
, 1/* Да */ )) /* Обязательное поле */
;
GO


/*Ограничения методов*/
create table METHODRESTRICTION/*Ограничение на использование методов раздела*/ (
ParentStructRowID uuid not null,
METHODRESTRICTIONid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table METHODRESTRICTION add 
Part
 uuid null /* Структура, которой принадлежит метод */
;
GO
alter  table METHODRESTRICTION add 
Method
 uuid null /* Метод */
;
GO
alter  table METHODRESTRICTION add 
IsRestricted
 INTEGER null 
 check (IsRestricted in ( -1/* Да */
, 0/* Нет */ )) /* Запрещено использовать */
;
GO


/*Методы типа*/
create table TYPEMENU/*Методы уровня типа*/ (
ParentStructRowID uuid not null,
TYPEMENUid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table TYPEMENU add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table TYPEMENU add 
Caption
 VARCHAR (80) null /* Заголовок */
;
GO
alter  table TYPEMENU add 
ToolTip
 VARCHAR (80) null /* Подсказка */
;
GO
alter  table TYPEMENU add 
the_Action
 uuid null /* Метод */
;
GO
alter  table TYPEMENU add 
IsMenuItem
 INTEGER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
;
GO
alter  table TYPEMENU add 
IsToolBarButton
 INTEGER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* Включать в тулбар */
;
GO
alter  table TYPEMENU add 
HotKey
 VARCHAR (20) null /* Горячая клавиша */
;
GO


/*Приложение*/
create table MTZAPP/*Группа взаимосвязных документов*/ (
InstanceID uuid ,
MTZAPPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZAPP add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table MTZAPP add 
DBName
 VARCHAR (64) null /* База данных */
;
GO
alter  table MTZAPP add 
TheComment
 TEXT null /* Описание */
;
GO


/*Обязательные приложения*/
create table ParentPackage/*Приложения от которых зависит данное приложение*/ (
ParentStructRowID uuid not null,
ParentPackageid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ParentPackage add 
Package
 uuid null /* Приложение */
;
GO


/*Пакет генерации*/
create table GENPACKAGE/*Пакет генерации*/ (
InstanceID uuid ,
GENPACKAGEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GENPACKAGE add 
Name
 VARCHAR (255) null /* Название */
;
GO


/*Генераторы*/
create table GENERATOR_TARGET/*Генераторы*/ (
ParentStructRowID uuid not null,
GENERATOR_TARGETid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GENERATOR_TARGET add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table GENERATOR_TARGET add 
TargetType
 integer null 
 check (TargetType in ( 0/* СУБД */
, 4/* АРМ */
, 3/* Документация */
, 1/* МОДЕЛЬ */
, 2/* Приложение */ )) /* Тип платформы */
;
GO
alter  table GENERATOR_TARGET add 
QueueName
 VARCHAR (255) null /* Очередь */
;
GO
alter  table GENERATOR_TARGET add 
GeneratorProgID
 VARCHAR (255) null /* COM класс */
;
GO
alter  table GENERATOR_TARGET add 
GeneratorStyle
 INTEGER null 
 check (GeneratorStyle in ( 0/* Один тип */
, 1/* Все типы сразу */ )) /* Вариант */
;
GO
alter  table GENERATOR_TARGET add 
TheDevelopmentEnv
 INTEGER null 
 check (TheDevelopmentEnv in ( 2/* JAVA */
, 3/* OTHER */
, 1/* DOTNET */
, 0/* VB6 */ )) /* Среда разработки */
;
GO


/*Ручной код*/
create table GENMANUALCODE/*Код, который не укладывается в описание модели*/ (
ParentStructRowID uuid not null,
GENMANUALCODEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GENMANUALCODE add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table GENMANUALCODE add 
the_Alias
 VARCHAR (80) null /* Псевдоним */
;
GO
alter  table GENMANUALCODE add 
Code
 TEXT null /* Код */
;
GO


/*Контрольные элементы*/
create table GENCONTROLS/*Контрольные элементы, которые используются при генерации*/ (
ParentStructRowID uuid not null,
GENCONTROLSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GENCONTROLS add 
ControlProgID
 VARCHAR (255) null /* ProgID контрольконо элемента */
;
GO
alter  table GENCONTROLS add 
ControlClassID
 VARCHAR (40) null /* Класс контрольногоэлемента */
;
GO
alter  table GENCONTROLS add 
VersionMajor
 integer null /* Версия */
;
GO
alter  table GENCONTROLS add 
VersionMinor
 integer null /* Подверсия */
;
GO


/*Библиотеки*/
create table GENREFERENCE/*Библиотеки, которые используются при генерации*/ (
ParentStructRowID uuid not null,
GENREFERENCEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GENREFERENCE add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table GENREFERENCE add 
RefClassID
 VARCHAR (40) null /* Класс ссылки */
;
GO
alter  table GENREFERENCE add 
VersionMajor
 integer null /* Номер версии */
;
GO
alter  table GENREFERENCE add 
VersionMinor
 integer null /* Подверсия */
;
GO


/*Локализация*/
create table LocalizeInfo/**/ (
InstanceID uuid ,
LocalizeInfoid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table LocalizeInfo add 
LangFull
 VARCHAR (255) null /* Язык - название */
;
GO
alter  table LocalizeInfo add 
LangShort
 VARCHAR (255) null /* Код языка */
;
GO


/*Зоны*/
create table Num_zones/*Зоны уникальных нумеров*/ (
InstanceID uuid ,
Num_zonesid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Num_zones add 
ZoneMask
 VARCHAR (255) null /* Маска зоны */
;
GO


/*Номера*/
create table Num_Values/*уникальные номера*/ (
ParentStructRowID uuid not null,
Num_Valuesid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Num_Values add 
the_Value
 integer null /* Значение */
;
GO
alter  table Num_Values add 
OwnerPartName
 VARCHAR (64) null /* Раздел */
;
GO
alter  table Num_Values add 
OwnerRowID
 uuid null /* Идентификатор строки */
;
GO


/*Описание*/
create table Num_head/*Описание нумератора*/ (
InstanceID uuid ,
Num_headid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Num_head add 
Name
 VARCHAR (80) null /* Название */
;
GO
alter  table Num_head add 
Shema
 INTEGER null 
 check (Shema in ( 0/* Единая зона */
, 1/* По году */
, 4/* По дню */
, 2/* По кварталу */
, 3/* По месяцу */
, 10/* Произвольные зоны */ )) /* Схема нумерации */
;
GO


/*Настройка*/
create table Ext_Photos/**/ (
InstanceID uuid ,
Ext_Photosid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Ext_Photos add 
TheName
 VARCHAR (255) null /* Название */
;
GO
alter  table Ext_Photos add 
TheSourceObject
 VARCHAR (255) null /* Исходный объект (Тип) */
;
GO
alter  table Ext_Photos add 
TheJournal
 uuid null /* Журнал */
;
GO
alter  table Ext_Photos add 
TheReplacedPart
 VARCHAR (255) null /* Подменяемая часть */
;
GO
alter  table Ext_Photos add 
TheRefFieldName
 VARCHAR (255) null /* Поле ссылка на добавление */
;
GO


/*Вызов изображения*/
create table Ext_Photo_Call/**/ (
ParentStructRowID uuid not null,
Ext_Photo_Callid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Ext_Photo_Call add 
TargetPlatform
 uuid null /* TargetPlatform */
;
GO
alter  table Ext_Photo_Call add 
TheCallString
 VARCHAR (255) null /* Вызов */
;
GO


/*Данные файла*/
create table INVF_DEF/*Данные файла*/ (
InstanceID uuid ,
INVF_DEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVF_DEF add 
ThePath
 VARCHAR (255) null /* Название файла */
;
GO
alter  table INVF_DEF add 
TheHash
 VARCHAR (50) null /* MD5 Хэш */
;
GO
alter  table INVF_DEF add 
LoadDate
 timestamp null /* Дата загрузки */
;
GO
alter  table INVF_DEF add 
TheUser
 uuid null /* Оператор */
;
GO
alter  table INVF_DEF add 
TypeOfFile
 VARCHAR (50) null /* Тип файла */
;
GO


/*Описание прав*/
create table MTZSEC_RIGHT/*описание прав для каждой группы*/ (
InstanceID uuid ,
MTZSEC_RIGHTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZSEC_RIGHT add 
Piority
 integer null /* Приоритет */
;
GO
alter  table MTZSEC_RIGHT add 
TheGroup
 uuid null /* Группа */
;
GO
alter  table MTZSEC_RIGHT add 
ProtectedItem
 VARCHAR (255) null /* Защищаемый элемент */
;
GO
alter  table MTZSEC_RIGHT add 
Allow
 INTEGER null 
 check (Allow in ( -1/* Да */
, 0/* Нет */ )) /* Разрешение */
;
GO


/*Аренда*/
create table INVOS_RENT/*Данные об аренде*/ (
InstanceID uuid ,
INVOS_RENTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_RENT add 
StartDate
 date null /* Дата начала аренды */
;
GO
alter  table INVOS_RENT add 
EndDate
 date null /* Дата завершения аренды */
;
GO
alter  table INVOS_RENT add 
arendator
 uuid null /* Арендатор */
;
GO
alter  table INVOS_RENT add 
ADog
 VARCHAR (80) null /* Договор аренды */
;
GO
alter  table INVOS_RENT add 
DocNumber
 VARCHAR (80) null /* Номер приказа */
;
GO


/*Движение*/
create table INVOS_HIST/*Изменения положения*/ (
InstanceID uuid ,
INVOS_HISTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_HIST add 
UntilDate
 timestamp null /* Значение до */
;
GO
alter  table INVOS_HIST add 
ChangedBy
 uuid null /* Изменена пользователем */
;
GO
alter  table INVOS_HIST add 
MatOtv
 uuid null /* Матерально отв. */
;
GO
alter  table INVOS_HIST add 
ComplNumber
 VARCHAR (30) null /* Номер комплекта */
;
GO
alter  table INVOS_HIST add 
DIrection
 uuid null /* Дирекция */
;
GO
alter  table INVOS_HIST add 
Uprav
 uuid null /* Управление */
;
GO
alter  table INVOS_HIST add 
Otdel
 uuid null /* Отдел */
;
GO
alter  table INVOS_HIST add 
TheHouse
 uuid null /* Здание */
;
GO
alter  table INVOS_HIST add 
Flow
 VARCHAR (10) null /* Этаж */
;
GO
alter  table INVOS_HIST add 
Room
 VARCHAR (10) null /* Кабинет */
;
GO
alter  table INVOS_HIST add 
WorkPlaceNum
 VARCHAR (10) null /* Номер рабочего места */
;
GO
alter  table INVOS_HIST add 
TheOwner
 uuid null /* Владелец */
;
GO


/*Причина списания*/
create table INVOS_OFFRULE/*Причина списания*/ (
InstanceID uuid ,
INVOS_OFFRULEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_OFFRULE add 
INFO
 VARCHAR (255) null /* Причина списания */
;
GO
alter  table INVOS_OFFRULE add 
DocNumber
 VARCHAR (80) null /* № Документа */
;
GO
alter  table INVOS_OFFRULE add 
DocDate
 date null /* Дата документа */
;
GO
alter  table INVOS_OFFRULE add 
TheComment
 TEXT null /* Примечание */
;
GO


/*Пересчет сроков ПИ*/
create table INVOS_SROK/*Пересчет сроков ПИ*/ (
InstanceID uuid ,
INVOS_SROKid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_SROK add 
RecalcDate
 date null /* Дата следующего пересчета срока */
;
GO


/*Техническая информация*/
create table INVOS_TECH/*Техническая информация ( описание вычислительной техники)*/ (
InstanceID uuid ,
INVOS_TECHid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_TECH add 
MAC_Addr
 VARCHAR (30) null /* MAC_Addr */
;
GO
alter  table INVOS_TECH add 
Computer_Name
 VARCHAR (128) null /* Computer_Name */
;
GO
alter  table INVOS_TECH add 
IP_Addr
 VARCHAR (100) null /* IP_Addr */
;
GO
alter  table INVOS_TECH add 
Current_User_Name
 VARCHAR (100) null /* Current_User_Name */
;
GO
alter  table INVOS_TECH add 
System
 VARCHAR (100) null /* System */
;
GO
alter  table INVOS_TECH add 
Record_Date
 VARCHAR (30) null /* Record_Date */
;
GO
alter  table INVOS_TECH add 
Param_0
 VARCHAR (100) null /* Param_0 */
;
GO


/*Windows soft*/
create table INVOS_WINSOFT/**/ (
ParentStructRowID uuid not null,
INVOS_WINSOFTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_WINSOFT add 
Name
 VARCHAR (100) null /* Name */
;
GO
alter  table INVOS_WINSOFT add 
ParamValue
 TEXT null /* Value */
;
GO


/*Computer*/
create table INVOS_COMP/**/ (
ParentStructRowID uuid not null,
INVOS_COMPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_COMP add 
Name
 VARCHAR (100) null /* Name */
;
GO
alter  table INVOS_COMP add 
ParamValue
 TEXT null /* Value */
;
GO


/*Hardware*/
create table INVOS_HARD/**/ (
ParentStructRowID uuid not null,
INVOS_HARDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_HARD add 
Name
 VARCHAR (100) null /* Name */
;
GO
alter  table INVOS_HARD add 
ParamValue
 TEXT null /* Value */
;
GO


/*Current Config*/
create table INVOS_CURCFG/**/ (
ParentStructRowID uuid not null,
INVOS_CURCFGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_CURCFG add 
Name
 VARCHAR (100) null /* Name */
;
GO
alter  table INVOS_CURCFG add 
ParamValue
 TEXT null /* Value */
;
GO


/*Config changes*/
create table INVOS_CFGCH/**/ (
ParentStructRowID uuid not null,
INVOS_CFGCHid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_CFGCH add 
ChDate
 timestamp null /* Date */
;
GO
alter  table INVOS_CFGCH add 
ChNum
 integer null /* Change number */
;
GO
alter  table INVOS_CFGCH add 
TheValue
 TEXT null /* Value */
;
GO


/*Windows Devices*/
create table INVOS_DEVICES/*Windows Devices*/ (
ParentStructRowID uuid not null,
INVOS_DEVICESid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_DEVICES add 
Name
 VARCHAR (100) null /* Name */
;
GO
alter  table INVOS_DEVICES add 
ParamValue
 TEXT null /* Value */
;
GO


/*Содержание драг. металов*/
create table INVOS_DRAG/**/ (
InstanceID uuid ,
INVOS_DRAGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_DRAG add 
DragMet
 uuid null /* Драг. металл */
;
GO
alter  table INVOS_DRAG add 
Q
 float null /* Содержание */
;
GO


/*Документы*/
create table INVOS_DOCS/**/ (
InstanceID uuid ,
INVOS_DOCSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_DOCS add 
InOrderNum
 VARCHAR (30) null /* Номер приходного ордера */
;
GO
alter  table INVOS_DOCS add 
NaklNum
 VARCHAR (30) null /* Номер накладной */
;
GO
alter  table INVOS_DOCS add 
Contragent
 uuid null /* Контрагент */
;
GO
alter  table INVOS_DOCS add 
DogNum
 VARCHAR (30) null /* Номер договора */
;
GO
alter  table INVOS_DOCS add 
AccNum
 VARCHAR (30) null /* Номер счета */
;
GO
alter  table INVOS_DOCS add 
AccFNum
 VARCHAR (30) null /* Номер счета фактуры */
;
GO
alter  table INVOS_DOCS add 
ActivateNum
 VARCHAR (30) null /* Номер ввода в эксплуатацию */
;
GO


/*Отметки об инвентаризации*/
create table INVOS_INV/*Отметки об инвентаризации*/ (
InstanceID uuid ,
INVOS_INVid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_INV add 
Inventory
 uuid null /* Инвентаризация */
;
GO
alter  table INVOS_INV add 
InvDate
 timestamp null /* Дата инвентаризации */
;
GO
alter  table INVOS_INV add 
OSStatus
 uuid null /* Состояние */
;
GO


/*Лизинг*/
create table INVOS_LIZING/*Лизинг*/ (
InstanceID uuid ,
INVOS_LIZINGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_LIZING add 
DocNumber
 VARCHAR (80) null /* Номер договора */
;
GO
alter  table INVOS_LIZING add 
TheDate
 date null /* Дата  передачи */
;
GO
alter  table INVOS_LIZING add 
TheAgent
 uuid null /* Контрагент */
;
GO


/*Консервация*/
create table INVOS_CNSRV/*Консервация*/ (
InstanceID uuid ,
INVOS_CNSRVid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_CNSRV add 
DocNumber
 VARCHAR (80) null /* Номер приказа */
;
GO
alter  table INVOS_CNSRV add 
StartDate
 date null /* Дата начала */
;
GO
alter  table INVOS_CNSRV add 
EndDate
 date null /* Дата завершения */
;
GO


/*Общие сведения*/
create table INVOS_INFO/*Общие сведения об основном среддстве*/ (
InstanceID uuid ,
INVOS_INFOid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_INFO add 
TheOrg
 uuid null /* На учете в  */
;
GO
alter  table INVOS_INFO add 
IsMaterial
 INTEGER null 
 check (IsMaterial in ( -1/* Да */
, 0/* Нет */ )) /* Материал */
;
GO
alter  table INVOS_INFO add 
OSType
 uuid null /* Группа ОС */
;
GO
alter  table INVOS_INFO add 
Name
 VARCHAR (255) null /* Наименование */
;
GO
alter  table INVOS_INFO add 
ShortName
 VARCHAR (100) null /* Краткое наименование */
;
GO
alter  table INVOS_INFO add 
CardNum
 VARCHAR (30) null /* Номер карточки учета */
;
GO
alter  table INVOS_INFO add 
INVNum
 VARCHAR (30) null /* Инвентарный номер */
;
GO
alter  table INVOS_INFO add 
CreateNum
 button null /* Присвоить № */
;
GO
alter  table INVOS_INFO add 
InLineNum
 integer null /* Номер в партии */
;
GO
alter  table INVOS_INFO add 
TheCost
 float null /* Cтоимость */
;
GO
alter  table INVOS_INFO add 
SrokPI
 integer null /* Срок ПИ */
;
GO
alter  table INVOS_INFO add 
SrokFI
 integer null /* Срок ФИ */
;
GO
alter  table INVOS_INFO add 
SrokOI
 integer null /* Остаточный срок ПИ */
;
GO
alter  table INVOS_INFO add 
ActivateDate
 date null /* Дата ввода в эксп. */
;
GO
alter  table INVOS_INFO add 
Info
 TEXT null /* Описание */
;
GO
alter  table INVOS_INFO add 
TechFilePath
 VARCHAR (255) null /* Путь к файлу  с ТИ */
;
GO


/*Модернизация*/
create table INVOS_MOD/*Модернизация*/ (
InstanceID uuid ,
INVOS_MODid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_MOD add 
DocNumber
 VARCHAR (80) null /* Номер приказа */
;
GO
alter  table INVOS_MOD add 
StartDate
 date null /* Дата начала */
;
GO
alter  table INVOS_MOD add 
EndDate
 date null /* Дата завершения */
;
GO
alter  table INVOS_MOD add 
INFO
 TEXT null /* Суть модернизации */
;
GO


/*Заметки о сосотоянии*/
create table INVOS_CMNT/*Заметки о сосотоянии*/ (
InstanceID uuid ,
INVOS_CMNTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_CMNT add 
TheCommenter
 uuid null /* Запись сделал */
;
GO
alter  table INVOS_CMNT add 
TheDate
 date null /* Дата записи */
;
GO
alter  table INVOS_CMNT add 
Info
 VARCHAR (250) null /* Информация */
;
GO
alter  table INVOS_CMNT add 
TheComment
 TEXT null /* Примечание */
;
GO
alter  table INVOS_CMNT add 
ThePhoto
 BYTEA null /* Фотография */
;
GO


/*Штрихкод*/
create table INVOS_CODE/*Штрихкод ОС*/ (
InstanceID uuid ,
INVOS_CODEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_CODE add 
ShCode
 VARCHAR (255) null /* Штрихкод */
;
GO
alter  table INVOS_CODE add 
VisibleCode
 VARCHAR (255) null /* Читаемый код */
;
GO
alter  table INVOS_CODE add 
CodePrinted
 INTEGER null 
 check (CodePrinted in ( -1/* Да */
, 0/* Нет */ )) /* Штрихкод напечатан */
;
GO
alter  table INVOS_CODE add 
MabualCreate
 INTEGER null 
 check (MabualCreate in ( -1/* Да */
, 0/* Нет */ )) /* Создан вручную */
;
GO


/*Ремонт*/
create table INVOS_REPAIR/*Данные по ремонту*/ (
InstanceID uuid ,
INVOS_REPAIRid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_REPAIR add 
StartDate
 date null /* Дата начала ремонта */
;
GO
alter  table INVOS_REPAIR add 
EndDate
 date null /* Дата завершения ремонта */
;
GO
alter  table INVOS_REPAIR add 
INFO
 TEXT null /* Вид ремонта */
;
GO
alter  table INVOS_REPAIR add 
DocNumber
 VARCHAR (80) null /* Номер приказа */
;
GO


/*Принадлежность*/
create table INVOS_PLACE/*Принадлежность и метоположение*/ (
InstanceID uuid ,
INVOS_PLACEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVOS_PLACE add 
MatOtv
 uuid null /* Матерально отв. */
;
GO
alter  table INVOS_PLACE add 
TheHouse
 uuid null /* Здание */
;
GO
alter  table INVOS_PLACE add 
ComplNumber
 VARCHAR (30) null /* Номер комплекта */
;
GO
alter  table INVOS_PLACE add 
DIrection
 uuid null /* Дирекция */
;
GO
alter  table INVOS_PLACE add 
Uprav
 uuid null /* Управление */
;
GO
alter  table INVOS_PLACE add 
Otdel
 uuid null /* Отдел */
;
GO
alter  table INVOS_PLACE add 
Flow
 VARCHAR (10) null /* Этаж */
;
GO
alter  table INVOS_PLACE add 
Room
 VARCHAR (10) null /* Кабинет */
;
GO
alter  table INVOS_PLACE add 
WorkPlaceNum
 VARCHAR (10) null /* Номер рабочего места */
;
GO
alter  table INVOS_PLACE add 
TheOwner
 uuid null /* Владелец */
;
GO
alter  table INVOS_PLACE add 
Info
 TEXT null /* Описание */
;
GO


/*Описание*/
create table Reports/*Описание*/ (
InstanceID uuid ,
Reportsid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Reports add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table Reports add 
ReportFile
 bytea null /* Файл отчета */
;
GO
alter  table Reports add 
 ReportFile_EXT char(4) null
;
GO
alter  table Reports add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table Reports add 
PrepareMethod
 uuid null /* Метод для формирования */
;
GO
alter  table Reports add 
ReportType
 INTEGER null 
 check (ReportType in ( 1/* Двумерная матрица */
, 0/* Таблица */
, 3/* Экспорт по WORD шаблону */
, 2/* Только расчет */
, 4/* Экспорт по Excel шаблону */ )) /* Тип отчета */
;
GO
alter  table Reports add 
TheReportExt
 uuid null /* Расширение для создания отчета */
;
GO
alter  table Reports add 
ReportView
 VARCHAR (255) null /* Базовый запрос */
;
GO
alter  table Reports add 
TheComment
 TEXT null /* Описание */
;
GO


/*Секции*/
create table RPTStruct/*Секции*/ (
InstanceID uuid ,
RPTStructid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
,ParentRowid uuid 
)
;
GO
alter  table RPTStruct add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table RPTStruct add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO


/*Поля секции*/
create table RPTFields/*Поля секции*/ (
ParentStructRowID uuid not null,
RPTFieldsid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table RPTFields add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table RPTFields add 
FieldType
 uuid null /* Тип поля */
;
GO
alter  table RPTFields add 
FieldSize
 integer null /* Размер */
;
GO
alter  table RPTFields add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO


/*Формулы*/
create table RPTFormula/*Формулы*/ (
InstanceID uuid ,
RPTFormulaid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table RPTFormula add 
Name
 VARCHAR (64) null /* Название */
;
GO
alter  table RPTFormula add 
Code
 TEXT null /* Выражение */
;
GO
alter  table RPTFormula add 
Platform
 uuid null /* Платформа */
;
GO


/*Пользователи*/
create table Users/*Пользователи*/ (
InstanceID uuid ,
Usersid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Users add 
Family
 VARCHAR (255) null /* Фамилия */
;
GO
alter  table Users add 
Name
 VARCHAR (64) null /* Имя */
;
GO
alter  table Users add 
SurName
 VARCHAR (255) null /* Отчество */
;
GO
alter  table Users add 
Login
 VARCHAR (64) null /* Имя для входа */
;
GO
alter  table Users add 
Password varchar(80) null /* Пароль */
;
GO
alter  table Users add 
DomaiName
 VARCHAR (255) null /* Доменное имя */
;
GO
alter  table Users add 
EMail varchar(255) null /* e-mail */
;
GO
alter  table Users add 
Phone
 VARCHAR (20) null /* Телефон */
;
GO
alter  table Users add 
LocalPhone
 VARCHAR (20) null /* Местный телефон */
;
GO
alter  table Users add 
MobilePhone
 VARCHAR (20) null /* Мобильный телефон */
;
GO
alter  table Users add 
Photo
 BYTEA null /* Фото */
;
GO
alter  table Users add 
BirthDay
 date null /* Дата рождения */
;
GO
alter  table Users add 
Activity
 uuid null /* Журнал активности */
;
GO
alter  table Users add 
CertificateID
 VARCHAR (255) null /* CertificateID */
;
GO
alter  table Users add 
CertData
 TEXT null /* CertData */
;
GO
alter  table Users add 
ClientDef
 uuid null /* Ассоциация с клиентом */
;
GO
alter  table Users add 
PersonaData
 uuid null /* PersonaData */
;
GO
alter  table Users add 
PositionU
 VARCHAR (255) null /* Должность */
;
GO
alter  table Users add 
WorkPlace
 VARCHAR (255) null /* Место работы */
;
GO


/*Группы*/
create table Groups/*Группы*/ (
InstanceID uuid ,
Groupsid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Groups add 
Name
 VARCHAR (80) null /* Название */
;
GO


/*Состав группы*/
create table GroupUser/*Состав группы*/ (
ParentStructRowID uuid not null,
GroupUserid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table GroupUser add 
TheUser
 uuid null /* Пользователь */
;
GO


/*Журнал событий*/
create table SysLog/*Журнал событий, которые произошли в системе*/ (
InstanceID uuid ,
SysLogid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table SysLog add 
TheSession
 uuid null /* Сессия */
;
GO
alter  table SysLog add 
the_Resource
 VARCHAR (255) null /* Ресурс */
;
GO
alter  table SysLog add 
LogStructID
 VARCHAR (255) null /* Раздел с которым происхоит действие */
;
GO
alter  table SysLog add 
VERB
 VARCHAR (80) null /* Действие */
;
GO
alter  table SysLog add 
LogInstanceID
 uuid null /* Идентификатор документа */
;
GO


/*Сессия пользователя*/
create table the_Session/*Зарегистрированные сессии пользователей*/ (
InstanceID uuid ,
the_Sessionid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table the_Session add 
UserRole
 uuid null /* Текущая роль пользователя */
;
GO
alter  table the_Session add 
ClosedAt
 timestamp null /* Момент закрытия */
;
GO
alter  table the_Session add 
Closed
 integer null 
 check (Closed in ( 1/* Да */
, 0/* Нет */ )) /* Закрыта */
;
GO
alter  table the_Session add 
Usersid
 uuid null /* Пользователь */
;
GO
alter  table the_Session add 
LastAccess
 timestamp null /* Последнее подтверждение */
;
GO
alter  table the_Session add 
StartAt
 timestamp null /* Момент открытия */
;
GO
alter  table the_Session add 
Lang
 VARCHAR (25) null /* Локализация */
;
GO


/*Роботы журнала событий*/
create table LogReader/*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
InstanceID uuid ,
LogReaderid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table LogReader add 
Name
 VARCHAR (80) null /* Название */
;
GO
alter  table LogReader add 
AutoStart
 integer null 
 check (AutoStart in ( 1/* Да */
, 0/* Нет */ )) /* Автоматизированный запуск */
;
GO
alter  table LogReader add 
AutoProgid
 VARCHAR (255) null /* Класс для автоматического запуска */
;
GO
alter  table LogReader add 
ReadMarker
 timestamp null /* Дата последней прочитанной записи */
;
GO
alter  table LogReader add 
StartInterval
 integer null /* Интервал запуска (мин) */
;
GO
alter  table LogReader add 
LastStart
 timestamp null /* Дата последнего запуска */
;
GO
alter  table LogReader add 
LastStop
 timestamp null /* Дата последне останвки */
;
GO


/*Действия*/
create table Verb/*Защищаемые системой дейсвия*/ (
InstanceID uuid ,
Verbid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Verb add 
Name
 VARCHAR (80) null /* Название */
;
GO


/*Пользователи*/
create table ROLES_USER/*Пользователи*/ (
InstanceID uuid ,
ROLES_USERid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_USER add 
TheUser
 uuid null /* Пользователь */
;
GO


/*Отображение на группы защиты*/
create table ROLES_MAP/*Отображение на группы защиты*/ (
InstanceID uuid ,
ROLES_MAPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_MAP add 
TheGroup
 uuid null /* Группа */
;
GO


/*Доступные документы*/
create table ROLES_DOC/**/ (
InstanceID uuid ,
ROLES_DOCid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_DOC add 
The_Document
 uuid null /* Тип документа */
;
GO
alter  table ROLES_DOC add 
The_Denied
 integer null 
 check (The_Denied in ( 1/* Да */
, 0/* Нет */ )) /* Запрещен */
;
GO
alter  table ROLES_DOC add 
AllowDeleteDoc
 INTEGER null 
 check (AllowDeleteDoc in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удаление */
;
GO


/*Доступные состояния*/
create table ROLES_DOC_STATE/**/ (
ParentStructRowID uuid not null,
ROLES_DOC_STATEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_DOC_STATE add 
The_State
 uuid null /* Состояние */
;
GO
alter  table ROLES_DOC_STATE add 
The_Mode
 uuid null /* Режим */
;
GO
alter  table ROLES_DOC_STATE add 
AllowDelete
 INTEGER null 
 check (AllowDelete in ( -1/* Да */
, 0/* Нет */ )) /* Можно удалять */
;
GO
alter  table ROLES_DOC_STATE add 
StateChangeDisabled
 INTEGER null 
 check (StateChangeDisabled in ( -1/* Да */
, 0/* Нет */ )) /* Запрещена смена состояния */
;
GO


/*Определение роли*/
create table ROLES_DEF/*Определение роли*/ (
InstanceID uuid ,
ROLES_DEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_DEF add 
name
 VARCHAR (255) null /* Название */
;
GO
alter  table ROLES_DEF add 
TheComment
 TEXT null /* Описание */
;
GO
alter  table ROLES_DEF add 
RightsSet_Denied
 INTEGER null 
 check (RightsSet_Denied in ( -1/* Да */
, 0/* Нет */ )) /* Настройка прав запрещена */
;
GO
alter  table ROLES_DEF add 
FormCFG_Denied
 INTEGER null 
 check (FormCFG_Denied in ( -1/* Да */
, 0/* Нет */ )) /* Настройки форм запрещены */
;
GO
alter  table ROLES_DEF add 
ListCFG_Denied
 INTEGER null 
 check (ListCFG_Denied in ( -1/* Да */
, 0/* Нет */ )) /* Настройка журналов запрещена */
;
GO
alter  table ROLES_DEF add 
FileExch_Denied
 INTEGER null 
 check (FileExch_Denied in ( -1/* Да */
, 0/* Нет */ )) /* Файловый обмен запрещен */
;
GO


/*Отчёты*/
create table ROLES_REPORTS/**/ (
InstanceID uuid ,
ROLES_REPORTSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_REPORTS add 
The_Report
 uuid null /* Отчёт */
;
GO


/*Доступные приложения*/
create table ROLES_WP/*Доступные приложения*/ (
InstanceID uuid ,
ROLES_WPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ROLES_WP add 
WP
 uuid null /* Приложение */
;
GO


/*Допустимые действия*/
create table ROLES_ACT/*Допустимые действия*/ (
ParentStructRowID uuid not null,
ROLES_ACTid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
,ParentRowid uuid 
)
;
GO
alter  table ROLES_ACT add 
Accesible
 integer null 
 check (Accesible in ( 1/* Да */
, 0/* Нет */ )) /* Доступность */
;
GO
alter  table ROLES_ACT add 
EntryPoints
 uuid null /* Доступные действия */
;
GO


/*Арм*/
create table WorkPlace/*Арм*/ (
InstanceID uuid ,
WorkPlaceid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table WorkPlace add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table WorkPlace add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table WorkPlace add 
TheVersion
 VARCHAR (30) null /* Версия */
;
GO
alter  table WorkPlace add 
ThePlatform
 INTEGER null 
 check (ThePlatform in ( 2/* JAVA */
, 3/* OTHER */
, 1/* DOTNET */
, 0/* VB6 */ )) /* Платформа реализации */
;
GO
alter  table WorkPlace add 
TheComment
 TEXT null /* Примечание */
;
GO


/*Меню*/
create table EntryPoints/*Меню*/ (
InstanceID uuid ,
EntryPointsid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
,ParentRowid uuid 
)
;
GO
alter  table EntryPoints add 
sequence
 integer null /* Последовательность */
;
GO
alter  table EntryPoints add 
Name
 VARCHAR (38) null /* Название */
;
GO
alter  table EntryPoints add 
Caption
 VARCHAR (255) null /* Заголовок */
;
GO
alter  table EntryPoints add 
AsToolbarItem
 INTEGER null 
 check (AsToolbarItem in ( -1/* Да */
, 0/* Нет */ )) /* Включить в тулбар */
;
GO
alter  table EntryPoints add 
ActionType
 INTEGER null 
 check (ActionType in ( 5/* Открыть отчет */
, 0/* Ничего не делать */
, 2/* Выполнить метод */
, 1/* Открыть документ */
, 4/* Запустить АРМ */
, 3/* Открыть журнал */ )) /* Вариант действия */
;
GO
alter  table EntryPoints add 
TheFilter
 uuid null /* Фильтр */
;
GO
alter  table EntryPoints add 
Journal
 uuid null /* Журнал */
;
GO
alter  table EntryPoints add 
Report
 uuid null /* Отчет */
;
GO
alter  table EntryPoints add 
Document
 uuid null /* Документ */
;
GO
alter  table EntryPoints add 
Method
 uuid null /* Метод */
;
GO
alter  table EntryPoints add 
IconFile
 VARCHAR (2000) null /* Файл картинки */
;
GO
alter  table EntryPoints add 
TheExtention
 uuid null /* Расширение */
;
GO
alter  table EntryPoints add 
ARM
 uuid null /* АРМ */
;
GO
alter  table EntryPoints add 
TheComment
 TEXT null /* Примечание */
;
GO
alter  table EntryPoints add 
ObjectType
 uuid null /* Тип документа */
;
GO
alter  table EntryPoints add 
JournalFixedQuery
 TEXT null /* Ограничения к журналу */
;
GO
alter  table EntryPoints add 
AllowAdd
 INTEGER null 
 check (AllowAdd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавление */
;
GO
alter  table EntryPoints add 
AllowEdit
 INTEGER null 
 check (AllowEdit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено редактирование */
;
GO
alter  table EntryPoints add 
AllowDel
 INTEGER null 
 check (AllowDel in ( -1/* Да */
, 0/* Нет */ )) /* Рарешено удаление */
;
GO
alter  table EntryPoints add 
AllowFilter
 INTEGER null 
 check (AllowFilter in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен фильтр */
;
GO
alter  table EntryPoints add 
AllowPrint
 INTEGER null 
 check (AllowPrint in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена печать */
;
GO


/*Привязка фильтра*/
create table EPFilterLink/*Привязка фильтра к журналу*/ (
ParentStructRowID uuid not null,
EPFilterLinkid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table EPFilterLink add 
RowSource
 VARCHAR (255) null /* Источник */
;
GO
alter  table EPFilterLink add 
TheExpression
 TEXT null /* Выражение */
;
GO
alter  table EPFilterLink add 
FilterField
 VARCHAR (255) null /* Поле фильтра */
;
GO


/*Список типов*/
create table ARMTypes/*Типы документов, которые подключаются в MDI режиме*/ (
InstanceID uuid ,
ARMTypesid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ARMTypes add 
TheDocumentType
 uuid null /* Тип документа */
;
GO


/*Поведение журналов*/
create table ARMJournal/*Описание действий журанлов*/ (
InstanceID uuid ,
ARMJournalid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ARMJournal add 
TheJournal
 uuid null /* Журнал */
;
GO


/*Добавление*/
create table ARMJRNLADD/*Варианты обработки добавления*/ (
ParentStructRowID uuid not null,
ARMJRNLADDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ARMJRNLADD add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table ARMJRNLADD add 
TheExtention
 uuid null /* Расширение */
;
GO


/*Отчеты*/
create table ARMJRNLREP/*Отчеты из журнала*/ (
ParentStructRowID uuid not null,
ARMJRNLREPid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ARMJRNLREP add 
repname
 VARCHAR (255) null /* Название отчета */
;
GO
alter  table ARMJRNLREP add 
TheReport
 uuid null /* Отчет */
;
GO


/*Действия*/
create table ARMJRNLRUN/*Дополнительные действия в журнале*/ (
ParentStructRowID uuid not null,
ARMJRNLRUNid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table ARMJRNLRUN add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table ARMJRNLRUN add 
TheExtention
 uuid null /* Расширение */
;
GO


/*Управление*/
create table INVD_UPR/*Управление*/ (
InstanceID uuid ,
INVD_UPRid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_UPR add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table INVD_UPR add 
Code
 VARCHAR (10) null /* Код */
;
GO


/*Отдел*/
create table INVD_OTDEL/*Отдел*/ (
InstanceID uuid ,
INVD_OTDELid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_OTDEL add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table INVD_OTDEL add 
Code
 VARCHAR (10) null /* Код */
;
GO


/*Здание*/
create table INVD_BLD/*Здание*/ (
InstanceID uuid ,
INVD_BLDid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_BLD add 
Name
 VARCHAR (200) null /* Название */
;
GO
alter  table INVD_BLD add 
Addr
 TEXT null /* Адрес */
;
GO


/*Драг. металлы*/
create table INVD_DRAG/**/ (
InstanceID uuid ,
INVD_DRAGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_DRAG add 
Name
 VARCHAR (80) null /* Название */
;
GO
alter  table INVD_DRAG add 
edIzm
 VARCHAR (80) null /* Ед. изм. */
;
GO


/*Свои юр. лица*/
create table INVD_ORG/*Информация об организациях*/ (
InstanceID uuid ,
INVD_ORGid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_ORG add 
NumPrefix
 integer null 
 check (NumPrefix &gt;= 0 and NumPrefix &lt;= 49)/* Префикс инв. номера */
;
GO
alter  table INVD_ORG add 
FullName
 VARCHAR (255) null /* Наименование */
;
GO
alter  table INVD_ORG add 
SortName
 VARCHAR (255) null /* Краткое наименование */
;
GO
alter  table INVD_ORG add 
INN
 VARCHAR (12) null /* ИНН */
;
GO
alter  table INVD_ORG add 
KPP
 VARCHAR (12) null /* КПП */
;
GO
alter  table INVD_ORG add 
UrAddr
 TEXT null /* Юридический адрес */
;
GO
alter  table INVD_ORG add 
FaktAddr
 TEXT null /* Фактический адрес */
;
GO
alter  table INVD_ORG add 
Phone
 VARCHAR (80) null /* Телефон \ Факс */
;
GO


/*Состояние ОС*/
create table INVD_OSSTATUS/**/ (
InstanceID uuid ,
INVD_OSSTATUSid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_OSSTATUS add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table INVD_OSSTATUS add 
Code
 VARCHAR (10) null /* Код */
;
GO


/*Владелец*/
create table INVD_OWNER/*Владелец*/ (
InstanceID uuid ,
INVD_OWNERid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_OWNER add 
FamiliName
 VARCHAR (100) null /* Фамилия */
;
GO
alter  table INVD_OWNER add 
Name
 VARCHAR (100) null /* Имя */
;
GO
alter  table INVD_OWNER add 
SurName
 VARCHAR (100) null /* Отчество */
;
GO


/*Юридическое лицо*/
create table INVD_UR/*Юридическое лицо*/ (
InstanceID uuid ,
INVD_URid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_UR add 
FullName
 VARCHAR (255) null /* Наименование */
;
GO
alter  table INVD_UR add 
SortName
 VARCHAR (255) null /* Краткое наименование */
;
GO
alter  table INVD_UR add 
INN
 VARCHAR (12) null /* ИНН */
;
GO
alter  table INVD_UR add 
KPP
 VARCHAR (12) null /* КПП */
;
GO
alter  table INVD_UR add 
UrAddr
 TEXT null /* Юридический адрес */
;
GO
alter  table INVD_UR add 
FaktAddr
 TEXT null /* Фактический адрес */
;
GO
alter  table INVD_UR add 
Phone
 VARCHAR (80) null /* Телефон \ Факс */
;
GO


/*Тип основного средства*/
create table INVD_OSTYPE/*Тип основного средства*/ (
InstanceID uuid ,
INVD_OSTYPEid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_OSTYPE add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table INVD_OSTYPE add 
Code
 VARCHAR (10) null /* Код */
;
GO
alter  table INVD_OSTYPE add 
ShowTech
 INTEGER null 
 check (ShowTech in ( -1/* Да */
, 0/* Нет */ )) /* Отображать тех. инф. */
;
GO


/*Дирекция*/
create table INVD_DIR/*Дирекция*/ (
InstanceID uuid ,
INVD_DIRid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVD_DIR add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table INVD_DIR add 
Code
 VARCHAR (10) null /* Код */
;
GO


/*Сборки*/
create table MTZ_Inst_Build/**/ (
InstanceID uuid ,
MTZ_Inst_Buildid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ_Inst_Build add 
PRODUCT_NAME
 VARCHAR (255) null /* PRODUCT_NAME */
;
GO
alter  table MTZ_Inst_Build add 
PRODUCT_VERSION
 VARCHAR (255) null /* PRODUCT_VERSION */
;
GO
alter  table MTZ_Inst_Build add 
PRODUCT_PUBLISHER
 VARCHAR (255) null /* PRODUCT_PUBLISHER */
;
GO
alter  table MTZ_Inst_Build add 
PRODUCT_WEB_SITE
 VARCHAR (255) null /* PRODUCT_WEB_SITE */
;
GO
alter  table MTZ_Inst_Build add 
LicensFilePath
 VARCHAR (2048) null /* Файл с лицензионным соглашением */
;
GO
alter  table MTZ_Inst_Build add 
MainFileRef
 uuid null /* Главный файл */
;
GO
alter  table MTZ_Inst_Build add 
InstallDir
 VARCHAR (1024) null /* InstallDir */
;
GO
alter  table MTZ_Inst_Build add 
ShortCutDir
 VARCHAR (255) null /* ShortCutDir */
;
GO


/*Секции*/
create table MTZ_Inst_Build_Sec/**/ (
ParentStructRowID uuid not null,
MTZ_Inst_Build_Secid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ_Inst_Build_Sec add 
TheSection
 uuid null /* Секция */
;
GO
alter  table MTZ_Inst_Build_Sec add 
TheDescription
 VARCHAR (255) null /* Комментарий */
;
GO
alter  table MTZ_Inst_Build_Sec add 
IsRewriteSectionDesc
 integer null 
 check (IsRewriteSectionDesc in ( 1/* Да */
, 0/* Нет */ )) /* Перезаписывать комментарий секции */
;
GO
alter  table MTZ_Inst_Build_Sec add 
SEQ
 integer null /* Порядок (от 1 до ...) */
;
GO


/*Секции*/
create table MTZ_Inst_Section/**/ (
InstanceID uuid ,
MTZ_Inst_Sectionid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ_Inst_Section add 
TheName
 VARCHAR (255) null /* Название (Eng) */
;
GO
alter  table MTZ_Inst_Section add 
IsVisible
 integer null 
 check (IsVisible in ( 1/* Да */
, 0/* Нет */ )) /* Видимая */
;
GO
alter  table MTZ_Inst_Section add 
TheDescription
 VARCHAR (2048) null /* Комментарий (ToolTip) */
;
GO
alter  table MTZ_Inst_Section add 
IsNotDeletable
 integer null 
 check (IsNotDeletable in ( 1/* Да */
, 0/* Нет */ )) /* Обязательная */
;
GO
alter  table MTZ_Inst_Section add 
TheTargetPlatform
 INTEGER null 
 check (TheTargetPlatform in ( 2/* JAVA */
, 3/* OTHER */
, 1/* DOTNET */
, 0/* VB6 */ )) /* Целевая платформа */
;
GO
alter  table MTZ_Inst_Section add 
IsCustomSection
 integer null 
 check (IsCustomSection in ( 1/* Да */
, 0/* Нет */ )) /* Custom Section */
;
GO
alter  table MTZ_Inst_Section add 
CustomSectionInstall
 uuid null /* Custom Section Install */
;
GO
alter  table MTZ_Inst_Section add 
CustomSectionUnInstall
 uuid null /* Custom Section UnInstall */
;
GO


/*Файлы секции*/
create table MTZ_Inst_Sec_Files/**/ (
ParentStructRowID uuid not null,
MTZ_Inst_Sec_Filesid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ_Inst_Sec_Files add 
TheSource
 VARCHAR (1024) null /* Файл или каталог */
;
GO
alter  table MTZ_Inst_Sec_Files add 
IsCOM
 integer null 
 check (IsCOM in ( 1/* Да */
, 0/* Нет */ )) /* Является COM объектом */
;
GO
alter  table MTZ_Inst_Sec_Files add 
HaveToRun
 integer null 
 check (HaveToRun in ( 1/* Да */
, 0/* Нет */ )) /* Обязательно запустить */
;
GO
alter  table MTZ_Inst_Sec_Files add 
CommanLineParams
 VARCHAR (255) null /* Ключи запуска */
;
GO
alter  table MTZ_Inst_Sec_Files add 
SysstemObject
 uuid null /* Объект системы */
;
GO
alter  table MTZ_Inst_Sec_Files add 
TheApplication
 uuid null /* Приложение системы */
;
GO
alter  table MTZ_Inst_Sec_Files add 
SubDir
 VARCHAR (255) null /* Подкаталог */
;
GO
alter  table MTZ_Inst_Sec_Files add 
IsShortcut
 integer null 
 check (IsShortcut in ( 1/* Да */
, 0/* Нет */ )) /* Ярлык в меню */
;
GO
alter  table MTZ_Inst_Sec_Files add 
ShortcutName
 VARCHAR (255) null /* Имя ярлыка */
;
GO
alter  table MTZ_Inst_Sec_Files add 
ShortCutInfo
 VARCHAR (255) null /* Комментярий ярлыка */
;
GO
alter  table MTZ_Inst_Sec_Files add 
DefaultInterface
 VARCHAR (255) null /* Интерфейс по умолчанию */
;
GO
alter  table MTZ_Inst_Sec_Files add 
HaveToRunDeinst
 integer null 
 check (HaveToRunDeinst in ( 1/* Да */
, 0/* Нет */ )) /* Запустить при деинсталляции */
;
GO
alter  table MTZ_Inst_Sec_Files add 
DeinstallComandParam
 VARCHAR (255) null /* Ключи деинсталляции */
;
GO
alter  table MTZ_Inst_Sec_Files add 
IsCustomScript
 integer null 
 check (IsCustomScript in ( 1/* Да */
, 0/* Нет */ )) /* Пользовательский скрипт (см. поле Файл или каталог) */
;
GO
alter  table MTZ_Inst_Sec_Files add 
CustomScriptInstall
 uuid null /* Custom Script Install */
;
GO
alter  table MTZ_Inst_Sec_Files add 
CustomScriptUnInstall
 uuid null /* Custom Script UnInstall */
;
GO
alter  table MTZ_Inst_Sec_Files add 
SEQ
 integer null /* Порядок */
;
GO


/*Пользовательские скрипты*/
create table MTZ_Inst_Common/**/ (
InstanceID uuid ,
MTZ_Inst_Commonid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZ_Inst_Common add 
TheName
 VARCHAR (255) null /* Название */
;
GO
alter  table MTZ_Inst_Common add 
TheInstallScript
 TEXT null /* Секция инсталляции */
;
GO
alter  table MTZ_Inst_Common add 
SEQ
 integer null /* Порядок (сортировка) */
;
GO
alter  table MTZ_Inst_Common add 
IsDeinstallUSE
 integer null 
 check (IsDeinstallUSE in ( 1/* Да */
, 0/* Нет */ )) /* Использовать при деинсталляции */
;
GO


/*Описание*/
create table InfoStoreDef/*Описание каталога*/ (
InstanceID uuid ,
InfoStoreDefid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table InfoStoreDef add 
TheGroup
 uuid null /* Группа */
;
GO
alter  table InfoStoreDef add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table InfoStoreDef add 
InfoStoreType
 INTEGER null 
 check (InfoStoreType in ( 2/* Групповой */
, 1/* Персональный */
, 0/*  Общий */ )) /* Тип каталога */
;
GO
alter  table InfoStoreDef add 
TheUser
 uuid null /* Пользователь */
;
GO


/*Папка*/
create table Folder/*Папка каталога*/ (
InstanceID uuid ,
Folderid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
,ParentRowid uuid 
)
;
GO
alter  table Folder add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table Folder add 
FolderType
 INTEGER null 
 check (FolderType in ( 2/* Исходящие */
, 10/* Завершенные */
, 0/* cls__ */
, 5/* Календарь */
, 1/* Входящие */
, 9/* Отложенные */
, 4/* Журнал */
, 8/* В работе */
, 7/* Черновики */
, 6/* Отправленные */
, 3/* Удаленные */ )) /* Тип папки */
;
GO


/*Документы*/
create table Shortcut/*Ярлыки документов*/ (
ParentStructRowID uuid not null,
Shortcutid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table Shortcut add 
DocItem
 uuid null /* Документ */
;
GO
alter  table Shortcut add 
StartMode
 VARCHAR (255) null /* Режим */
;
GO


/*Описание*/
create table MTZExt_def/*Список зарегистрированных расширений*/ (
InstanceID uuid ,
MTZExt_defid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZExt_def add 
Name
 VARCHAR (255) null /* Название */
;
GO
alter  table MTZExt_def add 
ExtType
 INTEGER null 
 check (ExtType in ( 1/* OnFormExt */
, 7/* CodeGenerator */
, 3/* JrnlAddExt */
, 6/* VerifyRowExt */
, 0/* StatusExt */
, 8/* ARMGenerator */
, 5/* DefaultExt */
, 2/* CustomExt */
, 4/* JrnlRunExt */ )) /* Тип расширения */
;
GO
alter  table MTZExt_def add 
TheDescription
 TEXT null /* Описание */
;
GO


/*Реализации расширения*/
create table MTZExtRel/*Реализации расширения для разных разработческих плаформ*/ (
InstanceID uuid ,
MTZExtRelid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table MTZExtRel add 
ThePlatform
 INTEGER null 
 check (ThePlatform in ( 2/* JAVA */
, 3/* OTHER */
, 1/* DOTNET */
, 0/* VB6 */ )) /* Реализация */
;
GO
alter  table MTZExtRel add 
TheClassName
 VARCHAR (255) null /* Название класса */
;
GO
alter  table MTZExtRel add 
TheLibraryName
 VARCHAR (255) null /* Название библиотеки */
;
GO


/*Нумерация материалов*/
create table INVN_DEF/**/ (
InstanceID uuid ,
INVN_DEFid uuid not null default (uuid_generate_v4()) primary key  
,ChangeStamp timestamp null default(LOCALTIMESTAMP)  /* Время последнего изменения */
,LockSessionID uuid null  /* temporary lock */
,LockUserID uuid null /* checkout lock */
,SecurityStyleID uuid null /* security formula */
)
;
GO
alter  table INVN_DEF add 
TheNumber
 integer null /* Следующий номер материала */
;
GO
alter  table INVN_DEF add 
TheOrg
 uuid null /* Организация */
;
GO
alter  table INVN_DEF add 
TheOSNumber
 integer null /* Следующий номер ОС */
;
GO


"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--ForeignKey" BlockCode=" 

alter  TABLE MTZ2JOB_DEF DROP CONSTRAINT fk_580
;
GO
alter  table MTZ2JOB_DEF add constraint fk_580 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE FilterFieldGroup DROP CONSTRAINT fk_195
;
GO
alter  table FilterFieldGroup add constraint fk_195 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE FileterField DROP CONSTRAINT fk_196
;
GO
alter  table FileterField add constraint fk_196 foreign key(ParentStructRowID) references FilterFieldGroup (FilterFieldGroupID)
;
GO


alter  TABLE Filters DROP CONSTRAINT fk_197
;
GO
alter  table Filters add constraint fk_197 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE SrvMessageInfo DROP CONSTRAINT fk_296
;
GO
alter  table SrvMessageInfo add constraint fk_296 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE JournalColumn DROP CONSTRAINT fk_168
;
GO
alter  table JournalColumn add constraint fk_168 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE JColumnSource DROP CONSTRAINT fk_169
;
GO
alter  table JColumnSource add constraint fk_169 foreign key(ParentStructRowID) references JournalColumn (JournalColumnID)
;
GO


alter  TABLE Journal DROP CONSTRAINT fk_170
;
GO
alter  table Journal add constraint fk_170 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE JournalSrc DROP CONSTRAINT fk_171
;
GO
alter  table JournalSrc add constraint fk_171 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE StateAction DROP CONSTRAINT fk_64
;
GO
alter  table StateAction add constraint fk_64 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_LOCKED DROP CONSTRAINT fk_527
;
GO
alter  table REPD_LOCKED add constraint fk_527 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_RequestQuery DROP CONSTRAINT fk_528
;
GO
alter  table REPD_RequestQuery add constraint fk_528 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_ResQueryRcv DROP CONSTRAINT fk_529
;
GO
alter  table REPD_ResQueryRcv add constraint fk_529 foreign key(ParentStructRowID) references REPD_RequestQuery (REPD_RequestQueryID)
;
GO


alter  TABLE REPD_PROV DROP CONSTRAINT fk_530
;
GO
alter  table REPD_PROV add constraint fk_530 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_SRV DROP CONSTRAINT fk_531
;
GO
alter  table REPD_SRV add constraint fk_531 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_SNDTO DROP CONSTRAINT fk_532
;
GO
alter  table REPD_SNDTO add constraint fk_532 foreign key(ParentStructRowID) references REPD_SRV (REPD_SRVID)
;
GO


alter  TABLE REPD_CONST DROP CONSTRAINT fk_621
;
GO
alter  table REPD_CONST add constraint fk_621 foreign key(ParentStructRowID) references REPD_SNDTO (REPD_SNDTOID)
;
GO


alter  TABLE REPD_REPTYPE DROP CONSTRAINT fk_622
;
GO
alter  table REPD_REPTYPE add constraint fk_622 foreign key(ParentStructRowID) references REPD_SNDTO (REPD_SNDTOID)
;
GO


alter  TABLE REPD_SendQ DROP CONSTRAINT fk_533
;
GO
alter  table REPD_SendQ add constraint fk_533 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE REPD_RecvQ DROP CONSTRAINT fk_534
;
GO
alter  table REPD_RecvQ add constraint fk_534 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE invi_DEF DROP CONSTRAINT fk_727
;
GO
alter  table invi_DEF add constraint fk_727 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_PERSONS DROP CONSTRAINT fk_728
;
GO
alter  table INVI_PERSONS add constraint fk_728 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_BAD DROP CONSTRAINT fk_842
;
GO
alter  table INVI_BAD add constraint fk_842 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_CHNG DROP CONSTRAINT fk_843
;
GO
alter  table INVI_CHNG add constraint fk_843 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_OBJ DROP CONSTRAINT fk_729
;
GO
alter  table INVI_OBJ add constraint fk_729 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_DONE DROP CONSTRAINT fk_730
;
GO
alter  table INVI_DONE add constraint fk_730 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVI_UNK DROP CONSTRAINT fk_844
;
GO
alter  table INVI_UNK add constraint fk_844 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE STDJournlaExtInfo DROP CONSTRAINT fk_648
;
GO
alter  table STDJournlaExtInfo add constraint fk_648 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE STDJournalExtParam DROP CONSTRAINT fk_649
;
GO
alter  table STDJournalExtParam add constraint fk_649 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE STDJournalExtFlt DROP CONSTRAINT fk_650
;
GO
alter  table STDJournalExtFlt add constraint fk_650 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE STDJournalExtField DROP CONSTRAINT fk_651
;
GO
alter  table STDJournalExtField add constraint fk_651 foreign key(ParentStructRowID) references STDJournalExtFlt (STDJournalExtFltID)
;
GO


alter  TABLE FIELDTYPE DROP CONSTRAINT fk_299
;
GO
alter  table FIELDTYPE add constraint fk_299 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE FIELDTYPEMAP DROP CONSTRAINT fk_300
;
GO
alter  table FIELDTYPEMAP add constraint fk_300 foreign key(ParentStructRowID) references FIELDTYPE (FIELDTYPEID)
;
GO


alter  TABLE ENUMITEM DROP CONSTRAINT fk_301
;
GO
alter  table ENUMITEM add constraint fk_301 foreign key(ParentStructRowID) references FIELDTYPE (FIELDTYPEID)
;
GO


alter  TABLE SHAREDMETHOD DROP CONSTRAINT fk_302
;
GO
alter  table SHAREDMETHOD add constraint fk_302 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE SCRIPT DROP CONSTRAINT fk_303
;
GO
alter  table SCRIPT add constraint fk_303 foreign key(ParentStructRowID) references SHAREDMETHOD (SHAREDMETHODID)
;
GO


alter  TABLE PARAMETERS DROP CONSTRAINT fk_304
;
GO
alter  table PARAMETERS add constraint fk_304 foreign key(ParentStructRowID) references SCRIPT (SCRIPTID)
;
GO


alter  TABLE OBJECTTYPE DROP CONSTRAINT fk_305
;
GO
alter  table OBJECTTYPE add constraint fk_305 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE PART DROP CONSTRAINT fk_306
;
GO
alter  table PART add constraint fk_306 foreign key(ParentStructRowID) references OBJECTTYPE (OBJECTTYPEID)
;
GO


alter  TABLE PARTMENU DROP CONSTRAINT fk_307
;
GO
alter  table PARTMENU add constraint fk_307 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE PARTPARAMMAP DROP CONSTRAINT fk_308
;
GO
alter  table PARTPARAMMAP add constraint fk_308 foreign key(ParentStructRowID) references PARTMENU (PARTMENUID)
;
GO


alter  TABLE FIELD DROP CONSTRAINT fk_309
;
GO
alter  table FIELD add constraint fk_309 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE FIELDVALIDATOR DROP CONSTRAINT fk_310
;
GO
alter  table FIELDVALIDATOR add constraint fk_310 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE FIELDMENU DROP CONSTRAINT fk_311
;
GO
alter  table FIELDMENU add constraint fk_311 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE FIELDPARAMMAP DROP CONSTRAINT fk_312
;
GO
alter  table FIELDPARAMMAP add constraint fk_312 foreign key(ParentStructRowID) references FIELDMENU (FIELDMENUID)
;
GO


alter  TABLE FldExtenders DROP CONSTRAINT fk_654
;
GO
alter  table FldExtenders add constraint fk_654 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE FIELDEXPRESSION DROP CONSTRAINT fk_313
;
GO
alter  table FIELDEXPRESSION add constraint fk_313 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE DINAMICFILTERSCRIPT DROP CONSTRAINT fk_314
;
GO
alter  table DINAMICFILTERSCRIPT add constraint fk_314 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE FIELDSRCDEF DROP CONSTRAINT fk_655
;
GO
alter  table FIELDSRCDEF add constraint fk_655 foreign key(ParentStructRowID) references FIELD (FIELDID)
;
GO


alter  TABLE PARTVIEW DROP CONSTRAINT fk_315
;
GO
alter  table PARTVIEW add constraint fk_315 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE ViewColumn DROP CONSTRAINT fk_316
;
GO
alter  table ViewColumn add constraint fk_316 foreign key(ParentStructRowID) references PARTVIEW (PARTVIEWID)
;
GO


alter  TABLE PARTVIEW_LNK DROP CONSTRAINT fk_656
;
GO
alter  table PARTVIEW_LNK add constraint fk_656 foreign key(ParentStructRowID) references PARTVIEW (PARTVIEWID)
;
GO


alter  TABLE ExtenderInterface DROP CONSTRAINT fk_657
;
GO
alter  table ExtenderInterface add constraint fk_657 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE VALIDATOR DROP CONSTRAINT fk_317
;
GO
alter  table VALIDATOR add constraint fk_317 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE UNIQUECONSTRAINT DROP CONSTRAINT fk_318
;
GO
alter  table UNIQUECONSTRAINT add constraint fk_318 foreign key(ParentStructRowID) references PART (PARTID)
;
GO


alter  TABLE CONSTRAINTFIELD DROP CONSTRAINT fk_319
;
GO
alter  table CONSTRAINTFIELD add constraint fk_319 foreign key(ParentStructRowID) references UNIQUECONSTRAINT (UNIQUECONSTRAINTID)
;
GO


alter  TABLE INSTANCEVALIDATOR DROP CONSTRAINT fk_320
;
GO
alter  table INSTANCEVALIDATOR add constraint fk_320 foreign key(ParentStructRowID) references OBJECTTYPE (OBJECTTYPEID)
;
GO


alter  TABLE OBJSTATUS DROP CONSTRAINT fk_321
;
GO
alter  table OBJSTATUS add constraint fk_321 foreign key(ParentStructRowID) references OBJECTTYPE (OBJECTTYPEID)
;
GO


alter  TABLE NEXTSTATE DROP CONSTRAINT fk_322
;
GO
alter  table NEXTSTATE add constraint fk_322 foreign key(ParentStructRowID) references OBJSTATUS (OBJSTATUSID)
;
GO


alter  TABLE OBJECTMODE DROP CONSTRAINT fk_323
;
GO
alter  table OBJECTMODE add constraint fk_323 foreign key(ParentStructRowID) references OBJECTTYPE (OBJECTTYPEID)
;
GO


alter  TABLE STRUCTRESTRICTION DROP CONSTRAINT fk_324
;
GO
alter  table STRUCTRESTRICTION add constraint fk_324 foreign key(ParentStructRowID) references OBJECTMODE (OBJECTMODEID)
;
GO


alter  TABLE FIELDRESTRICTION DROP CONSTRAINT fk_325
;
GO
alter  table FIELDRESTRICTION add constraint fk_325 foreign key(ParentStructRowID) references OBJECTMODE (OBJECTMODEID)
;
GO


alter  TABLE METHODRESTRICTION DROP CONSTRAINT fk_326
;
GO
alter  table METHODRESTRICTION add constraint fk_326 foreign key(ParentStructRowID) references OBJECTMODE (OBJECTMODEID)
;
GO


alter  TABLE TYPEMENU DROP CONSTRAINT fk_327
;
GO
alter  table TYPEMENU add constraint fk_327 foreign key(ParentStructRowID) references OBJECTTYPE (OBJECTTYPEID)
;
GO


alter  TABLE MTZAPP DROP CONSTRAINT fk_328
;
GO
alter  table MTZAPP add constraint fk_328 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ParentPackage DROP CONSTRAINT fk_329
;
GO
alter  table ParentPackage add constraint fk_329 foreign key(ParentStructRowID) references MTZAPP (MTZAPPID)
;
GO


alter  TABLE GENPACKAGE DROP CONSTRAINT fk_330
;
GO
alter  table GENPACKAGE add constraint fk_330 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE GENERATOR_TARGET DROP CONSTRAINT fk_331
;
GO
alter  table GENERATOR_TARGET add constraint fk_331 foreign key(ParentStructRowID) references GENPACKAGE (GENPACKAGEID)
;
GO


alter  TABLE GENMANUALCODE DROP CONSTRAINT fk_332
;
GO
alter  table GENMANUALCODE add constraint fk_332 foreign key(ParentStructRowID) references GENERATOR_TARGET (GENERATOR_TARGETID)
;
GO


alter  TABLE GENCONTROLS DROP CONSTRAINT fk_333
;
GO
alter  table GENCONTROLS add constraint fk_333 foreign key(ParentStructRowID) references GENERATOR_TARGET (GENERATOR_TARGETID)
;
GO


alter  TABLE GENREFERENCE DROP CONSTRAINT fk_334
;
GO
alter  table GENREFERENCE add constraint fk_334 foreign key(ParentStructRowID) references GENERATOR_TARGET (GENERATOR_TARGETID)
;
GO


alter  TABLE LocalizeInfo DROP CONSTRAINT fk_658
;
GO
alter  table LocalizeInfo add constraint fk_658 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Num_zones DROP CONSTRAINT fk_161
;
GO
alter  table Num_zones add constraint fk_161 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Num_Values DROP CONSTRAINT fk_162
;
GO
alter  table Num_Values add constraint fk_162 foreign key(ParentStructRowID) references Num_zones (Num_zonesID)
;
GO


alter  TABLE Num_head DROP CONSTRAINT fk_163
;
GO
alter  table Num_head add constraint fk_163 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Ext_Photos DROP CONSTRAINT fk_652
;
GO
alter  table Ext_Photos add constraint fk_652 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Ext_Photo_Call DROP CONSTRAINT fk_653
;
GO
alter  table Ext_Photo_Call add constraint fk_653 foreign key(ParentStructRowID) references Ext_Photos (Ext_PhotosID)
;
GO


alter  TABLE INVF_DEF DROP CONSTRAINT fk_845
;
GO
alter  table INVF_DEF add constraint fk_845 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE MTZSEC_RIGHT DROP CONSTRAINT fk_185
;
GO
alter  table MTZSEC_RIGHT add constraint fk_185 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_RENT DROP CONSTRAINT fk_731
;
GO
alter  table INVOS_RENT add constraint fk_731 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_HIST DROP CONSTRAINT fk_829
;
GO
alter  table INVOS_HIST add constraint fk_829 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_OFFRULE DROP CONSTRAINT fk_830
;
GO
alter  table INVOS_OFFRULE add constraint fk_830 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_SROK DROP CONSTRAINT fk_831
;
GO
alter  table INVOS_SROK add constraint fk_831 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_TECH DROP CONSTRAINT fk_732
;
GO
alter  table INVOS_TECH add constraint fk_732 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_WINSOFT DROP CONSTRAINT fk_733
;
GO
alter  table INVOS_WINSOFT add constraint fk_733 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_COMP DROP CONSTRAINT fk_734
;
GO
alter  table INVOS_COMP add constraint fk_734 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_HARD DROP CONSTRAINT fk_735
;
GO
alter  table INVOS_HARD add constraint fk_735 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_CURCFG DROP CONSTRAINT fk_736
;
GO
alter  table INVOS_CURCFG add constraint fk_736 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_CFGCH DROP CONSTRAINT fk_737
;
GO
alter  table INVOS_CFGCH add constraint fk_737 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_DEVICES DROP CONSTRAINT fk_738
;
GO
alter  table INVOS_DEVICES add constraint fk_738 foreign key(ParentStructRowID) references INVOS_TECH (INVOS_TECHID)
;
GO


alter  TABLE INVOS_DRAG DROP CONSTRAINT fk_835
;
GO
alter  table INVOS_DRAG add constraint fk_835 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_DOCS DROP CONSTRAINT fk_836
;
GO
alter  table INVOS_DOCS add constraint fk_836 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_INV DROP CONSTRAINT fk_739
;
GO
alter  table INVOS_INV add constraint fk_739 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_LIZING DROP CONSTRAINT fk_837
;
GO
alter  table INVOS_LIZING add constraint fk_837 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_CNSRV DROP CONSTRAINT fk_838
;
GO
alter  table INVOS_CNSRV add constraint fk_838 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_INFO DROP CONSTRAINT fk_740
;
GO
alter  table INVOS_INFO add constraint fk_740 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_MOD DROP CONSTRAINT fk_839
;
GO
alter  table INVOS_MOD add constraint fk_839 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_CMNT DROP CONSTRAINT fk_832
;
GO
alter  table INVOS_CMNT add constraint fk_832 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_CODE DROP CONSTRAINT fk_741
;
GO
alter  table INVOS_CODE add constraint fk_741 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_REPAIR DROP CONSTRAINT fk_742
;
GO
alter  table INVOS_REPAIR add constraint fk_742 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVOS_PLACE DROP CONSTRAINT fk_833
;
GO
alter  table INVOS_PLACE add constraint fk_833 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Reports DROP CONSTRAINT fk_181
;
GO
alter  table Reports add constraint fk_181 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE RPTStruct DROP CONSTRAINT fk_182
;
GO
alter  table RPTStruct add constraint fk_182 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE RPTFields DROP CONSTRAINT fk_183
;
GO
alter  table RPTFields add constraint fk_183 foreign key(ParentStructRowID) references RPTStruct (RPTStructID)
;
GO


alter  TABLE RPTFormula DROP CONSTRAINT fk_184
;
GO
alter  table RPTFormula add constraint fk_184 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Users DROP CONSTRAINT fk_418
;
GO
alter  table Users add constraint fk_418 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Groups DROP CONSTRAINT fk_419
;
GO
alter  table Groups add constraint fk_419 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE GroupUser DROP CONSTRAINT fk_420
;
GO
alter  table GroupUser add constraint fk_420 foreign key(ParentStructRowID) references Groups (GroupsID)
;
GO


alter  TABLE SysLog DROP CONSTRAINT fk_338
;
GO
alter  table SysLog add constraint fk_338 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE the_Session DROP CONSTRAINT fk_339
;
GO
alter  table the_Session add constraint fk_339 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE LogReader DROP CONSTRAINT fk_340
;
GO
alter  table LogReader add constraint fk_340 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Verb DROP CONSTRAINT fk_341
;
GO
alter  table Verb add constraint fk_341 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_USER DROP CONSTRAINT fk_281
;
GO
alter  table ROLES_USER add constraint fk_281 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_MAP DROP CONSTRAINT fk_282
;
GO
alter  table ROLES_MAP add constraint fk_282 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_DOC DROP CONSTRAINT fk_556
;
GO
alter  table ROLES_DOC add constraint fk_556 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_DOC_STATE DROP CONSTRAINT fk_557
;
GO
alter  table ROLES_DOC_STATE add constraint fk_557 foreign key(ParentStructRowID) references ROLES_DOC (ROLES_DOCID)
;
GO


alter  TABLE ROLES_DEF DROP CONSTRAINT fk_283
;
GO
alter  table ROLES_DEF add constraint fk_283 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_REPORTS DROP CONSTRAINT fk_558
;
GO
alter  table ROLES_REPORTS add constraint fk_558 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_WP DROP CONSTRAINT fk_285
;
GO
alter  table ROLES_WP add constraint fk_285 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ROLES_ACT DROP CONSTRAINT fk_559
;
GO
alter  table ROLES_ACT add constraint fk_559 foreign key(ParentStructRowID) references ROLES_WP (ROLES_WPID)
;
GO


alter  TABLE WorkPlace DROP CONSTRAINT fk_165
;
GO
alter  table WorkPlace add constraint fk_165 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE EntryPoints DROP CONSTRAINT fk_583
;
GO
alter  table EntryPoints add constraint fk_583 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE EPFilterLink DROP CONSTRAINT fk_590
;
GO
alter  table EPFilterLink add constraint fk_590 foreign key(ParentStructRowID) references EntryPoints (EntryPointsID)
;
GO


alter  TABLE ARMTypes DROP CONSTRAINT fk_584
;
GO
alter  table ARMTypes add constraint fk_584 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ARMJournal DROP CONSTRAINT fk_585
;
GO
alter  table ARMJournal add constraint fk_585 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE ARMJRNLADD DROP CONSTRAINT fk_586
;
GO
alter  table ARMJRNLADD add constraint fk_586 foreign key(ParentStructRowID) references ARMJournal (ARMJournalID)
;
GO


alter  TABLE ARMJRNLREP DROP CONSTRAINT fk_587
;
GO
alter  table ARMJRNLREP add constraint fk_587 foreign key(ParentStructRowID) references ARMJournal (ARMJournalID)
;
GO


alter  TABLE ARMJRNLRUN DROP CONSTRAINT fk_588
;
GO
alter  table ARMJRNLRUN add constraint fk_588 foreign key(ParentStructRowID) references ARMJournal (ARMJournalID)
;
GO


alter  TABLE INVD_UPR DROP CONSTRAINT fk_743
;
GO
alter  table INVD_UPR add constraint fk_743 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_OTDEL DROP CONSTRAINT fk_744
;
GO
alter  table INVD_OTDEL add constraint fk_744 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_BLD DROP CONSTRAINT fk_834
;
GO
alter  table INVD_BLD add constraint fk_834 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_DRAG DROP CONSTRAINT fk_840
;
GO
alter  table INVD_DRAG add constraint fk_840 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_ORG DROP CONSTRAINT fk_745
;
GO
alter  table INVD_ORG add constraint fk_745 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_OSSTATUS DROP CONSTRAINT fk_746
;
GO
alter  table INVD_OSSTATUS add constraint fk_746 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_OWNER DROP CONSTRAINT fk_747
;
GO
alter  table INVD_OWNER add constraint fk_747 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_UR DROP CONSTRAINT fk_748
;
GO
alter  table INVD_UR add constraint fk_748 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_OSTYPE DROP CONSTRAINT fk_749
;
GO
alter  table INVD_OSTYPE add constraint fk_749 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVD_DIR DROP CONSTRAINT fk_750
;
GO
alter  table INVD_DIR add constraint fk_750 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE MTZ_Inst_Build DROP CONSTRAINT fk_665
;
GO
alter  table MTZ_Inst_Build add constraint fk_665 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE MTZ_Inst_Build_Sec DROP CONSTRAINT fk_666
;
GO
alter  table MTZ_Inst_Build_Sec add constraint fk_666 foreign key(ParentStructRowID) references MTZ_Inst_Build (MTZ_Inst_BuildID)
;
GO


alter  TABLE MTZ_Inst_Section DROP CONSTRAINT fk_667
;
GO
alter  table MTZ_Inst_Section add constraint fk_667 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE MTZ_Inst_Sec_Files DROP CONSTRAINT fk_668
;
GO
alter  table MTZ_Inst_Sec_Files add constraint fk_668 foreign key(ParentStructRowID) references MTZ_Inst_Section (MTZ_Inst_SectionID)
;
GO


alter  TABLE MTZ_Inst_Common DROP CONSTRAINT fk_669
;
GO
alter  table MTZ_Inst_Common add constraint fk_669 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE InfoStoreDef DROP CONSTRAINT fk_120
;
GO
alter  table InfoStoreDef add constraint fk_120 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Folder DROP CONSTRAINT fk_121
;
GO
alter  table Folder add constraint fk_121 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE Shortcut DROP CONSTRAINT fk_122
;
GO
alter  table Shortcut add constraint fk_122 foreign key(ParentStructRowID) references Folder (FolderID)
;
GO


alter  TABLE MTZExt_def DROP CONSTRAINT fk_581
;
GO
alter  table MTZExt_def add constraint fk_581 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE MTZExtRel DROP CONSTRAINT fk_591
;
GO
alter  table MTZExtRel add constraint fk_591 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


alter  TABLE INVN_DEF DROP CONSTRAINT fk_841
;
GO
alter  table INVN_DEF add constraint fk_841 foreign key(INSTANCEID) references INSTANCE (INSTANCEID)
;
GO


"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--index" BlockCode=" 

drop index if exists parent_MTZ2JOB_DEF
;
GO
create index parent_MTZ2JOB_DEF on MTZ2JOB_DEF(INSTANCEID)
;
GO


drop index if exists parent_FilterFieldGroup
;
GO
create index parent_FilterFieldGroup on FilterFieldGroup(INSTANCEID)
;
GO


drop index if exists parent_FileterField
;
GO
create index parent_FileterField on FileterField(ParentStructRowID)
;
GO


drop index if exists parent_Filters
;
GO
create index parent_Filters on Filters(INSTANCEID)
;
GO


drop index if exists parent_SrvMessageInfo
;
GO
create index parent_SrvMessageInfo on SrvMessageInfo(INSTANCEID)
;
GO


drop index if exists parent_JournalColumn
;
GO
create index parent_JournalColumn on JournalColumn(INSTANCEID)
;
GO


drop index if exists parent_JColumnSource
;
GO
create index parent_JColumnSource on JColumnSource(ParentStructRowID)
;
GO


drop index if exists parent_Journal
;
GO
create index parent_Journal on Journal(INSTANCEID)
;
GO


drop index if exists parent_JournalSrc
;
GO
create index parent_JournalSrc on JournalSrc(INSTANCEID)
;
GO


drop index if exists parent_StateAction
;
GO
create index parent_StateAction on StateAction(INSTANCEID)
;
GO


drop index if exists parent_REPD_LOCKED
;
GO
create index parent_REPD_LOCKED on REPD_LOCKED(INSTANCEID)
;
GO


drop index if exists parent_REPD_RequestQuery
;
GO
create index parent_REPD_RequestQuery on REPD_RequestQuery(INSTANCEID)
;
GO


drop index if exists parent_REPD_ResQueryRcv
;
GO
create index parent_REPD_ResQueryRcv on REPD_ResQueryRcv(ParentStructRowID)
;
GO


drop index if exists parent_REPD_PROV
;
GO
create index parent_REPD_PROV on REPD_PROV(INSTANCEID)
;
GO


drop index if exists parent_REPD_SRV
;
GO
create index parent_REPD_SRV on REPD_SRV(INSTANCEID)
;
GO


drop index if exists parent_REPD_SNDTO
;
GO
create index parent_REPD_SNDTO on REPD_SNDTO(ParentStructRowID)
;
GO


drop index if exists parent_REPD_CONST
;
GO
create index parent_REPD_CONST on REPD_CONST(ParentStructRowID)
;
GO


drop index if exists parent_REPD_REPTYPE
;
GO
create index parent_REPD_REPTYPE on REPD_REPTYPE(ParentStructRowID)
;
GO


drop index if exists parent_REPD_SendQ
;
GO
create index parent_REPD_SendQ on REPD_SendQ(INSTANCEID)
;
GO


drop index if exists parent_REPD_RecvQ
;
GO
create index parent_REPD_RecvQ on REPD_RecvQ(INSTANCEID)
;
GO


drop index if exists parent_invi_DEF
;
GO
create index parent_invi_DEF on invi_DEF(INSTANCEID)
;
GO


drop index if exists parent_INVI_PERSONS
;
GO
create index parent_INVI_PERSONS on INVI_PERSONS(INSTANCEID)
;
GO


drop index if exists parent_INVI_BAD
;
GO
create index parent_INVI_BAD on INVI_BAD(INSTANCEID)
;
GO


drop index if exists parent_INVI_CHNG
;
GO
create index parent_INVI_CHNG on INVI_CHNG(INSTANCEID)
;
GO


drop index if exists parent_INVI_OBJ
;
GO
create index parent_INVI_OBJ on INVI_OBJ(INSTANCEID)
;
GO


drop index if exists parent_INVI_DONE
;
GO
create index parent_INVI_DONE on INVI_DONE(INSTANCEID)
;
GO


drop index if exists parent_INVI_UNK
;
GO
create index parent_INVI_UNK on INVI_UNK(INSTANCEID)
;
GO


drop index if exists parent_STDJournlaExtInfo
;
GO
create index parent_STDJournlaExtInfo on STDJournlaExtInfo(INSTANCEID)
;
GO


drop index if exists parent_STDJournalExtParam
;
GO
create index parent_STDJournalExtParam on STDJournalExtParam(INSTANCEID)
;
GO


drop index if exists parent_STDJournalExtFlt
;
GO
create index parent_STDJournalExtFlt on STDJournalExtFlt(INSTANCEID)
;
GO


drop index if exists parent_STDJournalExtField
;
GO
create index parent_STDJournalExtField on STDJournalExtField(ParentStructRowID)
;
GO


drop index if exists parent_FIELDTYPE
;
GO
create index parent_FIELDTYPE on FIELDTYPE(INSTANCEID)
;
GO


drop index if exists parent_FIELDTYPEMAP
;
GO
create index parent_FIELDTYPEMAP on FIELDTYPEMAP(ParentStructRowID)
;
GO


drop index if exists parent_ENUMITEM
;
GO
create index parent_ENUMITEM on ENUMITEM(ParentStructRowID)
;
GO


drop index if exists parent_SHAREDMETHOD
;
GO
create index parent_SHAREDMETHOD on SHAREDMETHOD(INSTANCEID)
;
GO


drop index if exists parent_SCRIPT
;
GO
create index parent_SCRIPT on SCRIPT(ParentStructRowID)
;
GO


drop index if exists parent_PARAMETERS
;
GO
create index parent_PARAMETERS on PARAMETERS(ParentStructRowID)
;
GO


drop index if exists parent_OBJECTTYPE
;
GO
create index parent_OBJECTTYPE on OBJECTTYPE(INSTANCEID)
;
GO


drop index if exists parent_PART
;
GO
create index parent_PART on PART(ParentStructRowID)
;
GO


drop index if exists parent_PARTMENU
;
GO
create index parent_PARTMENU on PARTMENU(ParentStructRowID)
;
GO


drop index if exists parent_PARTPARAMMAP
;
GO
create index parent_PARTPARAMMAP on PARTPARAMMAP(ParentStructRowID)
;
GO


drop index if exists parent_FIELD
;
GO
create index parent_FIELD on FIELD(ParentStructRowID)
;
GO


drop index if exists parent_FIELDVALIDATOR
;
GO
create index parent_FIELDVALIDATOR on FIELDVALIDATOR(ParentStructRowID)
;
GO


drop index if exists parent_FIELDMENU
;
GO
create index parent_FIELDMENU on FIELDMENU(ParentStructRowID)
;
GO


drop index if exists parent_FIELDPARAMMAP
;
GO
create index parent_FIELDPARAMMAP on FIELDPARAMMAP(ParentStructRowID)
;
GO


drop index if exists parent_FldExtenders
;
GO
create index parent_FldExtenders on FldExtenders(ParentStructRowID)
;
GO


drop index if exists parent_FIELDEXPRESSION
;
GO
create index parent_FIELDEXPRESSION on FIELDEXPRESSION(ParentStructRowID)
;
GO


drop index if exists parent_DINAMICFILTERSCRIPT
;
GO
create index parent_DINAMICFILTERSCRIPT on DINAMICFILTERSCRIPT(ParentStructRowID)
;
GO


drop index if exists parent_FIELDSRCDEF
;
GO
create index parent_FIELDSRCDEF on FIELDSRCDEF(ParentStructRowID)
;
GO


drop index if exists parent_PARTVIEW
;
GO
create index parent_PARTVIEW on PARTVIEW(ParentStructRowID)
;
GO


drop index if exists parent_ViewColumn
;
GO
create index parent_ViewColumn on ViewColumn(ParentStructRowID)
;
GO


drop index if exists parent_PARTVIEW_LNK
;
GO
create index parent_PARTVIEW_LNK on PARTVIEW_LNK(ParentStructRowID)
;
GO


drop index if exists parent_ExtenderInterface
;
GO
create index parent_ExtenderInterface on ExtenderInterface(ParentStructRowID)
;
GO


drop index if exists parent_VALIDATOR
;
GO
create index parent_VALIDATOR on VALIDATOR(ParentStructRowID)
;
GO


drop index if exists parent_UNIQUECONSTRAINT
;
GO
create index parent_UNIQUECONSTRAINT on UNIQUECONSTRAINT(ParentStructRowID)
;
GO


drop index if exists parent_CONSTRAINTFIELD
;
GO
create index parent_CONSTRAINTFIELD on CONSTRAINTFIELD(ParentStructRowID)
;
GO


drop index if exists parent_INSTANCEVALIDATOR
;
GO
create index parent_INSTANCEVALIDATOR on INSTANCEVALIDATOR(ParentStructRowID)
;
GO


drop index if exists parent_OBJSTATUS
;
GO
create index parent_OBJSTATUS on OBJSTATUS(ParentStructRowID)
;
GO


drop index if exists parent_NEXTSTATE
;
GO
create index parent_NEXTSTATE on NEXTSTATE(ParentStructRowID)
;
GO


drop index if exists parent_OBJECTMODE
;
GO
create index parent_OBJECTMODE on OBJECTMODE(ParentStructRowID)
;
GO


drop index if exists parent_STRUCTRESTRICTION
;
GO
create index parent_STRUCTRESTRICTION on STRUCTRESTRICTION(ParentStructRowID)
;
GO


drop index if exists parent_FIELDRESTRICTION
;
GO
create index parent_FIELDRESTRICTION on FIELDRESTRICTION(ParentStructRowID)
;
GO


drop index if exists parent_METHODRESTRICTION
;
GO
create index parent_METHODRESTRICTION on METHODRESTRICTION(ParentStructRowID)
;
GO


drop index if exists parent_TYPEMENU
;
GO
create index parent_TYPEMENU on TYPEMENU(ParentStructRowID)
;
GO


drop index if exists parent_MTZAPP
;
GO
create index parent_MTZAPP on MTZAPP(INSTANCEID)
;
GO


drop index if exists parent_ParentPackage
;
GO
create index parent_ParentPackage on ParentPackage(ParentStructRowID)
;
GO


drop index if exists parent_GENPACKAGE
;
GO
create index parent_GENPACKAGE on GENPACKAGE(INSTANCEID)
;
GO


drop index if exists parent_GENERATOR_TARGET
;
GO
create index parent_GENERATOR_TARGET on GENERATOR_TARGET(ParentStructRowID)
;
GO


drop index if exists parent_GENMANUALCODE
;
GO
create index parent_GENMANUALCODE on GENMANUALCODE(ParentStructRowID)
;
GO


drop index if exists parent_GENCONTROLS
;
GO
create index parent_GENCONTROLS on GENCONTROLS(ParentStructRowID)
;
GO


drop index if exists parent_GENREFERENCE
;
GO
create index parent_GENREFERENCE on GENREFERENCE(ParentStructRowID)
;
GO


drop index if exists parent_LocalizeInfo
;
GO
create index parent_LocalizeInfo on LocalizeInfo(INSTANCEID)
;
GO


drop index if exists parent_Num_zones
;
GO
create index parent_Num_zones on Num_zones(INSTANCEID)
;
GO


drop index if exists parent_Num_Values
;
GO
create index parent_Num_Values on Num_Values(ParentStructRowID)
;
GO


drop index if exists parent_Num_head
;
GO
create index parent_Num_head on Num_head(INSTANCEID)
;
GO


drop index if exists parent_Ext_Photos
;
GO
create index parent_Ext_Photos on Ext_Photos(INSTANCEID)
;
GO


drop index if exists parent_Ext_Photo_Call
;
GO
create index parent_Ext_Photo_Call on Ext_Photo_Call(ParentStructRowID)
;
GO


drop index if exists parent_INVF_DEF
;
GO
create index parent_INVF_DEF on INVF_DEF(INSTANCEID)
;
GO


drop index if exists parent_MTZSEC_RIGHT
;
GO
create index parent_MTZSEC_RIGHT on MTZSEC_RIGHT(INSTANCEID)
;
GO


drop index if exists parent_INVOS_RENT
;
GO
create index parent_INVOS_RENT on INVOS_RENT(INSTANCEID)
;
GO


drop index if exists parent_INVOS_HIST
;
GO
create index parent_INVOS_HIST on INVOS_HIST(INSTANCEID)
;
GO


drop index if exists parent_INVOS_OFFRULE
;
GO
create index parent_INVOS_OFFRULE on INVOS_OFFRULE(INSTANCEID)
;
GO


drop index if exists parent_INVOS_SROK
;
GO
create index parent_INVOS_SROK on INVOS_SROK(INSTANCEID)
;
GO


drop index if exists parent_INVOS_TECH
;
GO
create index parent_INVOS_TECH on INVOS_TECH(INSTANCEID)
;
GO


drop index if exists parent_INVOS_WINSOFT
;
GO
create index parent_INVOS_WINSOFT on INVOS_WINSOFT(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_COMP
;
GO
create index parent_INVOS_COMP on INVOS_COMP(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_HARD
;
GO
create index parent_INVOS_HARD on INVOS_HARD(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_CURCFG
;
GO
create index parent_INVOS_CURCFG on INVOS_CURCFG(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_CFGCH
;
GO
create index parent_INVOS_CFGCH on INVOS_CFGCH(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_DEVICES
;
GO
create index parent_INVOS_DEVICES on INVOS_DEVICES(ParentStructRowID)
;
GO


drop index if exists parent_INVOS_DRAG
;
GO
create index parent_INVOS_DRAG on INVOS_DRAG(INSTANCEID)
;
GO


drop index if exists parent_INVOS_DOCS
;
GO
create index parent_INVOS_DOCS on INVOS_DOCS(INSTANCEID)
;
GO


drop index if exists parent_INVOS_INV
;
GO
create index parent_INVOS_INV on INVOS_INV(INSTANCEID)
;
GO


drop index if exists parent_INVOS_LIZING
;
GO
create index parent_INVOS_LIZING on INVOS_LIZING(INSTANCEID)
;
GO


drop index if exists parent_INVOS_CNSRV
;
GO
create index parent_INVOS_CNSRV on INVOS_CNSRV(INSTANCEID)
;
GO


drop index if exists parent_INVOS_INFO
;
GO
create index parent_INVOS_INFO on INVOS_INFO(INSTANCEID)
;
GO


drop index if exists parent_INVOS_MOD
;
GO
create index parent_INVOS_MOD on INVOS_MOD(INSTANCEID)
;
GO


drop index if exists parent_INVOS_CMNT
;
GO
create index parent_INVOS_CMNT on INVOS_CMNT(INSTANCEID)
;
GO


drop index if exists parent_INVOS_CODE
;
GO
create index parent_INVOS_CODE on INVOS_CODE(INSTANCEID)
;
GO


drop index if exists parent_INVOS_REPAIR
;
GO
create index parent_INVOS_REPAIR on INVOS_REPAIR(INSTANCEID)
;
GO


drop index if exists parent_INVOS_PLACE
;
GO
create index parent_INVOS_PLACE on INVOS_PLACE(INSTANCEID)
;
GO


drop index if exists parent_Reports
;
GO
create index parent_Reports on Reports(INSTANCEID)
;
GO


drop index if exists parent_RPTStruct
;
GO
create index parent_RPTStruct on RPTStruct(INSTANCEID)
;
GO


drop index if exists parent_RPTFields
;
GO
create index parent_RPTFields on RPTFields(ParentStructRowID)
;
GO


drop index if exists parent_RPTFormula
;
GO
create index parent_RPTFormula on RPTFormula(INSTANCEID)
;
GO


drop index if exists parent_Users
;
GO
create index parent_Users on Users(INSTANCEID)
;
GO


drop index if exists parent_Groups
;
GO
create index parent_Groups on Groups(INSTANCEID)
;
GO


drop index if exists parent_GroupUser
;
GO
create index parent_GroupUser on GroupUser(ParentStructRowID)
;
GO


drop index if exists parent_SysLog
;
GO
create index parent_SysLog on SysLog(INSTANCEID)
;
GO


drop index if exists parent_the_Session
;
GO
create index parent_the_Session on the_Session(INSTANCEID)
;
GO


drop index if exists parent_LogReader
;
GO
create index parent_LogReader on LogReader(INSTANCEID)
;
GO


drop index if exists parent_Verb
;
GO
create index parent_Verb on Verb(INSTANCEID)
;
GO


drop index if exists parent_ROLES_USER
;
GO
create index parent_ROLES_USER on ROLES_USER(INSTANCEID)
;
GO


drop index if exists parent_ROLES_MAP
;
GO
create index parent_ROLES_MAP on ROLES_MAP(INSTANCEID)
;
GO


drop index if exists parent_ROLES_DOC
;
GO
create index parent_ROLES_DOC on ROLES_DOC(INSTANCEID)
;
GO


drop index if exists parent_ROLES_DOC_STATE
;
GO
create index parent_ROLES_DOC_STATE on ROLES_DOC_STATE(ParentStructRowID)
;
GO


drop index if exists parent_ROLES_DEF
;
GO
create index parent_ROLES_DEF on ROLES_DEF(INSTANCEID)
;
GO


drop index if exists parent_ROLES_REPORTS
;
GO
create index parent_ROLES_REPORTS on ROLES_REPORTS(INSTANCEID)
;
GO


drop index if exists parent_ROLES_WP
;
GO
create index parent_ROLES_WP on ROLES_WP(INSTANCEID)
;
GO


drop index if exists parent_ROLES_ACT
;
GO
create index parent_ROLES_ACT on ROLES_ACT(ParentStructRowID)
;
GO


drop index if exists parent_WorkPlace
;
GO
create index parent_WorkPlace on WorkPlace(INSTANCEID)
;
GO


drop index if exists parent_EntryPoints
;
GO
create index parent_EntryPoints on EntryPoints(INSTANCEID)
;
GO


drop index if exists parent_EPFilterLink
;
GO
create index parent_EPFilterLink on EPFilterLink(ParentStructRowID)
;
GO


drop index if exists parent_ARMTypes
;
GO
create index parent_ARMTypes on ARMTypes(INSTANCEID)
;
GO


drop index if exists parent_ARMJournal
;
GO
create index parent_ARMJournal on ARMJournal(INSTANCEID)
;
GO


drop index if exists parent_ARMJRNLADD
;
GO
create index parent_ARMJRNLADD on ARMJRNLADD(ParentStructRowID)
;
GO


drop index if exists parent_ARMJRNLREP
;
GO
create index parent_ARMJRNLREP on ARMJRNLREP(ParentStructRowID)
;
GO


drop index if exists parent_ARMJRNLRUN
;
GO
create index parent_ARMJRNLRUN on ARMJRNLRUN(ParentStructRowID)
;
GO


drop index if exists parent_INVD_UPR
;
GO
create index parent_INVD_UPR on INVD_UPR(INSTANCEID)
;
GO


drop index if exists parent_INVD_OTDEL
;
GO
create index parent_INVD_OTDEL on INVD_OTDEL(INSTANCEID)
;
GO


drop index if exists parent_INVD_BLD
;
GO
create index parent_INVD_BLD on INVD_BLD(INSTANCEID)
;
GO


drop index if exists parent_INVD_DRAG
;
GO
create index parent_INVD_DRAG on INVD_DRAG(INSTANCEID)
;
GO


drop index if exists parent_INVD_ORG
;
GO
create index parent_INVD_ORG on INVD_ORG(INSTANCEID)
;
GO


drop index if exists parent_INVD_OSSTATUS
;
GO
create index parent_INVD_OSSTATUS on INVD_OSSTATUS(INSTANCEID)
;
GO


drop index if exists parent_INVD_OWNER
;
GO
create index parent_INVD_OWNER on INVD_OWNER(INSTANCEID)
;
GO


drop index if exists parent_INVD_UR
;
GO
create index parent_INVD_UR on INVD_UR(INSTANCEID)
;
GO


drop index if exists parent_INVD_OSTYPE
;
GO
create index parent_INVD_OSTYPE on INVD_OSTYPE(INSTANCEID)
;
GO


drop index if exists parent_INVD_DIR
;
GO
create index parent_INVD_DIR on INVD_DIR(INSTANCEID)
;
GO


drop index if exists parent_MTZ_Inst_Build
;
GO
create index parent_MTZ_Inst_Build on MTZ_Inst_Build(INSTANCEID)
;
GO


drop index if exists parent_MTZ_Inst_Build_Sec
;
GO
create index parent_MTZ_Inst_Build_Sec on MTZ_Inst_Build_Sec(ParentStructRowID)
;
GO


drop index if exists parent_MTZ_Inst_Section
;
GO
create index parent_MTZ_Inst_Section on MTZ_Inst_Section(INSTANCEID)
;
GO


drop index if exists parent_MTZ_Inst_Sec_Files
;
GO
create index parent_MTZ_Inst_Sec_Files on MTZ_Inst_Sec_Files(ParentStructRowID)
;
GO


drop index if exists parent_MTZ_Inst_Common
;
GO
create index parent_MTZ_Inst_Common on MTZ_Inst_Common(INSTANCEID)
;
GO


drop index if exists parent_InfoStoreDef
;
GO
create index parent_InfoStoreDef on InfoStoreDef(INSTANCEID)
;
GO


drop index if exists parent_Folder
;
GO
create index parent_Folder on Folder(INSTANCEID)
;
GO


drop index if exists parent_Shortcut
;
GO
create index parent_Shortcut on Shortcut(ParentStructRowID)
;
GO


drop index if exists parent_MTZExt_def
;
GO
create index parent_MTZExt_def on MTZExt_def(INSTANCEID)
;
GO


drop index if exists parent_MTZExtRel
;
GO
create index parent_MTZExtRel on MTZExtRel(INSTANCEID)
;
GO


drop index if exists parent_INVN_DEF
;
GO
create index parent_INVN_DEF on INVN_DEF(INSTANCEID)
;
GO


"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Functions.Header" File=""><BlockHolder BlockName="--body" BlockCode=" 

 

 create or replace function  INSTANCE_OWNER   (
    aCURSESSION uuid ,ainstanceid uuid,
 aOwnerPartName varchar, aOwnerRowID uuid) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SYSOPTIONS_SAVE    (
 aSysOptionsid uuid,
 aName varchar,
 aValue varchar ,
 aOptionType varchar) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCE_SAVE      (
aCURSESSION uuid,
ainstanceid uuid,
aObjType varchar,
aName varchar
) returns void as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_DELETE    (
aCURSESSION uuid,
ainstanceid uuid
)returns void as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_HCL   (
aCURSESSION uuid,
aRowID uuid
)returns integer as $$ begin return 0; end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_PROPAGATE   (
aCURSESSION uuid,
aRowID uuid
)returns void as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_ISLOCKED   (
 aCURSESSION uuid,
 aRowID uuid 
)returns integer as $$ begin return 0; end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_SINIT    (
aCURSESSION uuid,
aRowID uuid ,
 aSecurityStyleID uuid
)returns void as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_LOCK     (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer
) returns void as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid
)returns void as $$ begin end; $$ language 'plpgsql';
GO
  create or replace function  INSTANCE_BRIEF    (
 aCURSESSION uuid,
 ainstanceid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
  create or replace function  QR_AND_QR  ( aid1 uuid, aid2
    uuid,aidout uuid )returns integer as $$ begin end; $$ language 'plpgsql';
GO
  create or replace function  QR_OR_QR  ( aid1 uuid, aid2 
    uuid,aidout uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
create or replace function  ROWPARENTS
(aQueryID   uuid
,aRowID uuid/* Row */
,aTable varchar /* Part Table Name */
,aCURSESSION uuid/* the_session */
)returns void as $$ begin end; $$ language 'plpgsql';
GO
  create or replace function  INSTANCE_STATUS    (
  aCURSESSION uuid,
  ainstanceid uuid,
  astatusid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


;

create or replace   function instance_BRIEF_F  (
 ainstanceid uuid
)returns varchar as $$ begin return 'INSTANCE'; end;  $$ language 'plpgsql';
GO


create or replace function MTZ2JOB_DEF_BRIEF_F  (
 aMTZ2JOB_DEFid uuid
) returns varchar  as $$ begin return 'MTZ2JOB_DEF'; end; $$ language 'plpgsql';
GO


create or replace function FilterFieldGroup_BRIEF_F  (
 aFilterFieldGroupid uuid
) returns varchar  as $$ begin return 'FilterFieldGroup'; end; $$ language 'plpgsql';
GO


create or replace function FileterField_BRIEF_F  (
 aFileterFieldid uuid
) returns varchar  as $$ begin return 'FileterField'; end; $$ language 'plpgsql';
GO


create or replace function Filters_BRIEF_F  (
 aFiltersid uuid
) returns varchar  as $$ begin return 'Filters'; end; $$ language 'plpgsql';
GO


create or replace function SrvMessageInfo_BRIEF_F  (
 aSrvMessageInfoid uuid
) returns varchar  as $$ begin return 'SrvMessageInfo'; end; $$ language 'plpgsql';
GO


create or replace function JournalColumn_BRIEF_F  (
 aJournalColumnid uuid
) returns varchar  as $$ begin return 'JournalColumn'; end; $$ language 'plpgsql';
GO


create or replace function JColumnSource_BRIEF_F  (
 aJColumnSourceid uuid
) returns varchar  as $$ begin return 'JColumnSource'; end; $$ language 'plpgsql';
GO


create or replace function Journal_BRIEF_F  (
 aJournalid uuid
) returns varchar  as $$ begin return 'Journal'; end; $$ language 'plpgsql';
GO


create or replace function JournalSrc_BRIEF_F  (
 aJournalSrcid uuid
) returns varchar  as $$ begin return 'JournalSrc'; end; $$ language 'plpgsql';
GO


create or replace function StateAction_BRIEF_F  (
 aStateActionid uuid
) returns varchar  as $$ begin return 'StateAction'; end; $$ language 'plpgsql';
GO


create or replace function REPD_LOCKED_BRIEF_F  (
 aREPD_LOCKEDid uuid
) returns varchar  as $$ begin return 'REPD_LOCKED'; end; $$ language 'plpgsql';
GO


create or replace function REPD_RequestQuery_BRIEF_F  (
 aREPD_RequestQueryid uuid
) returns varchar  as $$ begin return 'REPD_RequestQuery'; end; $$ language 'plpgsql';
GO


create or replace function REPD_ResQueryRcv_BRIEF_F  (
 aREPD_ResQueryRcvid uuid
) returns varchar  as $$ begin return 'REPD_ResQueryRcv'; end; $$ language 'plpgsql';
GO


create or replace function REPD_PROV_BRIEF_F  (
 aREPD_PROVid uuid
) returns varchar  as $$ begin return 'REPD_PROV'; end; $$ language 'plpgsql';
GO


create or replace function REPD_SRV_BRIEF_F  (
 aREPD_SRVid uuid
) returns varchar  as $$ begin return 'REPD_SRV'; end; $$ language 'plpgsql';
GO


create or replace function REPD_SNDTO_BRIEF_F  (
 aREPD_SNDTOid uuid
) returns varchar  as $$ begin return 'REPD_SNDTO'; end; $$ language 'plpgsql';
GO


create or replace function REPD_CONST_BRIEF_F  (
 aREPD_CONSTid uuid
) returns varchar  as $$ begin return 'REPD_CONST'; end; $$ language 'plpgsql';
GO


create or replace function REPD_REPTYPE_BRIEF_F  (
 aREPD_REPTYPEid uuid
) returns varchar  as $$ begin return 'REPD_REPTYPE'; end; $$ language 'plpgsql';
GO


create or replace function REPD_SendQ_BRIEF_F  (
 aREPD_SendQid uuid
) returns varchar  as $$ begin return 'REPD_SendQ'; end; $$ language 'plpgsql';
GO


create or replace function REPD_RecvQ_BRIEF_F  (
 aREPD_RecvQid uuid
) returns varchar  as $$ begin return 'REPD_RecvQ'; end; $$ language 'plpgsql';
GO


create or replace function invi_DEF_BRIEF_F  (
 ainvi_DEFid uuid
) returns varchar  as $$ begin return 'invi_DEF'; end; $$ language 'plpgsql';
GO


create or replace function INVI_PERSONS_BRIEF_F  (
 aINVI_PERSONSid uuid
) returns varchar  as $$ begin return 'INVI_PERSONS'; end; $$ language 'plpgsql';
GO


create or replace function INVI_BAD_BRIEF_F  (
 aINVI_BADid uuid
) returns varchar  as $$ begin return 'INVI_BAD'; end; $$ language 'plpgsql';
GO


create or replace function INVI_CHNG_BRIEF_F  (
 aINVI_CHNGid uuid
) returns varchar  as $$ begin return 'INVI_CHNG'; end; $$ language 'plpgsql';
GO


create or replace function INVI_OBJ_BRIEF_F  (
 aINVI_OBJid uuid
) returns varchar  as $$ begin return 'INVI_OBJ'; end; $$ language 'plpgsql';
GO


create or replace function INVI_DONE_BRIEF_F  (
 aINVI_DONEid uuid
) returns varchar  as $$ begin return 'INVI_DONE'; end; $$ language 'plpgsql';
GO


create or replace function INVI_UNK_BRIEF_F  (
 aINVI_UNKid uuid
) returns varchar  as $$ begin return 'INVI_UNK'; end; $$ language 'plpgsql';
GO


create or replace function STDJournlaExtInfo_BRIEF_F  (
 aSTDJournlaExtInfoid uuid
) returns varchar  as $$ begin return 'STDJournlaExtInfo'; end; $$ language 'plpgsql';
GO


create or replace function STDJournalExtParam_BRIEF_F  (
 aSTDJournalExtParamid uuid
) returns varchar  as $$ begin return 'STDJournalExtParam'; end; $$ language 'plpgsql';
GO


create or replace function STDJournalExtFlt_BRIEF_F  (
 aSTDJournalExtFltid uuid
) returns varchar  as $$ begin return 'STDJournalExtFlt'; end; $$ language 'plpgsql';
GO


create or replace function STDJournalExtField_BRIEF_F  (
 aSTDJournalExtFieldid uuid
) returns varchar  as $$ begin return 'STDJournalExtField'; end; $$ language 'plpgsql';
GO


create or replace function FIELDTYPE_BRIEF_F  (
 aFIELDTYPEid uuid
) returns varchar  as $$ begin return 'FIELDTYPE'; end; $$ language 'plpgsql';
GO


create or replace function FIELDTYPEMAP_BRIEF_F  (
 aFIELDTYPEMAPid uuid
) returns varchar  as $$ begin return 'FIELDTYPEMAP'; end; $$ language 'plpgsql';
GO


create or replace function ENUMITEM_BRIEF_F  (
 aENUMITEMid uuid
) returns varchar  as $$ begin return 'ENUMITEM'; end; $$ language 'plpgsql';
GO


create or replace function SHAREDMETHOD_BRIEF_F  (
 aSHAREDMETHODid uuid
) returns varchar  as $$ begin return 'SHAREDMETHOD'; end; $$ language 'plpgsql';
GO


create or replace function SCRIPT_BRIEF_F  (
 aSCRIPTid uuid
) returns varchar  as $$ begin return 'SCRIPT'; end; $$ language 'plpgsql';
GO


create or replace function PARAMETERS_BRIEF_F  (
 aPARAMETERSid uuid
) returns varchar  as $$ begin return 'PARAMETERS'; end; $$ language 'plpgsql';
GO


create or replace function OBJECTTYPE_BRIEF_F  (
 aOBJECTTYPEid uuid
) returns varchar  as $$ begin return 'OBJECTTYPE'; end; $$ language 'plpgsql';
GO


create or replace function PART_BRIEF_F  (
 aPARTid uuid
) returns varchar  as $$ begin return 'PART'; end; $$ language 'plpgsql';
GO


create or replace function PARTMENU_BRIEF_F  (
 aPARTMENUid uuid
) returns varchar  as $$ begin return 'PARTMENU'; end; $$ language 'plpgsql';
GO


create or replace function PARTPARAMMAP_BRIEF_F  (
 aPARTPARAMMAPid uuid
) returns varchar  as $$ begin return 'PARTPARAMMAP'; end; $$ language 'plpgsql';
GO


create or replace function FIELD_BRIEF_F  (
 aFIELDid uuid
) returns varchar  as $$ begin return 'FIELD'; end; $$ language 'plpgsql';
GO


create or replace function FIELDVALIDATOR_BRIEF_F  (
 aFIELDVALIDATORid uuid
) returns varchar  as $$ begin return 'FIELDVALIDATOR'; end; $$ language 'plpgsql';
GO


create or replace function FIELDMENU_BRIEF_F  (
 aFIELDMENUid uuid
) returns varchar  as $$ begin return 'FIELDMENU'; end; $$ language 'plpgsql';
GO


create or replace function FIELDPARAMMAP_BRIEF_F  (
 aFIELDPARAMMAPid uuid
) returns varchar  as $$ begin return 'FIELDPARAMMAP'; end; $$ language 'plpgsql';
GO


create or replace function FldExtenders_BRIEF_F  (
 aFldExtendersid uuid
) returns varchar  as $$ begin return 'FldExtenders'; end; $$ language 'plpgsql';
GO


create or replace function FIELDEXPRESSION_BRIEF_F  (
 aFIELDEXPRESSIONid uuid
) returns varchar  as $$ begin return 'FIELDEXPRESSION'; end; $$ language 'plpgsql';
GO


create or replace function DINAMICFILTERSCRIPT_BRIEF_F  (
 aDINAMICFILTERSCRIPTid uuid
) returns varchar  as $$ begin return 'DINAMICFILTERSCRIPT'; end; $$ language 'plpgsql';
GO


create or replace function FIELDSRCDEF_BRIEF_F  (
 aFIELDSRCDEFid uuid
) returns varchar  as $$ begin return 'FIELDSRCDEF'; end; $$ language 'plpgsql';
GO


create or replace function PARTVIEW_BRIEF_F  (
 aPARTVIEWid uuid
) returns varchar  as $$ begin return 'PARTVIEW'; end; $$ language 'plpgsql';
GO


create or replace function ViewColumn_BRIEF_F  (
 aViewColumnid uuid
) returns varchar  as $$ begin return 'ViewColumn'; end; $$ language 'plpgsql';
GO


create or replace function PARTVIEW_LNK_BRIEF_F  (
 aPARTVIEW_LNKid uuid
) returns varchar  as $$ begin return 'PARTVIEW_LNK'; end; $$ language 'plpgsql';
GO


create or replace function ExtenderInterface_BRIEF_F  (
 aExtenderInterfaceid uuid
) returns varchar  as $$ begin return 'ExtenderInterface'; end; $$ language 'plpgsql';
GO


create or replace function VALIDATOR_BRIEF_F  (
 aVALIDATORid uuid
) returns varchar  as $$ begin return 'VALIDATOR'; end; $$ language 'plpgsql';
GO


create or replace function UNIQUECONSTRAINT_BRIEF_F  (
 aUNIQUECONSTRAINTid uuid
) returns varchar  as $$ begin return 'UNIQUECONSTRAINT'; end; $$ language 'plpgsql';
GO


create or replace function CONSTRAINTFIELD_BRIEF_F  (
 aCONSTRAINTFIELDid uuid
) returns varchar  as $$ begin return 'CONSTRAINTFIELD'; end; $$ language 'plpgsql';
GO


create or replace function INSTANCEVALIDATOR_BRIEF_F  (
 aINSTANCEVALIDATORid uuid
) returns varchar  as $$ begin return 'INSTANCEVALIDATOR'; end; $$ language 'plpgsql';
GO


create or replace function OBJSTATUS_BRIEF_F  (
 aOBJSTATUSid uuid
) returns varchar  as $$ begin return 'OBJSTATUS'; end; $$ language 'plpgsql';
GO


create or replace function NEXTSTATE_BRIEF_F  (
 aNEXTSTATEid uuid
) returns varchar  as $$ begin return 'NEXTSTATE'; end; $$ language 'plpgsql';
GO


create or replace function OBJECTMODE_BRIEF_F  (
 aOBJECTMODEid uuid
) returns varchar  as $$ begin return 'OBJECTMODE'; end; $$ language 'plpgsql';
GO


create or replace function STRUCTRESTRICTION_BRIEF_F  (
 aSTRUCTRESTRICTIONid uuid
) returns varchar  as $$ begin return 'STRUCTRESTRICTION'; end; $$ language 'plpgsql';
GO


create or replace function FIELDRESTRICTION_BRIEF_F  (
 aFIELDRESTRICTIONid uuid
) returns varchar  as $$ begin return 'FIELDRESTRICTION'; end; $$ language 'plpgsql';
GO


create or replace function METHODRESTRICTION_BRIEF_F  (
 aMETHODRESTRICTIONid uuid
) returns varchar  as $$ begin return 'METHODRESTRICTION'; end; $$ language 'plpgsql';
GO


create or replace function TYPEMENU_BRIEF_F  (
 aTYPEMENUid uuid
) returns varchar  as $$ begin return 'TYPEMENU'; end; $$ language 'plpgsql';
GO


create or replace function MTZAPP_BRIEF_F  (
 aMTZAPPid uuid
) returns varchar  as $$ begin return 'MTZAPP'; end; $$ language 'plpgsql';
GO


create or replace function ParentPackage_BRIEF_F  (
 aParentPackageid uuid
) returns varchar  as $$ begin return 'ParentPackage'; end; $$ language 'plpgsql';
GO


create or replace function GENPACKAGE_BRIEF_F  (
 aGENPACKAGEid uuid
) returns varchar  as $$ begin return 'GENPACKAGE'; end; $$ language 'plpgsql';
GO


create or replace function GENERATOR_TARGET_BRIEF_F  (
 aGENERATOR_TARGETid uuid
) returns varchar  as $$ begin return 'GENERATOR_TARGET'; end; $$ language 'plpgsql';
GO


create or replace function GENMANUALCODE_BRIEF_F  (
 aGENMANUALCODEid uuid
) returns varchar  as $$ begin return 'GENMANUALCODE'; end; $$ language 'plpgsql';
GO


create or replace function GENCONTROLS_BRIEF_F  (
 aGENCONTROLSid uuid
) returns varchar  as $$ begin return 'GENCONTROLS'; end; $$ language 'plpgsql';
GO


create or replace function GENREFERENCE_BRIEF_F  (
 aGENREFERENCEid uuid
) returns varchar  as $$ begin return 'GENREFERENCE'; end; $$ language 'plpgsql';
GO


create or replace function LocalizeInfo_BRIEF_F  (
 aLocalizeInfoid uuid
) returns varchar  as $$ begin return 'LocalizeInfo'; end; $$ language 'plpgsql';
GO


create or replace function Num_zones_BRIEF_F  (
 aNum_zonesid uuid
) returns varchar  as $$ begin return 'Num_zones'; end; $$ language 'plpgsql';
GO


create or replace function Num_Values_BRIEF_F  (
 aNum_Valuesid uuid
) returns varchar  as $$ begin return 'Num_Values'; end; $$ language 'plpgsql';
GO


create or replace function Num_head_BRIEF_F  (
 aNum_headid uuid
) returns varchar  as $$ begin return 'Num_head'; end; $$ language 'plpgsql';
GO


create or replace function Ext_Photos_BRIEF_F  (
 aExt_Photosid uuid
) returns varchar  as $$ begin return 'Ext_Photos'; end; $$ language 'plpgsql';
GO


create or replace function Ext_Photo_Call_BRIEF_F  (
 aExt_Photo_Callid uuid
) returns varchar  as $$ begin return 'Ext_Photo_Call'; end; $$ language 'plpgsql';
GO


create or replace function INVF_DEF_BRIEF_F  (
 aINVF_DEFid uuid
) returns varchar  as $$ begin return 'INVF_DEF'; end; $$ language 'plpgsql';
GO


create or replace function MTZSEC_RIGHT_BRIEF_F  (
 aMTZSEC_RIGHTid uuid
) returns varchar  as $$ begin return 'MTZSEC_RIGHT'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_RENT_BRIEF_F  (
 aINVOS_RENTid uuid
) returns varchar  as $$ begin return 'INVOS_RENT'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_HIST_BRIEF_F  (
 aINVOS_HISTid uuid
) returns varchar  as $$ begin return 'INVOS_HIST'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_OFFRULE_BRIEF_F  (
 aINVOS_OFFRULEid uuid
) returns varchar  as $$ begin return 'INVOS_OFFRULE'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_SROK_BRIEF_F  (
 aINVOS_SROKid uuid
) returns varchar  as $$ begin return 'INVOS_SROK'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_TECH_BRIEF_F  (
 aINVOS_TECHid uuid
) returns varchar  as $$ begin return 'INVOS_TECH'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_WINSOFT_BRIEF_F  (
 aINVOS_WINSOFTid uuid
) returns varchar  as $$ begin return 'INVOS_WINSOFT'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_COMP_BRIEF_F  (
 aINVOS_COMPid uuid
) returns varchar  as $$ begin return 'INVOS_COMP'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_HARD_BRIEF_F  (
 aINVOS_HARDid uuid
) returns varchar  as $$ begin return 'INVOS_HARD'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_CURCFG_BRIEF_F  (
 aINVOS_CURCFGid uuid
) returns varchar  as $$ begin return 'INVOS_CURCFG'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_CFGCH_BRIEF_F  (
 aINVOS_CFGCHid uuid
) returns varchar  as $$ begin return 'INVOS_CFGCH'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_DEVICES_BRIEF_F  (
 aINVOS_DEVICESid uuid
) returns varchar  as $$ begin return 'INVOS_DEVICES'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_DRAG_BRIEF_F  (
 aINVOS_DRAGid uuid
) returns varchar  as $$ begin return 'INVOS_DRAG'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_DOCS_BRIEF_F  (
 aINVOS_DOCSid uuid
) returns varchar  as $$ begin return 'INVOS_DOCS'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_INV_BRIEF_F  (
 aINVOS_INVid uuid
) returns varchar  as $$ begin return 'INVOS_INV'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_LIZING_BRIEF_F  (
 aINVOS_LIZINGid uuid
) returns varchar  as $$ begin return 'INVOS_LIZING'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_CNSRV_BRIEF_F  (
 aINVOS_CNSRVid uuid
) returns varchar  as $$ begin return 'INVOS_CNSRV'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_INFO_BRIEF_F  (
 aINVOS_INFOid uuid
) returns varchar  as $$ begin return 'INVOS_INFO'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_MOD_BRIEF_F  (
 aINVOS_MODid uuid
) returns varchar  as $$ begin return 'INVOS_MOD'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_CMNT_BRIEF_F  (
 aINVOS_CMNTid uuid
) returns varchar  as $$ begin return 'INVOS_CMNT'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_CODE_BRIEF_F  (
 aINVOS_CODEid uuid
) returns varchar  as $$ begin return 'INVOS_CODE'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_REPAIR_BRIEF_F  (
 aINVOS_REPAIRid uuid
) returns varchar  as $$ begin return 'INVOS_REPAIR'; end; $$ language 'plpgsql';
GO


create or replace function INVOS_PLACE_BRIEF_F  (
 aINVOS_PLACEid uuid
) returns varchar  as $$ begin return 'INVOS_PLACE'; end; $$ language 'plpgsql';
GO


create or replace function Reports_BRIEF_F  (
 aReportsid uuid
) returns varchar  as $$ begin return 'Reports'; end; $$ language 'plpgsql';
GO


create or replace function RPTStruct_BRIEF_F  (
 aRPTStructid uuid
) returns varchar  as $$ begin return 'RPTStruct'; end; $$ language 'plpgsql';
GO


create or replace function RPTFields_BRIEF_F  (
 aRPTFieldsid uuid
) returns varchar  as $$ begin return 'RPTFields'; end; $$ language 'plpgsql';
GO


create or replace function RPTFormula_BRIEF_F  (
 aRPTFormulaid uuid
) returns varchar  as $$ begin return 'RPTFormula'; end; $$ language 'plpgsql';
GO


create or replace function Users_BRIEF_F  (
 aUsersid uuid
) returns varchar  as $$ begin return 'Users'; end; $$ language 'plpgsql';
GO


create or replace function Groups_BRIEF_F  (
 aGroupsid uuid
) returns varchar  as $$ begin return 'Groups'; end; $$ language 'plpgsql';
GO


create or replace function GroupUser_BRIEF_F  (
 aGroupUserid uuid
) returns varchar  as $$ begin return 'GroupUser'; end; $$ language 'plpgsql';
GO


create or replace function SysLog_BRIEF_F  (
 aSysLogid uuid
) returns varchar  as $$ begin return 'SysLog'; end; $$ language 'plpgsql';
GO


create or replace function the_Session_BRIEF_F  (
 athe_Sessionid uuid
) returns varchar  as $$ begin return 'the_Session'; end; $$ language 'plpgsql';
GO


create or replace function LogReader_BRIEF_F  (
 aLogReaderid uuid
) returns varchar  as $$ begin return 'LogReader'; end; $$ language 'plpgsql';
GO


create or replace function Verb_BRIEF_F  (
 aVerbid uuid
) returns varchar  as $$ begin return 'Verb'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_USER_BRIEF_F  (
 aROLES_USERid uuid
) returns varchar  as $$ begin return 'ROLES_USER'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_MAP_BRIEF_F  (
 aROLES_MAPid uuid
) returns varchar  as $$ begin return 'ROLES_MAP'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_DOC_BRIEF_F  (
 aROLES_DOCid uuid
) returns varchar  as $$ begin return 'ROLES_DOC'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_DOC_STATE_BRIEF_F  (
 aROLES_DOC_STATEid uuid
) returns varchar  as $$ begin return 'ROLES_DOC_STATE'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_DEF_BRIEF_F  (
 aROLES_DEFid uuid
) returns varchar  as $$ begin return 'ROLES_DEF'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_REPORTS_BRIEF_F  (
 aROLES_REPORTSid uuid
) returns varchar  as $$ begin return 'ROLES_REPORTS'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_WP_BRIEF_F  (
 aROLES_WPid uuid
) returns varchar  as $$ begin return 'ROLES_WP'; end; $$ language 'plpgsql';
GO


create or replace function ROLES_ACT_BRIEF_F  (
 aROLES_ACTid uuid
) returns varchar  as $$ begin return 'ROLES_ACT'; end; $$ language 'plpgsql';
GO


create or replace function WorkPlace_BRIEF_F  (
 aWorkPlaceid uuid
) returns varchar  as $$ begin return 'WorkPlace'; end; $$ language 'plpgsql';
GO


create or replace function EntryPoints_BRIEF_F  (
 aEntryPointsid uuid
) returns varchar  as $$ begin return 'EntryPoints'; end; $$ language 'plpgsql';
GO


create or replace function EPFilterLink_BRIEF_F  (
 aEPFilterLinkid uuid
) returns varchar  as $$ begin return 'EPFilterLink'; end; $$ language 'plpgsql';
GO


create or replace function ARMTypes_BRIEF_F  (
 aARMTypesid uuid
) returns varchar  as $$ begin return 'ARMTypes'; end; $$ language 'plpgsql';
GO


create or replace function ARMJournal_BRIEF_F  (
 aARMJournalid uuid
) returns varchar  as $$ begin return 'ARMJournal'; end; $$ language 'plpgsql';
GO


create or replace function ARMJRNLADD_BRIEF_F  (
 aARMJRNLADDid uuid
) returns varchar  as $$ begin return 'ARMJRNLADD'; end; $$ language 'plpgsql';
GO


create or replace function ARMJRNLREP_BRIEF_F  (
 aARMJRNLREPid uuid
) returns varchar  as $$ begin return 'ARMJRNLREP'; end; $$ language 'plpgsql';
GO


create or replace function ARMJRNLRUN_BRIEF_F  (
 aARMJRNLRUNid uuid
) returns varchar  as $$ begin return 'ARMJRNLRUN'; end; $$ language 'plpgsql';
GO


create or replace function INVD_UPR_BRIEF_F  (
 aINVD_UPRid uuid
) returns varchar  as $$ begin return 'INVD_UPR'; end; $$ language 'plpgsql';
GO


create or replace function INVD_OTDEL_BRIEF_F  (
 aINVD_OTDELid uuid
) returns varchar  as $$ begin return 'INVD_OTDEL'; end; $$ language 'plpgsql';
GO


create or replace function INVD_BLD_BRIEF_F  (
 aINVD_BLDid uuid
) returns varchar  as $$ begin return 'INVD_BLD'; end; $$ language 'plpgsql';
GO


create or replace function INVD_DRAG_BRIEF_F  (
 aINVD_DRAGid uuid
) returns varchar  as $$ begin return 'INVD_DRAG'; end; $$ language 'plpgsql';
GO


create or replace function INVD_ORG_BRIEF_F  (
 aINVD_ORGid uuid
) returns varchar  as $$ begin return 'INVD_ORG'; end; $$ language 'plpgsql';
GO


create or replace function INVD_OSSTATUS_BRIEF_F  (
 aINVD_OSSTATUSid uuid
) returns varchar  as $$ begin return 'INVD_OSSTATUS'; end; $$ language 'plpgsql';
GO


create or replace function INVD_OWNER_BRIEF_F  (
 aINVD_OWNERid uuid
) returns varchar  as $$ begin return 'INVD_OWNER'; end; $$ language 'plpgsql';
GO


create or replace function INVD_UR_BRIEF_F  (
 aINVD_URid uuid
) returns varchar  as $$ begin return 'INVD_UR'; end; $$ language 'plpgsql';
GO


create or replace function INVD_OSTYPE_BRIEF_F  (
 aINVD_OSTYPEid uuid
) returns varchar  as $$ begin return 'INVD_OSTYPE'; end; $$ language 'plpgsql';
GO


create or replace function INVD_DIR_BRIEF_F  (
 aINVD_DIRid uuid
) returns varchar  as $$ begin return 'INVD_DIR'; end; $$ language 'plpgsql';
GO


create or replace function MTZ_Inst_Build_BRIEF_F  (
 aMTZ_Inst_Buildid uuid
) returns varchar  as $$ begin return 'MTZ_Inst_Build'; end; $$ language 'plpgsql';
GO


create or replace function MTZ_Inst_Build_Sec_BRIEF_F  (
 aMTZ_Inst_Build_Secid uuid
) returns varchar  as $$ begin return 'MTZ_Inst_Build_Sec'; end; $$ language 'plpgsql';
GO


create or replace function MTZ_Inst_Section_BRIEF_F  (
 aMTZ_Inst_Sectionid uuid
) returns varchar  as $$ begin return 'MTZ_Inst_Section'; end; $$ language 'plpgsql';
GO


create or replace function MTZ_Inst_Sec_Files_BRIEF_F  (
 aMTZ_Inst_Sec_Filesid uuid
) returns varchar  as $$ begin return 'MTZ_Inst_Sec_Files'; end; $$ language 'plpgsql';
GO


create or replace function MTZ_Inst_Common_BRIEF_F  (
 aMTZ_Inst_Commonid uuid
) returns varchar  as $$ begin return 'MTZ_Inst_Common'; end; $$ language 'plpgsql';
GO


create or replace function InfoStoreDef_BRIEF_F  (
 aInfoStoreDefid uuid
) returns varchar  as $$ begin return 'InfoStoreDef'; end; $$ language 'plpgsql';
GO


create or replace function Folder_BRIEF_F  (
 aFolderid uuid
) returns varchar  as $$ begin return 'Folder'; end; $$ language 'plpgsql';
GO


create or replace function Shortcut_BRIEF_F  (
 aShortcutid uuid
) returns varchar  as $$ begin return 'Shortcut'; end; $$ language 'plpgsql';
GO


create or replace function MTZExt_def_BRIEF_F  (
 aMTZExt_defid uuid
) returns varchar  as $$ begin return 'MTZExt_def'; end; $$ language 'plpgsql';
GO


create or replace function MTZExtRel_BRIEF_F  (
 aMTZExtRelid uuid
) returns varchar  as $$ begin return 'MTZExtRel'; end; $$ language 'plpgsql';
GO


create or replace function INVN_DEF_BRIEF_F  (
 aINVN_DEFid uuid
) returns varchar  as $$ begin return 'INVN_DEF'; end; $$ language 'plpgsql';
GO

;

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Views" File=""><BlockHolder BlockName="--body" BlockCode=" 

create or replace view v_INSTANCE as
select instance.*,objstatus.name statusname,objstatus.IsArchive
from instance left join objstatus on instance.status=objstatus.objstatusid
;
GO

create or replace view V_viewMTZFltr_Filters as 
select   FiltersID
, 
Filters.TheCaption 
Filters_TheCaption 
, 
Filters.Name 
Filters_Name 
, Filters.InstanceID InstanceID 
, Filters.FiltersID ID 
, 'Filters' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Filters
 join INSTANCE on Filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZJrnl_Jo as 
select   JournalID
, 
Journal.TheComment 
Journal_TheComment 
, 
Journal.Name 
Journal_Name 
, 
Journal.the_Alias 
Journal_the_Alias 
, Journal.InstanceID InstanceID 
, Journal.JournalID ID 
, 'Journal' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Journal
 join INSTANCE on Journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOinvi_DEF as 
select   invi_DEFID
, 
 invi_DEF.Uprev  
invi_DEF_Uprev_ID, 
  INVD_UPR_BRIEF_F(invi_DEF.Uprev) 
invi_DEF_Uprev 
, 
invi_DEF.EndDate 
invi_DEF_EndDate 
, 
 invi_DEF.TheOrg  
invi_DEF_TheOrg_ID, 
  INVD_ORG_BRIEF_F(invi_DEF.TheOrg) 
invi_DEF_TheOrg 
, 
invi_DEF.TheWorkPlace 
invi_DEF_TheWorkPlace 
, 
 invi_DEF.TheOwner  
invi_DEF_TheOwner_ID, 
  INVD_OWNER_BRIEF_F(invi_DEF.TheOwner) 
invi_DEF_TheOwner 
, 
 invi_DEF.MatOtv  
invi_DEF_MatOtv_ID, 
  INVD_OWNER_BRIEF_F(invi_DEF.MatOtv) 
invi_DEF_MatOtv 
, 
invi_DEF.TheRoom 
invi_DEF_TheRoom 
, 
 invi_DEF.Building  
invi_DEF_Building_ID, 
  INVD_BLD_BRIEF_F(invi_DEF.Building) 
invi_DEF_Building 
, 
invi_DEF.StartDate 
invi_DEF_StartDate 
, 
invi_DEF.OrderNum 
invi_DEF_OrderNum 
, 
 invi_DEF.DIrection  
invi_DEF_DIrection_ID, 
  INVD_DIR_BRIEF_F(invi_DEF.DIrection) 
invi_DEF_DIrection 
, 
invi_DEF.Info 
invi_DEF_Info 
, 
 invi_DEF.Otdel  
invi_DEF_Otdel_ID, 
  INVD_OTDEL_BRIEF_F(invi_DEF.Otdel) 
invi_DEF_Otdel 
, 
invi_DEF.TheFlow 
invi_DEF_TheFlow 
, invi_DEF.InstanceID InstanceID 
, invi_DEF.invi_DEFID ID 
, 'invi_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from invi_DEF
 join INSTANCE on invi_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVI_PERSONS as 
select   INVI_PERSONSID
, 
INVI_PERSONS.FamiliName 
INVI_PERSONS_FamiliName 
, 
INVI_PERSONS.SurName 
INVI_PERSONS_SurName 
, 
INVI_PERSONS.ThePosition 
INVI_PERSONS_ThePosition 
, 
INVI_PERSONS.Name 
INVI_PERSONS_Name 
, INVI_PERSONS.InstanceID InstanceID 
, INVI_PERSONS.INVI_PERSONSID ID 
, 'INVI_PERSONS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVI_PERSONS
 join INSTANCE on INVI_PERSONS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVI_OBJ as 
select   INVI_OBJID
, 
 INVI_OBJ.TheOS  
INVI_OBJ_TheOS_ID, 
  INVOS_INFO_BRIEF_F(INVI_OBJ.TheOS) 
INVI_OBJ_TheOS 
, INVI_OBJ.InstanceID InstanceID 
, INVI_OBJ.INVI_OBJID ID 
, 'INVI_OBJ' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVI_OBJ
 join INSTANCE on INVI_OBJ.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVI_DONE as 
select   INVI_DONEID
, 
INVI_DONE.CheckDate 
INVI_DONE_CheckDate 
, 
 INVI_DONE.TheOS  
INVI_DONE_TheOS_ID, 
  INVOS_INFO_BRIEF_F(INVI_DONE.TheOS) 
INVI_DONE_TheOS 
, 
 INVI_DONE.OSStatus  
INVI_DONE_OSStatus_ID, 
  INVD_OSSTATUS_BRIEF_F(INVI_DONE.OSStatus) 
INVI_DONE_OSStatus 
, INVI_DONE.InstanceID InstanceID 
, INVI_DONE.INVI_DONEID ID 
, 'INVI_DONE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVI_DONE
 join INSTANCE on INVI_DONE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindFieldType as 
select   FIELDTYPEID
, 
 FIELDTYPE.TypeStyle  
FIELDTYPE_TypeStyle_VAL, 
 ( case FIELDTYPE.TypeStyle 
 when 3 then 'Интервал'
 when 5 then 'Элемент оформления'
 when 0 then 'Скалярный тип'
 when 4 then 'Ссылка'
 when 2 then 'Перечисление'
 when 1 then 'Выражение'
 else '???' end) 
FIELDTYPE_TypeStyle 
, 
FIELDTYPE.Name 
FIELDTYPE_Name 
, 
FIELDTYPE.the_Comment 
FIELDTYPE_Comment 
, FIELDTYPE.InstanceID InstanceID 
, FIELDTYPE.FIELDTYPEID ID 
, 'FIELDTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from FIELDTYPE
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindMethod as 
select   SHAREDMETHODID
, 
SHAREDMETHOD.Name 
SHAREDMETHOD_Name 
, 
SHAREDMETHOD.the_Comment 
SHAREDMETHOD_Comment 
, SHAREDMETHOD.InstanceID InstanceID 
, SHAREDMETHOD.SHAREDMETHODID ID 
, 'SHAREDMETHOD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from SHAREDMETHOD
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindOBJECTTYPE as 
select   OBJECTTYPEID
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_Comment 
, 
 OBJECTTYPE.Package  
OBJECTTYPE_Package_ID, 
  MTZAPP_BRIEF_F(OBJECTTYPE.Package) 
OBJECTTYPE_Package 
, 
OBJECTTYPE.Name 
OBJECTTYPE_Name 
, OBJECTTYPE.InstanceID InstanceID 
, OBJECTTYPE.OBJECTTYPEID ID 
, 'OBJECTTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from OBJECTTYPE
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindPart as 
select   PARTID,OBJECTTYPEID
, 
OBJECTTYPE.Name 
OBJECTTYPE_Name 
, 
PART.Caption 
PART_Caption 
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_Comment 
, 
PART.the_Comment 
PART_Comment 
, 
PART.Name 
PART_Name 
, OBJECTTYPE.InstanceID InstanceID 
, PART.PARTID ID 
, 'PART' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from PART
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindPARTMENU as 
select   PARTMENUID,PARTID,OBJECTTYPEID
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_Comment 
, 
PARTMENU.Name 
PARTMENU_Name 
, 
PART.the_Comment 
PART_Comment 
, OBJECTTYPE.InstanceID InstanceID 
, PARTMENU.PARTMENUID ID 
, 'PARTMENU' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from PARTMENU
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindField as 
select   FIELDID,PARTID,OBJECTTYPEID
, 
FIELD.Name 
FIELD_Name 
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_Comment 
, 
FIELD.Caption 
FIELD_Caption 
, 
PART.the_Comment 
PART_Comment 
, OBJECTTYPE.InstanceID InstanceID 
, FIELD.FIELDID ID 
, 'FIELD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from FIELD
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZMetaModel_OBJECTMODE as 
select   OBJECTMODEID,OBJECTTYPEID
, 
 OBJECTTYPE.AllowSearch  
OBJECTTYPE_AllowSearch_VAL, 
 ( case OBJECTTYPE.AllowSearch 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
OBJECTTYPE_AllowSearch 
, 
 OBJECTTYPE.ReplicaType  
OBJECTTYPE_ReplicaType_VAL, 
 ( case OBJECTTYPE.ReplicaType 
 when 0 then 'Весь документ'
 when 2 then 'Локальный'
 when 1 then 'Построчно'
 else '???' end) 
OBJECTTYPE_ReplicaType 
, 
 OBJECTTYPE.Package  
OBJECTTYPE_Package_ID, 
  MTZAPP_BRIEF_F(OBJECTTYPE.Package) 
OBJECTTYPE_Package 
, 
 OBJECTMODE.DefaultMode  
OBJECTMODE_DefaultMode_VAL, 
 ( case OBJECTMODE.DefaultMode 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
OBJECTMODE_DefaultMode 
, 
 OBJECTTYPE.IsSingleInstance  
OBJECTTYPE_IsSingleInstance_VAL, 
 ( case OBJECTTYPE.IsSingleInstance 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
OBJECTTYPE_IsSingleInstance 
, 
 OBJECTTYPE.OnRun  
OBJECTTYPE_OnRun_ID, 
  TYPEMENU_BRIEF_F(OBJECTTYPE.OnRun) 
OBJECTTYPE_OnRun 
, 
 OBJECTTYPE.ChooseView  
OBJECTTYPE_ChooseView_ID, 
  PARTVIEW_BRIEF_F(OBJECTTYPE.ChooseView) 
OBJECTTYPE_ChooseView 
, 
 OBJECTTYPE.OnDelete  
OBJECTTYPE_OnDelete_ID, 
  TYPEMENU_BRIEF_F(OBJECTTYPE.OnDelete) 
OBJECTTYPE_OnDelete 
, 
OBJECTMODE.Name 
OBJECTMODE_Name 
, 
 OBJECTTYPE.OnCreate  
OBJECTTYPE_OnCreate_ID, 
  TYPEMENU_BRIEF_F(OBJECTTYPE.OnCreate) 
OBJECTTYPE_OnCreate 
, 
 OBJECTTYPE.AllowRefToObject  
OBJECTTYPE_AllowRefToObject_VAL, 
 ( case OBJECTTYPE.AllowRefToObject 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
OBJECTTYPE_AllowRefToObject 
, 
OBJECTTYPE.Name 
OBJECTTYPE_Name 
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_the_Comment 
, OBJECTTYPE.InstanceID InstanceID 
, OBJECTMODE.OBJECTMODEID ID 
, 'OBJECTMODE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from OBJECTMODE
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindTYPEMENU as 
select   TYPEMENUID,OBJECTTYPEID
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_Comment 
, 
TYPEMENU.Name 
TYPEMENU_Name 
, OBJECTTYPE.InstanceID InstanceID 
, TYPEMENU.TYPEMENUID ID 
, 'TYPEMENU' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from TYPEMENU
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=TYPEMENU.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindMTZAPP as 
select   MTZAPPID
, 
MTZAPP.Name 
MTZAPP_Name 
, MTZAPP.InstanceID InstanceID 
, MTZAPP.MTZAPPID ID 
, 'MTZAPP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from MTZAPP
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindGENPACKAGE as 
select   GENPACKAGEID
, 
GENPACKAGE.Name 
GENPACKAGE_Name 
, GENPACKAGE.InstanceID InstanceID 
, GENPACKAGE.GENPACKAGEID ID 
, 'GENPACKAGE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from GENPACKAGE
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindGENERATOR_TARGET as 
select   GENERATOR_TARGETID,GENPACKAGEID
, 
GENERATOR_TARGET.Name 
GENERATOR_TARGET_Name 
, 
GENPACKAGE.Name 
GENPACKAGE_Name 
, GENPACKAGE.InstanceID InstanceID 
, GENERATOR_TARGET.GENERATOR_TARGETID ID 
, 'GENERATOR_TARGET' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from GENERATOR_TARGET
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewSTDNumerator_Num_Values as 
select   Num_ValuesID,Num_zonesID
, 
Num_zones.ZoneMask 
Num_zones_ZoneMask 
, 
Num_Values.the_Value 
Num_Values_Value 
, 
 Num_head.Shema  
Num_head_Shema_VAL, 
 ( case Num_head.Shema 
 when 0 then 'Единая зона'
 when 1 then 'По году'
 when 4 then 'По дню'
 when 2 then 'По кварталу'
 when 3 then 'По месяцу'
 when 10 then 'Произвольные зоны'
 else '???' end) 
Num_head_Shema 
, 
Num_head.Name 
Num_head_Name 
, Num_zones.InstanceID InstanceID 
, Num_Values.Num_ValuesID ID 
, 'Num_Values' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Num_Values
 join Num_zones on Num_zones.Num_zonesID=Num_Values.ParentStructRowID 
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid left join Num_head ON Num_head.InstanceID=Num_zones.InstanceID 
;
GO

create or replace view V_viewSTDNumerator_Num_head as 
select   Num_headID
, 
 Num_head.Shema  
Num_head_Shema_VAL, 
 ( case Num_head.Shema 
 when 0 then 'Единая зона'
 when 1 then 'По году'
 when 4 then 'По дню'
 when 2 then 'По кварталу'
 when 3 then 'По месяцу'
 when 10 then 'Произвольные зоны'
 else '???' end) 
Num_head_Shema 
, 
Num_head.Name 
Num_head_Name 
, Num_head.InstanceID InstanceID 
, Num_head.Num_headID ID 
, 'Num_head' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Num_head
 join INSTANCE on Num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVF_DEF as 
select   INVF_DEFID
, 
INVF_DEF.LoadDate 
INVF_DEF_LoadDate 
, 
 INVF_DEF.TheUser  
INVF_DEF_TheUser_ID, 
  Users_BRIEF_F(INVF_DEF.TheUser) 
INVF_DEF_TheUser 
, 
INVF_DEF.ThePath 
INVF_DEF_ThePath 
, 
INVF_DEF.TypeOfFile 
INVF_DEF_TypeOfFile 
, 
INVF_DEF.TheHash 
INVF_DEF_TheHash 
, INVF_DEF.InstanceID InstanceID 
, INVF_DEF.INVF_DEFID ID 
, 'INVF_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVF_DEF
 join INSTANCE on INVF_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindMTZSEC_RIGHT as 
select   MTZSEC_RIGHTID
, 
MTZSEC_RIGHT.ProtectedItem 
MTZSEC_RIGHT_ProtectedItem 
, 
MTZSEC_RIGHT.Piority 
MTZSEC_RIGHT_Piority 
, 
 MTZSEC_RIGHT.Allow  
MTZSEC_RIGHT_Allow_VAL, 
 ( case MTZSEC_RIGHT.Allow 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
MTZSEC_RIGHT_Allow 
, 
 MTZSEC_RIGHT.TheGroup  
MTZSEC_RIGHT_TheGroup_ID, 
  Groups_BRIEF_F(MTZSEC_RIGHT.TheGroup) 
MTZSEC_RIGHT_TheGroup 
, MTZSEC_RIGHT.InstanceID InstanceID 
, MTZSEC_RIGHT.MTZSEC_RIGHTID ID 
, 'MTZSEC_RIGHT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from MTZSEC_RIGHT
 join INSTANCE on MTZSEC_RIGHT.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_RENT as 
select   INVOS_RENTID
, 
INVOS_RENT.EndDate 
INVOS_RENT_EndDate 
, 
 INVOS_RENT.arendator  
INVOS_RENT_arendator_ID, 
  INVD_UR_BRIEF_F(INVOS_RENT.arendator) 
INVOS_RENT_arendator 
, 
INVOS_RENT.StartDate 
INVOS_RENT_StartDate 
, INVOS_RENT.InstanceID InstanceID 
, INVOS_RENT.INVOS_RENTID ID 
, 'INVOS_RENT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_RENT
 join INSTANCE on INVOS_RENT.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_HIST as 
select   INVOS_HISTID
, 
 INVOS_HIST.Otdel  
INVOS_HIST_Otdel_ID, 
  INVD_OTDEL_BRIEF_F(INVOS_HIST.Otdel) 
INVOS_HIST_Otdel 
, 
INVOS_HIST.UntilDate 
INVOS_HIST_UntilDate 
, 
INVOS_HIST.Flow 
INVOS_HIST_Flow 
, 
 INVOS_HIST.Uprav  
INVOS_HIST_Uprav_ID, 
  INVD_UPR_BRIEF_F(INVOS_HIST.Uprav) 
INVOS_HIST_Uprav 
, 
 INVOS_HIST.DIrection  
INVOS_HIST_DIrection_ID, 
  INVD_DIR_BRIEF_F(INVOS_HIST.DIrection) 
INVOS_HIST_DIrection 
, 
 INVOS_HIST.TheOwner  
INVOS_HIST_TheOwner_ID, 
  INVD_OWNER_BRIEF_F(INVOS_HIST.TheOwner) 
INVOS_HIST_TheOwner 
, 
 INVOS_HIST.TheHouse  
INVOS_HIST_TheHouse_ID, 
  INVD_BLD_BRIEF_F(INVOS_HIST.TheHouse) 
INVOS_HIST_TheHouse 
, 
 INVOS_HIST.ChangedBy  
INVOS_HIST_ChangedBy_ID, 
  Users_BRIEF_F(INVOS_HIST.ChangedBy) 
INVOS_HIST_ChangedBy 
, 
INVOS_HIST.Room 
INVOS_HIST_Room 
, 
INVOS_HIST.ComplNumber 
INVOS_HIST_ComplNumber 
, 
INVOS_HIST.WorkPlaceNum 
INVOS_HIST_WorkPlaceNum 
, INVOS_HIST.InstanceID InstanceID 
, INVOS_HIST.INVOS_HISTID ID 
, 'INVOS_HIST' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_HIST
 join INSTANCE on INVOS_HIST.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_OFFRULE as 
select   INVOS_OFFRULEID
, 
INVOS_OFFRULE.DocDate 
INVOS_OFFRULE_DocDate 
, 
INVOS_OFFRULE.DocNumber 
INVOS_OFFRULE_DocNumber 
, 
INVOS_OFFRULE.INFO 
INVOS_OFFRULE_INFO 
, 
INVOS_OFFRULE.TheComment 
INVOS_OFFRULE_TheComment 
, INVOS_OFFRULE.InstanceID InstanceID 
, INVOS_OFFRULE.INVOS_OFFRULEID ID 
, 'INVOS_OFFRULE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_OFFRULE
 join INSTANCE on INVOS_OFFRULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_SROK as 
select   INVOS_SROKID
, 
INVOS_SROK.RecalcDate 
INVOS_SROK_RecalcDate 
, INVOS_SROK.InstanceID InstanceID 
, INVOS_SROK.INVOS_SROKID ID 
, 'INVOS_SROK' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_SROK
 join INSTANCE on INVOS_SROK.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_TECH as 
select   INVOS_TECHID
, 
INVOS_TECH.Computer_Name 
INVOS_TECH_Computer_Name 
, 
INVOS_TECH.Current_User_Name 
INVOS_TECH_Current_User_Name 
, 
INVOS_TECH.IP_Addr 
INVOS_TECH_IP_Addr 
, 
INVOS_TECH.Record_Date 
INVOS_TECH_Record_Date 
, 
INVOS_TECH.System 
INVOS_TECH_System 
, 
INVOS_TECH.Param_0 
INVOS_TECH_Param_0 
, 
INVOS_TECH.MAC_Addr 
INVOS_TECH_MAC_Addr 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_TECH.INVOS_TECHID ID 
, 'INVOS_TECH' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_TECH
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_WINSOFT as 
select   INVOS_WINSOFTID,INVOS_TECHID
, 
INVOS_WINSOFT.Name 
INVOS_WINSOFT_Name 
, 
INVOS_WINSOFT.ParamValue 
INVOS_WINSOFT_ParamValue 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_WINSOFT.INVOS_WINSOFTID ID 
, 'INVOS_WINSOFT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_WINSOFT
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_WINSOFT.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_COMP as 
select   INVOS_COMPID,INVOS_TECHID
, 
INVOS_COMP.ParamValue 
INVOS_COMP_ParamValue 
, 
INVOS_COMP.Name 
INVOS_COMP_Name 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_COMP.INVOS_COMPID ID 
, 'INVOS_COMP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_COMP
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_COMP.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_HARD as 
select   INVOS_HARDID,INVOS_TECHID
, 
INVOS_HARD.Name 
INVOS_HARD_Name 
, 
INVOS_HARD.ParamValue 
INVOS_HARD_ParamValue 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_HARD.INVOS_HARDID ID 
, 'INVOS_HARD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_HARD
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_HARD.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_CURCFG as 
select   INVOS_CURCFGID,INVOS_TECHID
, 
INVOS_CURCFG.ParamValue 
INVOS_CURCFG_ParamValue 
, 
INVOS_CURCFG.Name 
INVOS_CURCFG_Name 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_CURCFG.INVOS_CURCFGID ID 
, 'INVOS_CURCFG' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_CURCFG
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_CURCFG.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_CFGCH as 
select   INVOS_CFGCHID,INVOS_TECHID
, 
INVOS_CFGCH.ChDate 
INVOS_CFGCH_ChDate 
, 
INVOS_CFGCH.ChNum 
INVOS_CFGCH_ChNum 
, 
INVOS_CFGCH.TheValue 
INVOS_CFGCH_TheValue 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_CFGCH.INVOS_CFGCHID ID 
, 'INVOS_CFGCH' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_CFGCH
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_CFGCH.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_DEVICES as 
select   INVOS_DEVICESID,INVOS_TECHID
, 
INVOS_DEVICES.ParamValue 
INVOS_DEVICES_ParamValue 
, 
INVOS_DEVICES.Name 
INVOS_DEVICES_Name 
, INVOS_TECH.InstanceID InstanceID 
, INVOS_DEVICES.INVOS_DEVICESID ID 
, 'INVOS_DEVICES' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_DEVICES
 join INVOS_TECH on INVOS_TECH.INVOS_TECHID=INVOS_DEVICES.ParentStructRowID 
 join INSTANCE on INVOS_TECH.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_INV as 
select   INVOS_INVID
, 
INVOS_INV.InvDate 
INVOS_INV_InvDate 
, 
 INVOS_INV.Inventory  
INVOS_INV_Inventory_ID, 
  invi_DEF_BRIEF_F(INVOS_INV.Inventory) 
INVOS_INV_Inventory 
, 
 INVOS_INV.OSStatus  
INVOS_INV_OSStatus_ID, 
  INVD_OSSTATUS_BRIEF_F(INVOS_INV.OSStatus) 
INVOS_INV_OSStatus 
, INVOS_INV.InstanceID InstanceID 
, INVOS_INV.INVOS_INVID ID 
, 'INVOS_INV' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_INV
 join INSTANCE on INVOS_INV.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_LIZING as 
select   INVOS_LIZINGID
, 
INVOS_LIZING.TheDate 
INVOS_LIZING_TheDate 
, 
INVOS_LIZING.DocNumber 
INVOS_LIZING_DocNumber 
, 
 INVOS_LIZING.TheAgent  
INVOS_LIZING_TheAgent_ID, 
  INVD_UR_BRIEF_F(INVOS_LIZING.TheAgent) 
INVOS_LIZING_TheAgent 
, INVOS_LIZING.InstanceID InstanceID 
, INVOS_LIZING.INVOS_LIZINGID ID 
, 'INVOS_LIZING' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_LIZING
 join INSTANCE on INVOS_LIZING.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_CNSRV as 
select   INVOS_CNSRVID
, 
INVOS_CNSRV.EndDate 
INVOS_CNSRV_EndDate 
, 
INVOS_CNSRV.StartDate 
INVOS_CNSRV_StartDate 
, 
INVOS_CNSRV.DocNumber 
INVOS_CNSRV_DocNumber 
, INVOS_CNSRV.InstanceID InstanceID 
, INVOS_CNSRV.INVOS_CNSRVID ID 
, 'INVOS_CNSRV' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_CNSRV
 join INSTANCE on INVOS_CNSRV.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_INFO as 
select   INVOS_INFOID
, 
 INVOS_PLACE.TheHouse  
INVOS_PLACE_TheHouse_ID, 
  INVD_BLD_BRIEF_F(INVOS_PLACE.TheHouse) 
INVOS_PLACE_TheHouse 
, 
 INVOS_CODE.MabualCreate  
INVOS_CODE_MabualCreate_VAL, 
 ( case INVOS_CODE.MabualCreate 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVOS_CODE_MabualCreate 
, 
 INVOS_PLACE.MatOtv  
INVOS_PLACE_MatOtv_ID, 
  INVD_OWNER_BRIEF_F(INVOS_PLACE.MatOtv) 
INVOS_PLACE_MatOtv 
, 
INVOS_INFO.Info 
INVOS_INFO_Info 
, 
INVOS_INFO.TechFilePath 
INVOS_INFO_TechFilePath 
, 
INVOS_CODE.VisibleCode 
INVOS_CODE_VisibleCode 
, 
INVOS_TECH.MAC_Addr 
INVOS_TECH_MAC_Addr 
, 
INVOS_INFO.SrokFI 
INVOS_INFO_SrokFI 
, 
INVOS_PLACE.Info 
INVOS_PLACE_Info 
, 
 INVOS_INFO.TheOrg  
INVOS_INFO_TheOrg_ID, 
  INVD_ORG_BRIEF_F(INVOS_INFO.TheOrg) 
INVOS_INFO_TheOrg 
, 
INVOS_INFO.CardNum 
INVOS_INFO_CardNum 
, 
 INVOS_INFO.IsMaterial  
INVOS_INFO_IsMaterial_VAL, 
 ( case INVOS_INFO.IsMaterial 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVOS_INFO_IsMaterial 
, 
 INVOS_PLACE.Otdel  
INVOS_PLACE_Otdel_ID, 
  INVD_OTDEL_BRIEF_F(INVOS_PLACE.Otdel) 
INVOS_PLACE_Otdel 
, 
INVOS_PLACE.Flow 
INVOS_PLACE_Flow 
, 
INVOS_INFO.Name 
INVOS_INFO_Name 
, 
INVOS_INFO.SrokPI 
INVOS_INFO_SrokPI 
, 
INVOS_INFO.INVNum 
INVOS_INFO_INVNum 
, 
INVOS_INFO.InLineNum 
INVOS_INFO_InLineNum 
, 
INVOS_INFO.ActivateDate 
INVOS_INFO_ActivateDate 
, 
INVOS_PLACE.WorkPlaceNum 
INVOS_PLACE_WorkPlaceNum 
, 
INVOS_INFO.SrokOI 
INVOS_INFO_SrokOI 
, 
INVOS_PLACE.ComplNumber 
INVOS_PLACE_ComplNumber 
, 
 INVOS_PLACE.Uprav  
INVOS_PLACE_Uprav_ID, 
  INVD_UPR_BRIEF_F(INVOS_PLACE.Uprav) 
INVOS_PLACE_Uprav 
, 
 INVOS_PLACE.DIrection  
INVOS_PLACE_DIrection_ID, 
  INVD_DIR_BRIEF_F(INVOS_PLACE.DIrection) 
INVOS_PLACE_DIrection 
, 
INVOS_PLACE.Room 
INVOS_PLACE_Room 
, 
 INVOS_CODE.CodePrinted  
INVOS_CODE_CodePrinted_VAL, 
 ( case INVOS_CODE.CodePrinted 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVOS_CODE_CodePrinted 
, 
INVOS_INFO.ShortName 
INVOS_INFO_ShortName 
, 
INVOS_TECH.IP_Addr 
INVOS_TECH_IP_Addr 
, 
 INVOS_PLACE.TheOwner  
INVOS_PLACE_TheOwner_ID, 
  INVD_OWNER_BRIEF_F(INVOS_PLACE.TheOwner) 
INVOS_PLACE_TheOwner 
, 
INVOS_INFO.TheCost 
INVOS_INFO_TheCost 
, 
INVOS_SROK.RecalcDate 
INVOS_SROK_RecalcDate 
, 
 INVOS_INFO.OSType  
INVOS_INFO_OSType_ID, 
  INVD_OSTYPE_BRIEF_F(INVOS_INFO.OSType) 
INVOS_INFO_OSType 
, 
INVOS_TECH.Computer_Name 
INVOS_TECH_Computer_Name 
, INVOS_INFO.InstanceID InstanceID 
, INVOS_INFO.INVOS_INFOID ID 
, 'INVOS_INFO' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_INFO
 join INSTANCE on INVOS_INFO.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid left join INVOS_PLACE ON INVOS_PLACE.InstanceID=INVOS_INFO.InstanceID left join INVOS_CODE ON INVOS_CODE.InstanceID=INVOS_INFO.InstanceID left join INVOS_TECH ON INVOS_TECH.InstanceID=INVOS_INFO.InstanceID left join INVOS_SROK ON INVOS_SROK.InstanceID=INVOS_INFO.InstanceID 
;
GO

create or replace view V_AUTOINVOS_MOD as 
select   INVOS_MODID
, 
INVOS_MOD.DocNumber 
INVOS_MOD_DocNumber 
, 
INVOS_MOD.EndDate 
INVOS_MOD_EndDate 
, 
INVOS_MOD.INFO 
INVOS_MOD_INFO 
, 
INVOS_MOD.StartDate 
INVOS_MOD_StartDate 
, INVOS_MOD.InstanceID InstanceID 
, INVOS_MOD.INVOS_MODID ID 
, 'INVOS_MOD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_MOD
 join INSTANCE on INVOS_MOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_CMNT as 
select   INVOS_CMNTID
, 
INVOS_CMNT.ThePhoto 
INVOS_CMNT_ThePhoto 
, 
INVOS_CMNT.TheDate 
INVOS_CMNT_TheDate 
, 
 INVOS_CMNT.TheCommenter  
INVOS_CMNT_TheCommenter_ID, 
  Users_BRIEF_F(INVOS_CMNT.TheCommenter) 
INVOS_CMNT_TheCommenter 
, 
INVOS_CMNT.TheComment 
INVOS_CMNT_TheComment 
, 
INVOS_CMNT.Info 
INVOS_CMNT_Info 
, INVOS_CMNT.InstanceID InstanceID 
, INVOS_CMNT.INVOS_CMNTID ID 
, 'INVOS_CMNT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_CMNT
 join INSTANCE on INVOS_CMNT.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_CODE as 
select   INVOS_CODEID
, 
INVOS_CODE.ShCode 
INVOS_CODE_ShCode 
, 
 INVOS_CODE.CodePrinted  
INVOS_CODE_CodePrinted_VAL, 
 ( case INVOS_CODE.CodePrinted 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVOS_CODE_CodePrinted 
, 
INVOS_CODE.VisibleCode 
INVOS_CODE_VisibleCode 
, INVOS_CODE.InstanceID InstanceID 
, INVOS_CODE.INVOS_CODEID ID 
, 'INVOS_CODE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_CODE
 join INSTANCE on INVOS_CODE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_REPAIR as 
select   INVOS_REPAIRID
, 
INVOS_REPAIR.INFO 
INVOS_REPAIR_INFO 
, 
INVOS_REPAIR.EndDate 
INVOS_REPAIR_EndDate 
, 
INVOS_REPAIR.StartDate 
INVOS_REPAIR_StartDate 
, INVOS_REPAIR.InstanceID InstanceID 
, INVOS_REPAIR.INVOS_REPAIRID ID 
, 'INVOS_REPAIR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_REPAIR
 join INSTANCE on INVOS_REPAIR.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVOS_PLACE as 
select   INVOS_PLACEID
, 
 INVOS_PLACE.DIrection  
INVOS_PLACE_DIrection_ID, 
  INVD_DIR_BRIEF_F(INVOS_PLACE.DIrection) 
INVOS_PLACE_DIrection 
, 
 INVOS_PLACE.Uprav  
INVOS_PLACE_Uprav_ID, 
  INVD_UPR_BRIEF_F(INVOS_PLACE.Uprav) 
INVOS_PLACE_Uprav 
, 
 INVOS_PLACE.TheOwner  
INVOS_PLACE_TheOwner_ID, 
  INVD_OWNER_BRIEF_F(INVOS_PLACE.TheOwner) 
INVOS_PLACE_TheOwner 
, 
INVOS_PLACE.Info 
INVOS_PLACE_Info 
, 
INVOS_PLACE.Room 
INVOS_PLACE_Room 
, 
INVOS_PLACE.ComplNumber 
INVOS_PLACE_ComplNumber 
, 
INVOS_PLACE.Flow 
INVOS_PLACE_Flow 
, 
 INVOS_PLACE.TheHouse  
INVOS_PLACE_TheHouse_ID, 
  INVD_BLD_BRIEF_F(INVOS_PLACE.TheHouse) 
INVOS_PLACE_TheHouse 
, 
INVOS_PLACE.WorkPlaceNum 
INVOS_PLACE_WorkPlaceNum 
, 
 INVOS_PLACE.Otdel  
INVOS_PLACE_Otdel_ID, 
  INVD_OTDEL_BRIEF_F(INVOS_PLACE.Otdel) 
INVOS_PLACE_Otdel 
, INVOS_PLACE.InstanceID InstanceID 
, INVOS_PLACE.INVOS_PLACEID ID 
, 'INVOS_PLACE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVOS_PLACE
 join INSTANCE on INVOS_PLACE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindReports as 
select   ReportsID
, 
Reports.Name 
Reports_Name 
, Reports.InstanceID InstanceID 
, Reports.ReportsID ID 
, 'Reports' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Reports
 join INSTANCE on Reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindUsers as 
select   UsersID
, 
Users.LocalPhone 
Users_LocalPhone 
, 
Users.Family 
Users_Family 
, 
Users.SurName 
Users_SurName 
, 
Users.MobilePhone 
Users_MobilePhone 
, 
Users.EMail 
Users_EMail 
, 
Users.Phone 
Users_Phone 
, 
Users.Name 
Users_Name 
, Users.InstanceID InstanceID 
, Users.UsersID ID 
, 'Users' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOUsers as 
select   UsersID
, 
Users.Login 
Users_Login 
, 
Users.Name 
Users_Name 
, 
Users.Phone 
Users_Phone 
, 
Users.EMail 
Users_EMail 
, 
 Users.PersonaData  
Users_PersonaData_ID, 
  INSTANCE_BRIEF_F(Users.PersonaData) 
Users_PersonaData 
, 
Users.PositionU 
Users_PositionU 
, 
Users.Family 
Users_Family 
, 
 Users.ClientDef  
Users_ClientDef_ID, 
  INSTANCE_BRIEF_F(Users.ClientDef) 
Users_ClientDef 
, 
Users.CertData 
Users_CertData 
, 
Users.CertificateID 
Users_CertificateID 
, 
Users.WorkPlace 
Users_WorkPlace 
, 
Users.SurName 
Users_SurName 
, 
Users.MobilePhone 
Users_MobilePhone 
, 
Users.BirthDay 
Users_BirthDay 
, 
Users.Password 
Users_Password 
, 
Users.LocalPhone 
Users_LocalPhone 
, 
Users.Photo 
Users_Photo 
, 
Users.DomaiName 
Users_DomaiName 
, 
 Users.Activity  
Users_Activity_ID, 
  INSTANCE_BRIEF_F(Users.Activity) 
Users_Activity 
, Users.InstanceID InstanceID 
, Users.UsersID ID 
, 'Users' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOGroups as 
select   GroupsID
, 
Groups.Name 
Groups_Name 
, Groups.InstanceID InstanceID 
, Groups.GroupsID ID 
, 'Groups' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_FindGroups as 
select   GroupsID
, 
Groups.Name 
Groups_Name 
, Groups.InstanceID InstanceID 
, Groups.GroupsID ID 
, 'Groups' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZUsers_GroupUser as 
select   GroupUserID,GroupsID
, 
 GroupUser.TheUser  
GroupUser_TheUser_ID, 
  Users_BRIEF_F(GroupUser.TheUser) 
GroupUser_TheUser 
, 
Groups.Name 
Groups_Name 
, Groups.InstanceID InstanceID 
, GroupUser.GroupUserID ID 
, 'GroupUser' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOGroupUser as 
select   GroupUserID,GroupsID
, 
 GroupUser.TheUser  
GroupUser_TheUser_ID, 
  Users_BRIEF_F(GroupUser.TheUser) 
GroupUser_TheUser 
, Groups.InstanceID InstanceID 
, GroupUser.GroupUserID ID 
, 'GroupUser' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_USER as 
select   ROLES_USERID
, 
 ROLES_USER.TheUser  
ROLES_USER_TheUser_ID, 
  Users_BRIEF_F(ROLES_USER.TheUser) 
ROLES_USER_TheUser 
, ROLES_USER.InstanceID InstanceID 
, ROLES_USER.ROLES_USERID ID 
, 'ROLES_USER' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_USER
 join INSTANCE on ROLES_USER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_MAP as 
select   ROLES_MAPID
, 
 ROLES_MAP.TheGroup  
ROLES_MAP_TheGroup_ID, 
  Groups_BRIEF_F(ROLES_MAP.TheGroup) 
ROLES_MAP_TheGroup 
, ROLES_MAP.InstanceID InstanceID 
, ROLES_MAP.ROLES_MAPID ID 
, 'ROLES_MAP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_MAP
 join INSTANCE on ROLES_MAP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_DOC as 
select   ROLES_DOCID
, 
 ROLES_DOC.The_Document  
ROLES_DOC_The_Document_ID, 
  OBJECTTYPE_BRIEF_F(ROLES_DOC.The_Document) 
ROLES_DOC_The_Document 
, 
 ROLES_DOC.AllowDeleteDoc  
ROLES_DOC_AllowDeleteDoc_VAL, 
 ( case ROLES_DOC.AllowDeleteDoc 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DOC_AllowDeleteDoc 
, 
 ROLES_DOC.The_Denied  
ROLES_DOC_The_Denied_VAL, 
 ( case ROLES_DOC.The_Denied 
 when 1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DOC_The_Denied 
, ROLES_DOC.InstanceID InstanceID 
, ROLES_DOC.ROLES_DOCID ID 
, 'ROLES_DOC' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_DOC
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_DOC_STATE as 
select   ROLES_DOC_STATEID,ROLES_DOCID
, 
 ROLES_DOC_STATE.The_Mode  
ROLES_DOC_STATE_The_Mode_ID, 
  OBJECTMODE_BRIEF_F(ROLES_DOC_STATE.The_Mode) 
ROLES_DOC_STATE_The_Mode 
, 
 ROLES_DOC_STATE.StateChangeDisabled  
ROLES_DOC_STATE_StateChangeDisabled_VAL, 
 ( case ROLES_DOC_STATE.StateChangeDisabled 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DOC_STATE_StateChangeDisabled 
, 
 ROLES_DOC_STATE.AllowDelete  
ROLES_DOC_STATE_AllowDelete_VAL, 
 ( case ROLES_DOC_STATE.AllowDelete 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DOC_STATE_AllowDelete 
, 
 ROLES_DOC_STATE.The_State  
ROLES_DOC_STATE_The_State_ID, 
  OBJSTATUS_BRIEF_F(ROLES_DOC_STATE.The_State) 
ROLES_DOC_STATE_The_State 
, ROLES_DOC.InstanceID InstanceID 
, ROLES_DOC_STATE.ROLES_DOC_STATEID ID 
, 'ROLES_DOC_STATE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_DOC_STATE
 join ROLES_DOC on ROLES_DOC.ROLES_DOCID=ROLES_DOC_STATE.ParentStructRowID 
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_DEF as 
select   ROLES_DEFID
, 
 ROLES_DEF.ListCFG_Denied  
ROLES_DEF_ListCFG_Denied_VAL, 
 ( case ROLES_DEF.ListCFG_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_ListCFG_Denied 
, 
ROLES_DEF.TheComment 
ROLES_DEF_TheComment 
, 
 ROLES_DEF.FormCFG_Denied  
ROLES_DEF_FormCFG_Denied_VAL, 
 ( case ROLES_DEF.FormCFG_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_FormCFG_Denied 
, 
 ROLES_DEF.FileExch_Denied  
ROLES_DEF_FileExch_Denied_VAL, 
 ( case ROLES_DEF.FileExch_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_FileExch_Denied 
, 
 ROLES_DEF.RightsSet_Denied  
ROLES_DEF_RightsSet_Denied_VAL, 
 ( case ROLES_DEF.RightsSet_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_RightsSet_Denied 
, 
ROLES_DEF.name 
ROLES_DEF_name 
, ROLES_DEF.InstanceID InstanceID 
, ROLES_DEF.ROLES_DEFID ID 
, 'ROLES_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewROLES_ROLES_DEF as 
select   ROLES_DEFID
, 
ROLES_DEF.name 
ROLES_DEF_name 
, 
 ROLES_DEF.RightsSet_Denied  
ROLES_DEF_RightsSet_Denied_VAL, 
 ( case ROLES_DEF.RightsSet_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_RightsSet_Denied 
, 
ROLES_DEF.TheComment 
ROLES_DEF_TheComment 
, 
 ROLES_DEF.FileExch_Denied  
ROLES_DEF_FileExch_Denied_VAL, 
 ( case ROLES_DEF.FileExch_Denied 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_DEF_FileExch_Denied 
, ROLES_DEF.InstanceID InstanceID 
, ROLES_DEF.ROLES_DEFID ID 
, 'ROLES_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_REPORTS as 
select   ROLES_REPORTSID
, 
 ROLES_REPORTS.The_Report  
ROLES_REPORTS_The_Report_ID, 
  INSTANCE_BRIEF_F(ROLES_REPORTS.The_Report) 
ROLES_REPORTS_The_Report 
, ROLES_REPORTS.InstanceID InstanceID 
, ROLES_REPORTS.ROLES_REPORTSID ID 
, 'ROLES_REPORTS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_REPORTS
 join INSTANCE on ROLES_REPORTS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_WP as 
select   ROLES_WPID
, 
 ROLES_WP.WP  
ROLES_WP_WP_ID, 
  INSTANCE_BRIEF_F(ROLES_WP.WP) 
ROLES_WP_WP 
, ROLES_WP.InstanceID InstanceID 
, ROLES_WP.ROLES_WPID ID 
, 'ROLES_WP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_WP
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOROLES_ACT as 
select   ROLES_ACTID,ROLES_WPID
, 
 ROLES_ACT.Accesible  
ROLES_ACT_Accesible_VAL, 
 ( case ROLES_ACT.Accesible 
 when 1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
ROLES_ACT_Accesible 
, 
 ROLES_ACT.EntryPoints  
ROLES_ACT_EntryPoints_ID, 
  EntryPoints_BRIEF_F(ROLES_ACT.EntryPoints) 
ROLES_ACT_EntryPoints 
, ROLES_WP.InstanceID InstanceID 
, ROLES_ACT.ROLES_ACTID ID 
, 'ROLES_ACT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from ROLES_ACT
 join ROLES_WP on ROLES_WP.ROLES_WPID=ROLES_ACT.ParentStructRowID 
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZwp_WorkPlace as 
select   WorkPlaceID
, 
 WorkPlace.ThePlatform  
WorkPlace_ThePlatform_VAL, 
 ( case WorkPlace.ThePlatform 
 when 2 then 'JAVA'
 when 3 then 'OTHER'
 when 1 then 'DOTNET'
 when 0 then 'VB6'
 else '???' end) 
WorkPlace_ThePlatform 
, 
WorkPlace.Name 
WorkPlace_Name 
, 
WorkPlace.TheVersion 
WorkPlace_TheVersion 
, WorkPlace.InstanceID InstanceID 
, WorkPlace.WorkPlaceID ID 
, 'WorkPlace' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from WorkPlace
 join INSTANCE on WorkPlace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_UPR as 
select   INVD_UPRID
, 
INVD_UPR.Code 
INVD_UPR_Code 
, 
INVD_UPR.Name 
INVD_UPR_Name 
, INVD_UPR.InstanceID InstanceID 
, INVD_UPR.INVD_UPRID ID 
, 'INVD_UPR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_UPR
 join INSTANCE on INVD_UPR.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_OTDEL as 
select   INVD_OTDELID
, 
INVD_OTDEL.Name 
INVD_OTDEL_Name 
, 
INVD_OTDEL.Code 
INVD_OTDEL_Code 
, INVD_OTDEL.InstanceID InstanceID 
, INVD_OTDEL.INVD_OTDELID ID 
, 'INVD_OTDEL' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_OTDEL
 join INSTANCE on INVD_OTDEL.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_BLD as 
select   INVD_BLDID
, 
INVD_BLD.Addr 
INVD_BLD_Addr 
, 
INVD_BLD.Name 
INVD_BLD_Name 
, INVD_BLD.InstanceID InstanceID 
, INVD_BLD.INVD_BLDID ID 
, 'INVD_BLD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_BLD
 join INSTANCE on INVD_BLD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_DRAG as 
select   INVD_DRAGID
, 
INVD_DRAG.Name 
INVD_DRAG_Name 
, 
INVD_DRAG.edIzm 
INVD_DRAG_edIzm 
, INVD_DRAG.InstanceID InstanceID 
, INVD_DRAG.INVD_DRAGID ID 
, 'INVD_DRAG' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_DRAG
 join INSTANCE on INVD_DRAG.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_ORG as 
select   INVD_ORGID
, 
INVD_ORG.INN 
INVD_ORG_INN 
, 
INVD_ORG.SortName 
INVD_ORG_SortName 
, 
INVD_ORG.KPP 
INVD_ORG_KPP 
, 
INVD_ORG.FaktAddr 
INVD_ORG_FaktAddr 
, 
INVD_ORG.Phone 
INVD_ORG_Phone 
, 
INVD_ORG.UrAddr 
INVD_ORG_UrAddr 
, 
INVD_ORG.FullName 
INVD_ORG_FullName 
, INVD_ORG.InstanceID InstanceID 
, INVD_ORG.INVD_ORGID ID 
, 'INVD_ORG' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_ORG
 join INSTANCE on INVD_ORG.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_OSSTATUS as 
select   INVD_OSSTATUSID
, 
INVD_OSSTATUS.Name 
INVD_OSSTATUS_Name 
, 
INVD_OSSTATUS.Code 
INVD_OSSTATUS_Code 
, INVD_OSSTATUS.InstanceID InstanceID 
, INVD_OSSTATUS.INVD_OSSTATUSID ID 
, 'INVD_OSSTATUS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_OSSTATUS
 join INSTANCE on INVD_OSSTATUS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_OWNER as 
select   INVD_OWNERID
, 
INVD_OWNER.SurName 
INVD_OWNER_SurName 
, 
INVD_OWNER.Name 
INVD_OWNER_Name 
, 
INVD_OWNER.FamiliName 
INVD_OWNER_FamiliName 
, INVD_OWNER.InstanceID InstanceID 
, INVD_OWNER.INVD_OWNERID ID 
, 'INVD_OWNER' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_OWNER
 join INSTANCE on INVD_OWNER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_UR as 
select   INVD_URID
, 
INVD_UR.Phone 
INVD_UR_Phone 
, 
INVD_UR.FullName 
INVD_UR_FullName 
, 
INVD_UR.UrAddr 
INVD_UR_UrAddr 
, 
INVD_UR.KPP 
INVD_UR_KPP 
, 
INVD_UR.FaktAddr 
INVD_UR_FaktAddr 
, 
INVD_UR.INN 
INVD_UR_INN 
, 
INVD_UR.SortName 
INVD_UR_SortName 
, INVD_UR.InstanceID InstanceID 
, INVD_UR.INVD_URID ID 
, 'INVD_UR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_UR
 join INSTANCE on INVD_UR.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_OSTYPE as 
select   INVD_OSTYPEID
, 
 INVD_OSTYPE.ShowTech  
INVD_OSTYPE_ShowTech_VAL, 
 ( case INVD_OSTYPE.ShowTech 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVD_OSTYPE_ShowTech 
, 
INVD_OSTYPE.Code 
INVD_OSTYPE_Code 
, 
INVD_OSTYPE.Name 
INVD_OSTYPE_Name 
, INVD_OSTYPE.InstanceID InstanceID 
, INVD_OSTYPE.INVD_OSTYPEID ID 
, 'INVD_OSTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_OSTYPE
 join INSTANCE on INVD_OSTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewINV_DIC_INVD_OSTYPE as 
select   INVD_OSTYPEID
, 
INVD_OSTYPE.Name 
INVD_OSTYPE_Name 
, 
INVD_OSTYPE.Code 
INVD_OSTYPE_Code 
, 
 INVD_OSTYPE.ShowTech  
INVD_OSTYPE_ShowTech_VAL, 
 ( case INVD_OSTYPE.ShowTech 
 when -1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
INVD_OSTYPE_ShowTech 
, INVD_OSTYPE.InstanceID InstanceID 
, INVD_OSTYPE.INVD_OSTYPEID ID 
, 'INVD_OSTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_OSTYPE
 join INSTANCE on INVD_OSTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVD_DIR as 
select   INVD_DIRID
, 
INVD_DIR.Name 
INVD_DIR_Name 
, 
INVD_DIR.Code 
INVD_DIR_Code 
, INVD_DIR.InstanceID InstanceID 
, INVD_DIR.INVD_DIRID ID 
, 'INVD_DIR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVD_DIR
 join INSTANCE on INVD_DIR.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZ_Install_MTZ_Inst_Build as 
select   MTZ_Inst_BuildID
, 
MTZ_Inst_Build.LicensFilePath 
MTZ_Inst_Build_LicensFilePath 
, 
MTZ_Inst_Build.PRODUCT_NAME 
MTZ_Inst_Build_PRODUCT_NAME 
, 
MTZ_Inst_Build.InstallDir 
MTZ_Inst_Build_InstallDir 
, 
MTZ_Inst_Build.PRODUCT_VERSION 
MTZ_Inst_Build_PRODUCT_VERSION 
, 
MTZ_Inst_Build.PRODUCT_PUBLISHER 
MTZ_Inst_Build_PRODUCT_PUBLISHER 
, 
MTZ_Inst_Build.PRODUCT_WEB_SITE 
MTZ_Inst_Build_PRODUCT_WEB_SITE 
, 
 MTZ_Inst_Build.MainFileRef  
MTZ_Inst_Build_MainFileRef_ID, 
  MTZ_Inst_Sec_Files_BRIEF_F(MTZ_Inst_Build.MainFileRef) 
MTZ_Inst_Build_MainFileRef 
, 
MTZ_Inst_Build.ShortCutDir 
MTZ_Inst_Build_ShortCutDir 
, MTZ_Inst_Build.InstanceID InstanceID 
, MTZ_Inst_Build.MTZ_Inst_BuildID ID 
, 'MTZ_Inst_Build' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from MTZ_Inst_Build
 join INSTANCE on MTZ_Inst_Build.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZ_Install_MTZ_Inst_Common as 
select   MTZ_Inst_CommonID
, 
 MTZ_Inst_Common.IsDeinstallUSE  
MTZ_Inst_Common_IsDeinstallUSE_VAL, 
 ( case MTZ_Inst_Common.IsDeinstallUSE 
 when 1 then 'Да'
 when 0 then 'Нет'
 else '???' end) 
MTZ_Inst_Common_IsDeinstallUSE 
, 
MTZ_Inst_Common.TheName 
MTZ_Inst_Common_TheName 
, MTZ_Inst_Common.InstanceID InstanceID 
, MTZ_Inst_Common.MTZ_Inst_CommonID ID 
, 'MTZ_Inst_Common' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from MTZ_Inst_Common
 join INSTANCE on MTZ_Inst_Common.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOInfoStoreDef as 
select   InfoStoreDefID
, 
 InfoStoreDef.InfoStoreType  
InfoStoreDef_InfoStoreType_VAL, 
 ( case InfoStoreDef.InfoStoreType 
 when 2 then 'Групповой'
 when 1 then 'Персональный'
 when 0 then ' Общий'
 else '???' end) 
InfoStoreDef_InfoStoreType 
, 
 InfoStoreDef.TheGroup  
InfoStoreDef_TheGroup_ID, 
  Groups_BRIEF_F(InfoStoreDef.TheGroup) 
InfoStoreDef_TheGroup 
, 
InfoStoreDef.Name 
InfoStoreDef_Name 
, 
 InfoStoreDef.TheUser  
InfoStoreDef_TheUser_ID, 
  Users_BRIEF_F(InfoStoreDef.TheUser) 
InfoStoreDef_TheUser 
, InfoStoreDef.InstanceID InstanceID 
, InfoStoreDef.InfoStoreDefID ID 
, 'InfoStoreDef' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from InfoStoreDef
 join INSTANCE on InfoStoreDef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOFolder as 
select   FolderID
, 
 Folder.FolderType  
Folder_FolderType_VAL, 
 ( case Folder.FolderType 
 when 2 then 'Исходящие'
 when 10 then 'Завершенные'
 when 0 then 'cls__'
 when 5 then 'Календарь'
 when 1 then 'Входящие'
 when 9 then 'Отложенные'
 when 4 then 'Журнал'
 when 8 then 'В работе'
 when 7 then 'Черновики'
 when 6 then 'Отправленные'
 when 3 then 'Удаленные'
 else '???' end) 
Folder_FolderType 
, 
Folder.Name 
Folder_Name 
, Folder.InstanceID InstanceID 
, Folder.FolderID ID 
, 'Folder' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewSTDInfoStore_Folder as 
select   FolderID
, 
 InfoStoreDef.TheUser  
InfoStoreDef_TheUser_ID, 
  Users_BRIEF_F(InfoStoreDef.TheUser) 
InfoStoreDef_TheUser 
, 
 InfoStoreDef.TheGroup  
InfoStoreDef_TheGroup_ID, 
  Groups_BRIEF_F(InfoStoreDef.TheGroup) 
InfoStoreDef_TheGroup 
, 
 InfoStoreDef.InfoStoreType  
InfoStoreDef_InfoStoreType_VAL, 
 ( case InfoStoreDef.InfoStoreType 
 when 2 then 'Групповой'
 when 1 then 'Персональный'
 when 0 then ' Общий'
 else '???' end) 
InfoStoreDef_InfoStoreType 
, 
InfoStoreDef.Name 
InfoStoreDef_Name 
, 
Folder.Name 
Folder_Name 
, 
 Folder.FolderType  
Folder_FolderType_VAL, 
 ( case Folder.FolderType 
 when 2 then 'Исходящие'
 when 10 then 'Завершенные'
 when 0 then 'cls__'
 when 5 then 'Календарь'
 when 1 then 'Входящие'
 when 9 then 'Отложенные'
 when 4 then 'Журнал'
 when 8 then 'В работе'
 when 7 then 'Черновики'
 when 6 then 'Отправленные'
 when 3 then 'Удаленные'
 else '???' end) 
Folder_FolderType 
, Folder.InstanceID InstanceID 
, Folder.FolderID ID 
, 'Folder' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid left join InfoStoreDef ON InfoStoreDef.InstanceID=Folder.InstanceID 
;
GO

create or replace view V_AUTOShortcut as 
select   ShortcutID,FolderID
, 
 Shortcut.DocItem  
Shortcut_DocItem_ID, 
  INSTANCE_BRIEF_F(Shortcut.DocItem) 
Shortcut_DocItem 
, 
Shortcut.StartMode 
Shortcut_StartMode 
, Folder.InstanceID InstanceID 
, Shortcut.ShortcutID ID 
, 'Shortcut' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from Shortcut
 join Folder on Folder.FolderID=Shortcut.ParentStructRowID 
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_viewMTZExt_MTZExt_def as 
select   MTZExt_defID
, 
MTZExt_def.TheDescription 
MTZExt_def_TheDescription 
, 
 MTZExt_def.ExtType  
MTZExt_def_ExtType_VAL, 
 ( case MTZExt_def.ExtType 
 when 1 then 'OnFormExt'
 when 7 then 'CodeGenerator'
 when 3 then 'JrnlAddExt'
 when 6 then 'VerifyRowExt'
 when 0 then 'StatusExt'
 when 8 then 'ARMGenerator'
 when 5 then 'DefaultExt'
 when 2 then 'CustomExt'
 when 4 then 'JrnlRunExt'
 else '???' end) 
MTZExt_def_ExtType 
, 
MTZExt_def.Name 
MTZExt_def_Name 
, MTZExt_def.InstanceID InstanceID 
, MTZExt_def.MTZExt_defID ID 
, 'MTZExt_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from MTZExt_def
 join INSTANCE on MTZExt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

create or replace view V_AUTOINVN_DEF as 
select   INVN_DEFID
, 
 INVN_DEF.TheOrg  
INVN_DEF_TheOrg_ID, 
  INVD_ORG_BRIEF_F(INVN_DEF.TheOrg) 
INVN_DEF_TheOrg 
, 
INVN_DEF.TheNumber 
INVN_DEF_TheNumber 
, 
INVN_DEF.TheOSNumber 
INVN_DEF_TheOSNumber 
, INVN_DEF.InstanceID InstanceID 
, INVN_DEF.INVN_DEFID ID 
, 'INVN_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID
  from INVN_DEF
 join INSTANCE on INVN_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
;
GO

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--functions.Type.Header" File=""><BlockHolder BlockName="--body" BlockCode=" 

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZ2JOB" BlockCode=" create or replace function  MTZ2JOB_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_BRIEF  (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_DELETE  (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ2JOB_DEF_SAVE (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid,
ainstanceid uuid 
,aEventDate
 timestamp/* Отложено до *//* Отложено до */
,aEvenType
 VARCHAR/* Тип события *//* Тип события */
,aThruObject
 uuid/* Объект - причина события *//* Объект - причина события */
,aThruState
 uuid/* Состояние - причина *//* Состояние - причина */
,aNextState
 uuid/* Состояние после обработки *//* Состояние после обработки */
,aProcessDate
 timestamp/* Момент обработки *//* Момент обработки */
,aProcessed
 INTEGER/* Обработан *//* Обработан */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ2JOB_DEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ2JOB_DEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZFltr" BlockCode=" create or replace function  MTZFltr_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZFltr_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZFltr_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_BRIEF  (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_DELETE  (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FilterFieldGroup_SAVE (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid,
ainstanceid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aAllowIgnore
 INTEGER/* Можно отключать *//* Можно отключать */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FilterFieldGroup_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FilterFieldGroup_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FileterField_BRIEF  (
 aCURSESSION uuid,
 aFileterFieldid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_DELETE  (
 aCURSESSION uuid,
 aFileterFieldid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FileterField_SAVE (
 aCURSESSION uuid,
 aFileterFieldid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aFieldSize
 integer/* Размер *//* Размер */
,aRefType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,aRefToPart
 uuid/* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,aValueArray
 INTEGER/* Массив значений *//* Массив значений */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FileterField_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FileterField_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Filters_BRIEF  (
 aCURSESSION uuid,
 aFiltersid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_DELETE  (
 aCURSESSION uuid,
 aFiltersid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Filters_SAVE (
 aCURSESSION uuid,
 aFiltersid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Filters_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Filters_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Filters_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSrvMsg" BlockCode=" create or replace function  MTZSrvMsg_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSrvMsg_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSrvMsg_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_BRIEF  (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_DELETE  (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SrvMessageInfo_SAVE (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid,
ainstanceid uuid 
,aForUser
 uuid/* Для пользователя *//* Для пользователя */
,amsgDate
 timestamp/* Дата *//* Дата */
,aMsgInfo
 TEXT/* Текст сообщения *//* Текст сообщения */
,aTheDocument
 uuid/* Документ *//* Документ */
,aReadTime
 timestamp/* Время прочтения *//* Время прочтения */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SrvMessageInfo_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  SrvMessageInfo_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZJrnl" BlockCode=" create or replace function  MTZJrnl_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZJrnl_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZJrnl_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_BRIEF  (
 aCURSESSION uuid,
 aJournalColumnid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_DELETE  (
 aCURSESSION uuid,
 aJournalColumnid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JournalColumn_SAVE (
 aCURSESSION uuid,
 aJournalColumnid uuid,
ainstanceid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aname
 VARCHAR/* Название *//* Название */
,aColumnAlignment
 integer/* Выравнивание *//* Выравнивание */
,aColSort
 INTEGER/* Сортировка колонки *//* Сортировка колонки */
,aGroupAggregation
 INTEGER/* Аггрегация при группировке *//* Аггрегация при группировке */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JournalColumn_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  JournalColumn_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_BRIEF  (
 aCURSESSION uuid,
 aJColumnSourceid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_DELETE  (
 aCURSESSION uuid,
 aJColumnSourceid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JColumnSource_SAVE (
 aCURSESSION uuid,
 aJColumnSourceid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aSrcPartView
 uuid/* Представление *//* Представление */
,aViewField
 VARCHAR/* Поле представления *//* Поле представления */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JColumnSource_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  JColumnSource_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Journal_BRIEF  (
 aCURSESSION uuid,
 aJournalid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_DELETE  (
 aCURSESSION uuid,
 aJournalid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Journal_SAVE (
 aCURSESSION uuid,
 aJournalid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Journal_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Journal_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Journal_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_BRIEF  (
 aCURSESSION uuid,
 aJournalSrcid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_DELETE  (
 aCURSESSION uuid,
 aJournalSrcid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JournalSrc_SAVE (
 aCURSESSION uuid,
 aJournalSrcid uuid,
ainstanceid uuid 
,aPartView
 uuid/* Представление *//* Представление */
,aOnRun
 INTEGER/* При открытии *//* При открытии */
,aOpenMode
 VARCHAR/* Режим открытия *//* Режим открытия */
,aViewAlias
 VARCHAR/* Псевдоним представления *//* Псевдоним представления */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  JournalSrc_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  JournalSrc_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZStateSrv" BlockCode=" create or replace function  MTZStateSrv_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZStateSrv_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZStateSrv_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  StateAction_BRIEF  (
 aCURSESSION uuid,
 aStateActionid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_DELETE  (
 aCURSESSION uuid,
 aStateActionid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  StateAction_SAVE (
 aCURSESSION uuid,
 aStateActionid uuid,
ainstanceid uuid 
,aOnDocStatus
 uuid/* При входе в состояие *//* При входе в состояие */
,aNewSecurityStyle
 uuid/* Установить стиль защиты *//* Установить стиль защиты */
,aClearSecurity
 INTEGER/* Сбросить стиль защиты *//* Сбросить стиль защиты */
,aLibraryFile
 VARCHAR/* Библиотека-обработчик *//* Библиотека-обработчик */
,aActionClass
 VARCHAR/* Класс для обработки *//* Класс для обработки */
,aActionScript
 TEXT/* Скрипт для исполнения *//* Скрипт для исполнения */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  StateAction_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  StateAction_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--REPD" BlockCode=" create or replace function  REPD_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_BRIEF  (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_DELETE  (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_LOCKED_SAVE (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid,
ainstanceid uuid 
,aLastTry
 timestamp/* Последняя разработка *//* Последняя разработка */
,aSourceFile
 VARCHAR/* Файл данных *//* Файл данных */
,aReplicaRowID
 uuid/* Идентификатор строки реплики *//* Идентификатор строки реплики */
,aFirstTry
 timestamp/* Первая обработка *//* Первая обработка */
,aStructType
 VARCHAR/* Тип строки *//* Тип строки */
,aObjectType
 VARCHAR/* Тип объекта *//* Тип объекта */
,aThe_RowID
 uuid/* Идетнификатор строки *//* Идетнификатор строки */
,aThe_InstanceID
 uuid/* Объект *//* Объект */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aPartCount
 integer/* PartCount *//* PartCount */
,aPartNumber
 integer/* PartNumber *//* PartNumber */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_LOCKED_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_LOCKED_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_BRIEF  (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_DELETE  (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_RequestQuery_SAVE (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid,
ainstanceid uuid 
,aTheRowID
 uuid/* TheRowID *//* TheRowID */
,aReqPartName
 VARCHAR/* ReqPartName *//* ReqPartName */
,aObjectID
 uuid/* ObjectID *//* ObjectID */
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aSendRecord
 uuid/* SendRecord *//* SendRecord */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aProvider
 uuid/* Provider *//* Provider */
,aReqTypeName
 VARCHAR/* ReqTypeName *//* ReqTypeName */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_RequestQuery_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_RequestQuery_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_BRIEF  (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_DELETE  (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_ResQueryRcv_SAVE (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aReceiveRec
 uuid/* ReceiveRec *//* ReceiveRec */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_ResQueryRcv_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_ResQueryRcv_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_BRIEF  (
 aCURSESSION uuid,
 aREPD_PROVid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_DELETE  (
 aCURSESSION uuid,
 aREPD_PROVid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_PROV_SAVE (
 aCURSESSION uuid,
 aREPD_PROVid uuid,
ainstanceid uuid 
,aAssemblyName
 VARCHAR/* AssemblyName *//* AssemblyName */
,aClassName
 VARCHAR/* ClassName *//* ClassName */
,aName
 VARCHAR/* Name *//* Name */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_PROV_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_PROV_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_BRIEF  (
 aCURSESSION uuid,
 aREPD_SRVid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_DELETE  (
 aCURSESSION uuid,
 aREPD_SRVid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SRV_SAVE (
 aCURSESSION uuid,
 aREPD_SRVid uuid,
ainstanceid uuid 
,aObj3
 uuid/* Obj3 *//* Obj3 */
,aname
 VARCHAR/* Название *//* Название */
,aObj2
 uuid/* Obj2 *//* Obj2 */
,aObj1
 uuid/* Obj1 *//* Obj1 */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SRV_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_SRV_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_BRIEF  (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_DELETE  (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SNDTO_SAVE (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aLastScan
 timestamp/* Last scan *//* Last scan */
,aConfig
 TEXT/* Config *//* Config */
,aLastReceive
 timestamp/* Last Receive *//* Last Receive */
,aProvider
 uuid/* Provider *//* Provider */
,aWork_Start
 time/* Начало работы (время) *//* Начало работы (время) */
,aWork_End
 time/* Окончание работы (время) *//* Окончание работы (время) */
,aThe_Interval
 integer/* Интервал *//* Интервал */
,aIsActive
 INTEGER/* Активен *//* Активен */
,aLastApproveLog
 timestamp/* Последнее подтверждение (лог) *//* Последнее подтверждение (лог) */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SNDTO_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_SNDTO_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_BRIEF  (
 aCURSESSION uuid,
 aREPD_CONSTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_DELETE  (
 aCURSESSION uuid,
 aREPD_CONSTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_CONST_SAVE (
 aCURSESSION uuid,
 aREPD_CONSTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheValue
 VARCHAR/* Значение *//* Значение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_CONST_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_CONST_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_BRIEF  (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_DELETE  (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_REPTYPE_SAVE (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aReplicaType
 INTEGER/* Тип репликации *//* Тип репликации */
,aTheObjectType
 uuid/* Тип объекта *//* Тип объекта */
,aUseFilter
 INTEGER/* Фильтровать по условию *//* Фильтровать по условию */
,aRepConditonQRY
 TEXT/* Условие репликации *//* Условие репликации */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_REPTYPE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_REPTYPE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_BRIEF  (
 aCURSESSION uuid,
 aREPD_SendQid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_DELETE  (
 aCURSESSION uuid,
 aREPD_SendQid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SendQ_SAVE (
 aCURSESSION uuid,
 aREPD_SendQid uuid,
ainstanceid uuid 
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aConfig
 TEXT/* Config *//* Config */
,aSentDate
 timestamp/* SentDate *//* SentDate */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aProvider
 uuid/* Provider *//* Provider */
,aAcknowelge
 INTEGER/* Acknowelge *//* Acknowelge */
,aSendSize
 integer/* SendSize *//* SendSize */
,aCheckDate
 timestamp/* CheckDate *//* CheckDate */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aFileName
 VARCHAR/* FileName *//* FileName */
,aPartCount
 integer/* Количество частей *//* Количество частей */
,aPartNumber
 integer/* Часть *//* Часть */
,aSent
 integer/* Sent *//* Sent */
,aReplicatorPointer
 timestamp/* Указатель репликации *//* Указатель репликации */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_SendQ_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_SendQ_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_BRIEF  (
 aCURSESSION uuid,
 aREPD_RecvQid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_DELETE  (
 aCURSESSION uuid,
 aREPD_RecvQid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_RecvQ_SAVE (
 aCURSESSION uuid,
 aREPD_RecvQid uuid,
ainstanceid uuid 
,aTheRowID
 uuid/* TheRowID *//* TheRowID */
,aReceived
 timestamp/* Received *//* Received */
,aProvider
 uuid/* Provider *//* Provider */
,aRecvSize
 integer/* RecvSize *//* RecvSize */
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aAcknowelge
 INTEGER/* Acknowelge *//* Acknowelge */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aPartCount
 integer/* Количество частей *//* Количество частей */
,aPartNumber
 integer/* Часть *//* Часть */
,aFileName
 VARCHAR/* FileName *//* FileName */
,aCompleted
 INTEGER/* Completed *//* Completed */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_RecvQ_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  REPD_RecvQ_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_INV" BlockCode=" create or replace function  INV_INV_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_INV_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_INV_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_BRIEF  (
 aCURSESSION uuid,
 ainvi_DEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_DELETE  (
 aCURSESSION uuid,
 ainvi_DEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  invi_DEF_SAVE (
 aCURSESSION uuid,
 ainvi_DEFid uuid,
ainstanceid uuid 
,aOrderNum
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала инвентаризации *//* Дата начала инвентаризации */
,aEndDate
 date/* Дата завершения инвентаризации *//* Дата завершения инвентаризации */
,aTheOrg
 uuid/* Юр. лицо *//* Юр. лицо */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprev
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aTheOwner
 uuid/* Владелец *//* Владелец */
,aBuilding
 uuid/* Здание *//* Здание */
,aTheFlow
 VARCHAR/* Этаж *//* Этаж */
,aTheRoom
 VARCHAR/* Комната *//* Комната */
,aTheWorkPlace
 VARCHAR/* Рабочее место *//* Рабочее место */
,aMatOtv
 uuid/* МОЛ *//* МОЛ */
,aInfo
 TEXT/* Примечания *//* Примечания */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  invi_DEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  invi_DEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_BRIEF  (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_DELETE  (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_PERSONS_SAVE (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid,
ainstanceid uuid 
,aThePosition
 VARCHAR/* Должность *//* Должность */
,aFamiliName
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_PERSONS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_PERSONS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_BRIEF  (
 aCURSESSION uuid,
 aINVI_BADid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_DELETE  (
 aCURSESSION uuid,
 aINVI_BADid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_BAD_SAVE (
 aCURSESSION uuid,
 aINVI_BADid uuid,
ainstanceid uuid 
,aSHCode
 VARCHAR/* Штрихкод *//* Штрихкод */
,aInfo
 TEXT/* Описание объекта *//* Описание объекта */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_BAD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_BAD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_BRIEF  (
 aCURSESSION uuid,
 aINVI_CHNGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_DELETE  (
 aCURSESSION uuid,
 aINVI_CHNGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_CHNG_SAVE (
 aCURSESSION uuid,
 aINVI_CHNGid uuid,
ainstanceid uuid 
,aSHCode
 VARCHAR/* Штрихкод *//* Штрихкод */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_CHNG_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_CHNG_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_BRIEF  (
 aCURSESSION uuid,
 aINVI_OBJid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_DELETE  (
 aCURSESSION uuid,
 aINVI_OBJid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_OBJ_SAVE (
 aCURSESSION uuid,
 aINVI_OBJid uuid,
ainstanceid uuid 
,aTheOS
 uuid/* Основное средство *//* Основное средство */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_OBJ_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_OBJ_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_BRIEF  (
 aCURSESSION uuid,
 aINVI_DONEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_DELETE  (
 aCURSESSION uuid,
 aINVI_DONEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_DONE_SAVE (
 aCURSESSION uuid,
 aINVI_DONEid uuid,
ainstanceid uuid 
,aCheckDate
 timestamp/* Дата проверки *//* Дата проверки */
,aTheOS
 uuid/* Основное средство *//* Основное средство */
,aOSStatus
 uuid/* Состояние *//* Состояние */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_DONE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_DONE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_BRIEF  (
 aCURSESSION uuid,
 aINVI_UNKid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_DELETE  (
 aCURSESSION uuid,
 aINVI_UNKid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_UNK_SAVE (
 aCURSESSION uuid,
 aINVI_UNKid uuid,
ainstanceid uuid 
,aTheRoom
 VARCHAR/* Помещение *//* Помещение */
,aInfo
 TEXT/* Описание объекта *//* Описание объекта */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVI_UNK_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVI_UNK_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDJournalExt" BlockCode=" create or replace function  STDJournalExt_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExt_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExt_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_BRIEF  (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_DELETE  (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournlaExtInfo_SAVE (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheJournalRef
 uuid/* Журнал *//* Журнал */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournlaExtInfo_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  STDJournlaExtInfo_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_DELETE  (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtParam_SAVE (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid,
ainstanceid uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtParam_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  STDJournalExtParam_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_DELETE  (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtFlt_SAVE (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid,
ainstanceid uuid 
,aViewSource
 VARCHAR/* Источник журнала *//* Источник журнала */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtFlt_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  STDJournalExtFlt_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_DELETE  (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtField_SAVE (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aViewField
 VARCHAR/* Колонка журнала *//* Колонка журнала */
,aFieldSource
 VARCHAR/* Поле *//* Поле */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aConstantValue
 VARCHAR/* Значение *//* Значение */
,aConditionType
 INTEGER/* Условие *//* Условие */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExtField_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  STDJournalExtField_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZMetaModel" BlockCode=" create or replace function  MTZMetaModel_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZMetaModel_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZMetaModel_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_BRIEF  (
 aCURSESSION uuid,
 aFIELDTYPEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_DELETE  (
 aCURSESSION uuid,
 aFIELDTYPEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDTYPE_SAVE (
 aCURSESSION uuid,
 aFIELDTYPEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTypeStyle
 INTEGER/* Трактовка *//* Трактовка */
,athe_Comment
 TEXT/* Описание *//* Описание */
,aAllowSize
 INTEGER/* Нужен размер *//* Нужен размер */
,aMinimum
 VARCHAR/* Минимум *//* Минимум */
,aMaximum
 VARCHAR/* Максимум *//* Максимум */
,aAllowLikeSearch
 INTEGER/* Поиск текста *//* Поиск текста */
,aGridSortType
 INTEGER/* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDTYPE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDTYPE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_BRIEF  (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_DELETE  (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDTYPEMAP_SAVE (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aStoageType
 VARCHAR/* Тип хранения *//* Тип хранения */
,aFixedSize
 integer/* Размер *//* Размер */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDTYPEMAP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDTYPEMAP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_BRIEF  (
 aCURSESSION uuid,
 aENUMITEMid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_DELETE  (
 aCURSESSION uuid,
 aENUMITEMid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ENUMITEM_SAVE (
 aCURSESSION uuid,
 aENUMITEMid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aNameValue
 integer/* Значение *//* Значение */
,aNameInCode
 VARCHAR/* Название в коде *//* Название в коде */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ENUMITEM_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ENUMITEM_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_BRIEF  (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_DELETE  (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SHAREDMETHOD_SAVE (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Comment
 TEXT/* Описание метода *//* Описание метода */
,aReturnType
 uuid/* Возвращаемый тип *//* Возвращаемый тип */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SHAREDMETHOD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  SHAREDMETHOD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_BRIEF  (
 aCURSESSION uuid,
 aSCRIPTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_DELETE  (
 aCURSESSION uuid,
 aSCRIPTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SCRIPT_SAVE (
 aCURSESSION uuid,
 aSCRIPTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SCRIPT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  SCRIPT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_BRIEF  (
 aCURSESSION uuid,
 aPARAMETERSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_DELETE  (
 aCURSESSION uuid,
 aPARAMETERSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARAMETERS_SAVE (
 aCURSESSION uuid,
 aPARAMETERSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Имя *//* Имя */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTypeOfParm
 uuid/* Тип данных *//* Тип данных */
,aDataSize
 integer/* Размер *//* Размер */
,aAllowNull
 INTEGER/* Можно не задавать *//* Можно не задавать */
,aOutParam
 INTEGER/* Возвращает значение *//* Возвращает значение */
,aReferenceType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Ссылка на тип *//* Ссылка на тип */
,aRefToPart
 uuid/* Ссылка на раздел *//* Ссылка на раздел */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARAMETERS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PARAMETERS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_BRIEF  (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_DELETE  (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJECTTYPE_SAVE (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid,
ainstanceid uuid 
,aPackage
 uuid/* Приложение *//* Приложение */
,athe_Comment
 VARCHAR/* Название *//* Название */
,aName
 VARCHAR/* Код *//* Код */
,aIsSingleInstance
 INTEGER/* Допускается только один объект *//* Допускается только один объект */
,aChooseView
 uuid/* Представление для выбора *//* Представление для выбора */
,aOnRun
 uuid/* При запуске *//* При запуске */
,aOnCreate
 uuid/* При создании *//* При создании */
,aOnDelete
 uuid/* При удалении *//* При удалении */
,aAllowRefToObject
 INTEGER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aAllowSearch
 INTEGER/* Отображать при поиске *//* Отображать при поиске */
,aReplicaType
 INTEGER/* Тип репликации *//* Тип репликации */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJECTTYPE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  OBJECTTYPE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PART_BRIEF  (
 aCURSESSION uuid,
 aPARTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_DELETE  (
 aCURSESSION uuid,
 aPARTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PART_SAVE (
 aCURSESSION uuid,
 aPARTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
, aParentRowid uuid 
,aSequence
 integer/* № п/п *//* № п/п */
,aPartType
 INTEGER/* Тип структры  *//* Тип структры  */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aName
 VARCHAR/* Название *//* Название */
,athe_Comment
 TEXT/* Описание *//* Описание */
,aNoLog
 INTEGER/* Не записывать в журнал *//* Не записывать в журнал */
,aManualRegister
 INTEGER/* Исключить из индексирования *//* Исключить из индексирования */
,aOnCreate
 uuid/* При создании *//* При создании */
,aOnSave
 uuid/* При сохранении *//* При сохранении */
,aOnRun
 uuid/* При открытии *//* При открытии */
,aOnDelete
 uuid/* При удалении *//* При удалении */
,aAddBehaivor
 INTEGER/* Поведение при добавлении *//* Поведение при добавлении */
,aExtenderObject
 uuid/* Объект расширения *//* Объект расширения */
,ashablonBrief
 VARCHAR/* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,aruleBrief
 VARCHAR/* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aIsJormalChange
 INTEGER/* Вести журнал изменений *//* Вести журнал изменений */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PART_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PART_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PART_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_BRIEF  (
 aCURSESSION uuid,
 aPARTMENUid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_DELETE  (
 aCURSESSION uuid,
 aPARTMENUid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTMENU_SAVE (
 aCURSESSION uuid,
 aPARTMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,athe_Action
 uuid/* Метод *//* Метод */
,aIsMenuItem
 INTEGER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 INTEGER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTMENU_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PARTMENU_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_BRIEF  (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_DELETE  (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTPARAMMAP_SAVE (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aNoEdit
 INTEGER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTPARAMMAP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PARTPARAMMAP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELD_BRIEF  (
 aCURSESSION uuid,
 aFIELDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_DELETE  (
 aCURSESSION uuid,
 aFIELDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELD_SAVE (
 aCURSESSION uuid,
 aFIELDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aSequence
 integer/* № п/п *//* № п/п */
,aCaption
 VARCHAR/* Надпись *//* Надпись */
,aName
 VARCHAR/* Имя поля *//* Имя поля */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aIsBrief
 INTEGER/* Краткая информация *//* Краткая информация */
,aAllowNull
 INTEGER/* Может быть пустым *//* Может быть пустым */
,aDataSize
 integer/* Размер поля *//* Размер поля */
,aReferenceType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Ссылка на тип *//* Ссылка на тип */
,aRefToPart
 uuid/* Ссылка на раздел *//* Ссылка на раздел */
,aInternalReference
 INTEGER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,aCreateRefOnly
 INTEGER/* Только создание объекта *//* Только создание объекта */
,aIsAutoNumber
 INTEGER/* Автонумерация *//* Автонумерация */
,aTheNumerator
 uuid/* Нумератор *//* Нумератор */
,aZoneTemplate
 VARCHAR/* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,aNumberDateField
 uuid/* Поле для расчета даты *//* Поле для расчета даты */
,aTheComment
 TEXT/* Описание *//* Описание */
,ashablonBrief
 VARCHAR/* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,atheNameClass
 VARCHAR/* Имя класса для мастера строк *//* Имя класса для мастера строк */
,aTheMask
 VARCHAR/* Маска *//* Маска */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_DELETE  (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDVALIDATOR_SAVE (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDVALIDATOR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDVALIDATOR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_BRIEF  (
 aCURSESSION uuid,
 aFIELDMENUid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_DELETE  (
 aCURSESSION uuid,
 aFIELDMENUid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDMENU_SAVE (
 aCURSESSION uuid,
 aFIELDMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,aActionID
 uuid/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aIsMenuItem
 INTEGER/* В меню *//* В меню */
,aIsToolBarButton
 INTEGER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDMENU_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDMENU_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_BRIEF  (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_DELETE  (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDPARAMMAP_SAVE (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aNoEdit
 INTEGER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDPARAMMAP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDPARAMMAP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_BRIEF  (
 aCURSESSION uuid,
 aFldExtendersid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_DELETE  (
 aCURSESSION uuid,
 aFldExtendersid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FldExtenders_SAVE (
 aCURSESSION uuid,
 aFldExtendersid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR/* Объект *//* Объект */
,aTheConfig
 VARCHAR/* Конфиг *//* Конфиг */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FldExtenders_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FldExtenders_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_BRIEF  (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_DELETE  (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDEXPRESSION_SAVE (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDEXPRESSION_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDEXPRESSION_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_BRIEF  (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_DELETE  (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  DINAMICFILTERSCRIPT_SAVE (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  DINAMICFILTERSCRIPT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  DINAMICFILTERSCRIPT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_BRIEF  (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_DELETE  (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDSRCDEF_SAVE (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aProvider
 VARCHAR/* Провайдер *//* Провайдер */
,aConnectionString
 VARCHAR/* Строка соединения с источником *//* Строка соединения с источником */
,aDataSource
 VARCHAR/* Источник данных *//* Источник данных */
,aIDField
 VARCHAR/* ID *//* ID */
,aBriefString
 VARCHAR/* Источник краткой информации *//* Источник краткой информации */
,aFilterString
 VARCHAR/* Фильтр источника данных *//* Фильтр источника данных */
,aSortField
 VARCHAR/* Сортировка источника данных *//* Сортировка источника данных */
,aDescriptionString
 TEXT/* Примечания *//* Примечания */
,aDontShowDialog
 integer/* Не показывать форму выбора *//* Не показывать форму выбора */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDSRCDEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDSRCDEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_BRIEF  (
 aCURSESSION uuid,
 aPARTVIEWid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_DELETE  (
 aCURSESSION uuid,
 aPARTVIEWid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTVIEW_SAVE (
 aCURSESSION uuid,
 aPARTVIEWid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aForChoose
 INTEGER/* Для поиска *//* Для поиска */
,aFilterField0
 VARCHAR/* Поле - фильтр 0 *//* Поле - фильтр 0 */
,aFilterField1
 VARCHAR/* Поле - фильтр 1 *//* Поле - фильтр 1 */
,aFilterField2
 VARCHAR/* Поле - фильтр 2 *//* Поле - фильтр 2 */
,aFilterField3
 VARCHAR/* Поле - фильтр 3 *//* Поле - фильтр 3 */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTVIEW_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PARTVIEW_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_BRIEF  (
 aCURSESSION uuid,
 aViewColumnid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_DELETE  (
 aCURSESSION uuid,
 aViewColumnid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ViewColumn_SAVE (
 aCURSESSION uuid,
 aViewColumnid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* №  *//* №  */
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псвдоним *//* Псвдоним */
,aFromPart
 uuid/* Раздел *//* Раздел */
,aField
 uuid/* Поле *//* Поле */
,aAggregation
 INTEGER/* Агрегация *//* Агрегация */
,aExpression
 TEXT/* Формула *//* Формула */
,aForCombo
 INTEGER/* Для комбо *//* Для комбо */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ViewColumn_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ViewColumn_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_BRIEF  (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_DELETE  (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTVIEW_LNK_SAVE (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheView
 uuid/* Представление *//* Представление */
,aTheJoinSource
 uuid/* Связь: Поле для join источник *//* Связь: Поле для join источник */
,aRefType
 integer/* Связывать как *//* Связывать как */
,aTheJoinDestination
 uuid/* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,aHandJoin
 VARCHAR/* Ручной join *//* Ручной join */
,aSEQ
 integer/* Порядок *//* Порядок */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  PARTVIEW_LNK_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  PARTVIEW_LNK_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_BRIEF  (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_DELETE  (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ExtenderInterface_SAVE (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR/* Объект *//* Объект */
,aTheConfig
 VARCHAR/* Конфиг *//* Конфиг */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ExtenderInterface_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ExtenderInterface_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aVALIDATORid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_DELETE  (
 aCURSESSION uuid,
 aVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  VALIDATOR_SAVE (
 aCURSESSION uuid,
 aVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  VALIDATOR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  VALIDATOR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_BRIEF  (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_DELETE  (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  UNIQUECONSTRAINT_SAVE (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aPerParent
 INTEGER/* По родителю *//* По родителю */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  UNIQUECONSTRAINT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  UNIQUECONSTRAINT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_BRIEF  (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_DELETE  (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  CONSTRAINTFIELD_SAVE (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheField
 uuid/* Поле *//* Поле */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  CONSTRAINTFIELD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  CONSTRAINTFIELD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_DELETE  (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INSTANCEVALIDATOR_SAVE (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INSTANCEVALIDATOR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INSTANCEVALIDATOR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_BRIEF  (
 aCURSESSION uuid,
 aOBJSTATUSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_DELETE  (
 aCURSESSION uuid,
 aOBJSTATUSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJSTATUS_SAVE (
 aCURSESSION uuid,
 aOBJSTATUSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aname
 VARCHAR/* Название *//* Название */
,aisStartup
 INTEGER/* Начальное *//* Начальное */
,aIsArchive
 INTEGER/* Архивное *//* Архивное */
,athe_comment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJSTATUS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  OBJSTATUS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_BRIEF  (
 aCURSESSION uuid,
 aNEXTSTATEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_DELETE  (
 aCURSESSION uuid,
 aNEXTSTATEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  NEXTSTATE_SAVE (
 aCURSESSION uuid,
 aNEXTSTATEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheState
 uuid/* Разрешенное состояние *//* Разрешенное состояние */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  NEXTSTATE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  NEXTSTATE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_BRIEF  (
 aCURSESSION uuid,
 aOBJECTMODEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_DELETE  (
 aCURSESSION uuid,
 aOBJECTMODEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJECTMODE_SAVE (
 aCURSESSION uuid,
 aOBJECTMODEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название режима *//* Название режима */
,aDefaultMode
 INTEGER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  OBJECTMODE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  OBJECTMODE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_DELETE  (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STRUCTRESTRICTION_SAVE (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aStruct
 uuid/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aAllowRead
 INTEGER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowAdd
 INTEGER/* Разрешено добавлять *//* Разрешено добавлять */
,aAllowEdit
 INTEGER/* Разрешено изменять *//* Разрешено изменять */
,aAllowDelete
 INTEGER/* Разрешено удалять *//* Разрешено удалять */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  STRUCTRESTRICTION_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  STRUCTRESTRICTION_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_DELETE  (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDRESTRICTION_SAVE (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aThePart
 uuid/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,aTheField
 uuid/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aAllowRead
 INTEGER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowModify
 INTEGER/* Разрешена модификация *//* Разрешена модификация */
,aMandatoryField
 integer/* Обязательное поле *//* Обязательное поле */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  FIELDRESTRICTION_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  FIELDRESTRICTION_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_DELETE  (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  METHODRESTRICTION_SAVE (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aPart
 uuid/* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,aMethod
 uuid/* Метод *//* Метод */
,aIsRestricted
 INTEGER/* Запрещено использовать *//* Запрещено использовать */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  METHODRESTRICTION_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  METHODRESTRICTION_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_BRIEF  (
 aCURSESSION uuid,
 aTYPEMENUid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_DELETE  (
 aCURSESSION uuid,
 aTYPEMENUid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  TYPEMENU_SAVE (
 aCURSESSION uuid,
 aTYPEMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,athe_Action
 uuid/* Метод *//* Метод */
,aIsMenuItem
 INTEGER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 INTEGER/* Включать в тулбар *//* Включать в тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  TYPEMENU_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  TYPEMENU_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_BRIEF  (
 aCURSESSION uuid,
 aMTZAPPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_DELETE  (
 aCURSESSION uuid,
 aMTZAPPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZAPP_SAVE (
 aCURSESSION uuid,
 aMTZAPPid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aDBName
 VARCHAR/* База данных *//* База данных */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZAPP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZAPP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_BRIEF  (
 aCURSESSION uuid,
 aParentPackageid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_DELETE  (
 aCURSESSION uuid,
 aParentPackageid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ParentPackage_SAVE (
 aCURSESSION uuid,
 aParentPackageid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aPackage
 uuid/* Приложение *//* Приложение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ParentPackage_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ParentPackage_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_BRIEF  (
 aCURSESSION uuid,
 aGENPACKAGEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_DELETE  (
 aCURSESSION uuid,
 aGENPACKAGEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENPACKAGE_SAVE (
 aCURSESSION uuid,
 aGENPACKAGEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENPACKAGE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GENPACKAGE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_BRIEF  (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_DELETE  (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENERATOR_TARGET_SAVE (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTargetType
 integer/* Тип платформы *//* Тип платформы */
,aQueueName
 VARCHAR/* Очередь *//* Очередь */
,aGeneratorProgID
 VARCHAR/* COM класс *//* COM класс */
,aGeneratorStyle
 INTEGER/* Вариант *//* Вариант */
,aTheDevelopmentEnv
 INTEGER/* Среда разработки *//* Среда разработки */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENERATOR_TARGET_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GENERATOR_TARGET_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_BRIEF  (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_DELETE  (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENMANUALCODE_SAVE (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aCode
 TEXT/* Код *//* Код */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENMANUALCODE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GENMANUALCODE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_BRIEF  (
 aCURSESSION uuid,
 aGENCONTROLSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_DELETE  (
 aCURSESSION uuid,
 aGENCONTROLSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENCONTROLS_SAVE (
 aCURSESSION uuid,
 aGENCONTROLSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aControlProgID
 VARCHAR/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,aControlClassID
 VARCHAR/* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aVersionMajor
 integer/* Версия *//* Версия */
,aVersionMinor
 integer/* Подверсия *//* Подверсия */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENCONTROLS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GENCONTROLS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_BRIEF  (
 aCURSESSION uuid,
 aGENREFERENCEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_DELETE  (
 aCURSESSION uuid,
 aGENREFERENCEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENREFERENCE_SAVE (
 aCURSESSION uuid,
 aGENREFERENCEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aRefClassID
 VARCHAR/* Класс ссылки *//* Класс ссылки */
,aVersionMajor
 integer/* Номер версии *//* Номер версии */
,aVersionMinor
 integer/* Подверсия *//* Подверсия */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GENREFERENCE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GENREFERENCE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_BRIEF  (
 aCURSESSION uuid,
 aLocalizeInfoid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_DELETE  (
 aCURSESSION uuid,
 aLocalizeInfoid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  LocalizeInfo_SAVE (
 aCURSESSION uuid,
 aLocalizeInfoid uuid,
ainstanceid uuid 
,aLangFull
 VARCHAR/* Язык - название *//* Язык - название */
,aLangShort
 VARCHAR/* Код языка *//* Код языка */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  LocalizeInfo_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  LocalizeInfo_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDNumerator" BlockCode=" create or replace function  STDNumerator_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDNumerator_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDNumerator_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_BRIEF  (
 aCURSESSION uuid,
 aNum_zonesid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_DELETE  (
 aCURSESSION uuid,
 aNum_zonesid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_zones_SAVE (
 aCURSESSION uuid,
 aNum_zonesid uuid,
ainstanceid uuid 
,aZoneMask
 VARCHAR/* Маска зоны *//* Маска зоны */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_zones_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Num_zones_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_BRIEF  (
 aCURSESSION uuid,
 aNum_Valuesid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_DELETE  (
 aCURSESSION uuid,
 aNum_Valuesid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_Values_SAVE (
 aCURSESSION uuid,
 aNum_Valuesid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,athe_Value
 integer/* Значение *//* Значение */
,aOwnerPartName
 VARCHAR/* Раздел *//* Раздел */
,aOwnerRowID
 uuid/* Идентификатор строки *//* Идентификатор строки */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_Values_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Num_Values_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Num_head_BRIEF  (
 aCURSESSION uuid,
 aNum_headid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_DELETE  (
 aCURSESSION uuid,
 aNum_headid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_head_SAVE (
 aCURSESSION uuid,
 aNum_headid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aShema
 INTEGER/* Схема нумерации *//* Схема нумерации */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Num_head_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Num_head_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--Ext_Photo_J" BlockCode=" create or replace function  Ext_Photo_J_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_J_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_J_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_BRIEF  (
 aCURSESSION uuid,
 aExt_Photosid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_DELETE  (
 aCURSESSION uuid,
 aExt_Photosid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photos_SAVE (
 aCURSESSION uuid,
 aExt_Photosid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheSourceObject
 VARCHAR/* Исходный объект (Тип) *//* Исходный объект (Тип) */
,aTheJournal
 uuid/* Журнал *//* Журнал */
,aTheReplacedPart
 VARCHAR/* Подменяемая часть *//* Подменяемая часть */
,aTheRefFieldName
 VARCHAR/* Поле ссылка на добавление *//* Поле ссылка на добавление */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photos_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Ext_Photos_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_BRIEF  (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_DELETE  (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photo_Call_SAVE (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTargetPlatform
 uuid/* TargetPlatform *//* TargetPlatform */
,aTheCallString
 VARCHAR/* Вызов *//* Вызов */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photo_Call_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Ext_Photo_Call_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INVF" BlockCode=" create or replace function  INVF_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_BRIEF  (
 aCURSESSION uuid,
 aINVF_DEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_DELETE  (
 aCURSESSION uuid,
 aINVF_DEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVF_DEF_SAVE (
 aCURSESSION uuid,
 aINVF_DEFid uuid,
ainstanceid uuid 
,aThePath
 VARCHAR/* Название файла *//* Название файла */
,aTheHash
 VARCHAR/* MD5 Хэш *//* MD5 Хэш */
,aLoadDate
 timestamp/* Дата загрузки *//* Дата загрузки */
,aTheUser
 uuid/* Оператор *//* Оператор */
,aTypeOfFile
 VARCHAR/* Тип файла *//* Тип файла */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVF_DEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVF_DEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSecurity" BlockCode=" create or replace function  MTZSecurity_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSecurity_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSecurity_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_BRIEF  (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_DELETE  (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSEC_RIGHT_SAVE (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid,
ainstanceid uuid 
,aPiority
 integer/* Приоритет *//* Приоритет */
,aTheGroup
 uuid/* Группа *//* Группа */
,aProtectedItem
 VARCHAR/* Защищаемый элемент *//* Защищаемый элемент */
,aAllow
 INTEGER/* Разрешение *//* Разрешение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSEC_RIGHT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZSEC_RIGHT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_OS" BlockCode=" create or replace function  INV_OS_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_OS_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_OS_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_RENTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_DELETE  (
 aCURSESSION uuid,
 aINVOS_RENTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_RENT_SAVE (
 aCURSESSION uuid,
 aINVOS_RENTid uuid,
ainstanceid uuid 
,aStartDate
 date/* Дата начала аренды *//* Дата начала аренды */
,aEndDate
 date/* Дата завершения аренды *//* Дата завершения аренды */
,aarendator
 uuid/* Арендатор *//* Арендатор */
,aADog
 VARCHAR/* Договор аренды *//* Договор аренды */
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_RENT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_RENT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_BRIEF  (
 aCURSESSION uuid,
 aINVOS_HISTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_DELETE  (
 aCURSESSION uuid,
 aINVOS_HISTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_HIST_SAVE (
 aCURSESSION uuid,
 aINVOS_HISTid uuid,
ainstanceid uuid 
,aUntilDate
 timestamp/* Значение до *//* Значение до */
,aChangedBy
 uuid/* Изменена пользователем *//* Изменена пользователем */
,aMatOtv
 uuid/* Матерально отв. *//* Матерально отв. */
,aComplNumber
 VARCHAR/* Номер комплекта *//* Номер комплекта */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprav
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aTheHouse
 uuid/* Здание *//* Здание */
,aFlow
 VARCHAR/* Этаж *//* Этаж */
,aRoom
 VARCHAR/* Кабинет *//* Кабинет */
,aWorkPlaceNum
 VARCHAR/* Номер рабочего места *//* Номер рабочего места */
,aTheOwner
 uuid/* Владелец *//* Владелец */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_HIST_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_HIST_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_DELETE  (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_OFFRULE_SAVE (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid,
ainstanceid uuid 
,aINFO
 VARCHAR/* Причина списания *//* Причина списания */
,aDocNumber
 VARCHAR/* № Документа *//* № Документа */
,aDocDate
 date/* Дата документа *//* Дата документа */
,aTheComment
 TEXT/* Примечание *//* Примечание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_OFFRULE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_OFFRULE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_BRIEF  (
 aCURSESSION uuid,
 aINVOS_SROKid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_DELETE  (
 aCURSESSION uuid,
 aINVOS_SROKid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_SROK_SAVE (
 aCURSESSION uuid,
 aINVOS_SROKid uuid,
ainstanceid uuid 
,aRecalcDate
 date/* Дата следующего пересчета срока *//* Дата следующего пересчета срока */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_SROK_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_SROK_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_BRIEF  (
 aCURSESSION uuid,
 aINVOS_TECHid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_DELETE  (
 aCURSESSION uuid,
 aINVOS_TECHid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_TECH_SAVE (
 aCURSESSION uuid,
 aINVOS_TECHid uuid,
ainstanceid uuid 
,aMAC_Addr
 VARCHAR/* MAC_Addr *//* MAC_Addr */
,aComputer_Name
 VARCHAR/* Computer_Name *//* Computer_Name */
,aIP_Addr
 VARCHAR/* IP_Addr *//* IP_Addr */
,aCurrent_User_Name
 VARCHAR/* Current_User_Name *//* Current_User_Name */
,aSystem
 VARCHAR/* System *//* System */
,aRecord_Date
 VARCHAR/* Record_Date *//* Record_Date */
,aParam_0
 VARCHAR/* Param_0 *//* Param_0 */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_TECH_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_TECH_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_DELETE  (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_WINSOFT_SAVE (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_WINSOFT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_WINSOFT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_BRIEF  (
 aCURSESSION uuid,
 aINVOS_COMPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_DELETE  (
 aCURSESSION uuid,
 aINVOS_COMPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_COMP_SAVE (
 aCURSESSION uuid,
 aINVOS_COMPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_COMP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_COMP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_BRIEF  (
 aCURSESSION uuid,
 aINVOS_HARDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_DELETE  (
 aCURSESSION uuid,
 aINVOS_HARDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_HARD_SAVE (
 aCURSESSION uuid,
 aINVOS_HARDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_HARD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_HARD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_DELETE  (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CURCFG_SAVE (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CURCFG_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_CURCFG_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_DELETE  (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CFGCH_SAVE (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aChDate
 timestamp/* Date *//* Date */
,aChNum
 integer/* Change number *//* Change number */
,aTheValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CFGCH_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_CFGCH_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_DELETE  (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DEVICES_SAVE (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DEVICES_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_DEVICES_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_DELETE  (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DRAG_SAVE (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid,
ainstanceid uuid 
,aDragMet
 uuid/* Драг. металл *//* Драг. металл */
,aQ
 float/* Содержание *//* Содержание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DRAG_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_DRAG_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_DELETE  (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DOCS_SAVE (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid,
ainstanceid uuid 
,aInOrderNum
 VARCHAR/* Номер приходного ордера *//* Номер приходного ордера */
,aNaklNum
 VARCHAR/* Номер накладной *//* Номер накладной */
,aContragent
 uuid/* Контрагент *//* Контрагент */
,aDogNum
 VARCHAR/* Номер договора *//* Номер договора */
,aAccNum
 VARCHAR/* Номер счета *//* Номер счета */
,aAccFNum
 VARCHAR/* Номер счета фактуры *//* Номер счета фактуры */
,aActivateNum
 VARCHAR/* Номер ввода в эксплуатацию *//* Номер ввода в эксплуатацию */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_DOCS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_DOCS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_BRIEF  (
 aCURSESSION uuid,
 aINVOS_INVid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_DELETE  (
 aCURSESSION uuid,
 aINVOS_INVid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_INV_SAVE (
 aCURSESSION uuid,
 aINVOS_INVid uuid,
ainstanceid uuid 
,aInventory
 uuid/* Инвентаризация *//* Инвентаризация */
,aInvDate
 timestamp/* Дата инвентаризации *//* Дата инвентаризации */
,aOSStatus
 uuid/* Состояние *//* Состояние */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_INV_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_INV_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_BRIEF  (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_DELETE  (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_LIZING_SAVE (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер договора *//* Номер договора */
,aTheDate
 date/* Дата  передачи *//* Дата  передачи */
,aTheAgent
 uuid/* Контрагент *//* Контрагент */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_LIZING_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_LIZING_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_DELETE  (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CNSRV_SAVE (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала *//* Дата начала */
,aEndDate
 date/* Дата завершения *//* Дата завершения */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CNSRV_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_CNSRV_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_BRIEF  (
 aCURSESSION uuid,
 aINVOS_INFOid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_DELETE  (
 aCURSESSION uuid,
 aINVOS_INFOid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_INFO_SAVE (
 aCURSESSION uuid,
 aINVOS_INFOid uuid,
ainstanceid uuid 
,aTheOrg
 uuid/* На учете в  *//* На учете в  */
,aIsMaterial
 INTEGER/* Материал *//* Материал */
,aOSType
 uuid/* Группа ОС *//* Группа ОС */
,aName
 VARCHAR/* Наименование *//* Наименование */
,aShortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aCardNum
 VARCHAR/* Номер карточки учета *//* Номер карточки учета */
,aINVNum
 VARCHAR/* Инвентарный номер *//* Инвентарный номер */
,aCreateNum
 button/* Присвоить № *//* Присвоить № */
,aInLineNum
 integer/* Номер в партии *//* Номер в партии */
,aTheCost
 float/* Cтоимость *//* Cтоимость */
,aSrokPI
 integer/* Срок ПИ *//* Срок ПИ */
,aSrokFI
 integer/* Срок ФИ *//* Срок ФИ */
,aSrokOI
 integer/* Остаточный срок ПИ *//* Остаточный срок ПИ */
,aActivateDate
 date/* Дата ввода в эксп. *//* Дата ввода в эксп. */
,aInfo
 TEXT/* Описание *//* Описание */
,aTechFilePath
 VARCHAR/* Путь к файлу  с ТИ *//* Путь к файлу  с ТИ */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_INFO_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_INFO_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_BRIEF  (
 aCURSESSION uuid,
 aINVOS_MODid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_DELETE  (
 aCURSESSION uuid,
 aINVOS_MODid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_MOD_SAVE (
 aCURSESSION uuid,
 aINVOS_MODid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала *//* Дата начала */
,aEndDate
 date/* Дата завершения *//* Дата завершения */
,aINFO
 TEXT/* Суть модернизации *//* Суть модернизации */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_MOD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_MOD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_DELETE  (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CMNT_SAVE (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid,
ainstanceid uuid 
,aTheCommenter
 uuid/* Запись сделал *//* Запись сделал */
,aTheDate
 date/* Дата записи *//* Дата записи */
,aInfo
 VARCHAR/* Информация *//* Информация */
,aTheComment
 TEXT/* Примечание *//* Примечание */
,aThePhoto
 BYTEA/* Фотография *//* Фотография */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CMNT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_CMNT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CODEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_DELETE  (
 aCURSESSION uuid,
 aINVOS_CODEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CODE_SAVE (
 aCURSESSION uuid,
 aINVOS_CODEid uuid,
ainstanceid uuid 
,aShCode
 VARCHAR/* Штрихкод *//* Штрихкод */
,aVisibleCode
 VARCHAR/* Читаемый код *//* Читаемый код */
,aCodePrinted
 INTEGER/* Штрихкод напечатан *//* Штрихкод напечатан */
,aMabualCreate
 INTEGER/* Создан вручную *//* Создан вручную */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_CODE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_CODE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_BRIEF  (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_DELETE  (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_REPAIR_SAVE (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid,
ainstanceid uuid 
,aStartDate
 date/* Дата начала ремонта *//* Дата начала ремонта */
,aEndDate
 date/* Дата завершения ремонта *//* Дата завершения ремонта */
,aINFO
 TEXT/* Вид ремонта *//* Вид ремонта */
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_REPAIR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_REPAIR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_DELETE  (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_PLACE_SAVE (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid,
ainstanceid uuid 
,aMatOtv
 uuid/* Матерально отв. *//* Матерально отв. */
,aTheHouse
 uuid/* Здание *//* Здание */
,aComplNumber
 VARCHAR/* Номер комплекта *//* Номер комплекта */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprav
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aFlow
 VARCHAR/* Этаж *//* Этаж */
,aRoom
 VARCHAR/* Кабинет *//* Кабинет */
,aWorkPlaceNum
 VARCHAR/* Номер рабочего места *//* Номер рабочего места */
,aTheOwner
 uuid/* Владелец *//* Владелец */
,aInfo
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVOS_PLACE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVOS_PLACE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZRprt" BlockCode=" create or replace function  MTZRprt_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZRprt_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZRprt_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Reports_BRIEF  (
 aCURSESSION uuid,
 aReportsid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_DELETE  (
 aCURSESSION uuid,
 aReportsid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Reports_SAVE (
 aCURSESSION uuid,
 aReportsid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aReportFile
 bytea/* Файл отчета */
,aReportFile_EXT varchar /* Файл отчета */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aPrepareMethod
 uuid/* Метод для формирования *//* Метод для формирования */
,aReportType
 INTEGER/* Тип отчета *//* Тип отчета */
,aTheReportExt
 uuid/* Расширение для создания отчета *//* Расширение для создания отчета */
,aReportView
 VARCHAR/* Базовый запрос *//* Базовый запрос */
,aTheComment
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Reports_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Reports_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Reports_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_BRIEF  (
 aCURSESSION uuid,
 aRPTStructid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_DELETE  (
 aCURSESSION uuid,
 aRPTStructid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTStruct_SAVE (
 aCURSESSION uuid,
 aRPTStructid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTStruct_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  RPTStruct_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_BRIEF  (
 aCURSESSION uuid,
 aRPTFieldsid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_DELETE  (
 aCURSESSION uuid,
 aRPTFieldsid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTFields_SAVE (
 aCURSESSION uuid,
 aRPTFieldsid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aFieldSize
 integer/* Размер *//* Размер */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTFields_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  RPTFields_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_BRIEF  (
 aCURSESSION uuid,
 aRPTFormulaid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_DELETE  (
 aCURSESSION uuid,
 aRPTFormulaid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTFormula_SAVE (
 aCURSESSION uuid,
 aRPTFormulaid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 TEXT/* Выражение *//* Выражение */
,aPlatform
 uuid/* Платформа *//* Платформа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  RPTFormula_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  RPTFormula_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZUsers" BlockCode=" create or replace function  MTZUsers_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZUsers_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZUsers_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Users_BRIEF  (
 aCURSESSION uuid,
 aUsersid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_DELETE  (
 aCURSESSION uuid,
 aUsersid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Users_SAVE (
 aCURSESSION uuid,
 aUsersid uuid,
ainstanceid uuid 
,aFamily
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
,aLogin
 VARCHAR/* Имя для входа *//* Имя для входа */
,aPassword varchar/* Пароль *//* Пароль */
,aDomaiName
 VARCHAR/* Доменное имя *//* Доменное имя */
,aEMail varchar/* e-mail *//* e-mail */
,aPhone
 VARCHAR/* Телефон *//* Телефон */
,aLocalPhone
 VARCHAR/* Местный телефон *//* Местный телефон */
,aMobilePhone
 VARCHAR/* Мобильный телефон *//* Мобильный телефон */
,aPhoto
 BYTEA/* Фото *//* Фото */
,aBirthDay
 date/* Дата рождения *//* Дата рождения */
,aActivity
 uuid/* Журнал активности *//* Журнал активности */
,aCertificateID
 VARCHAR/* CertificateID *//* CertificateID */
,aCertData
 TEXT/* CertData *//* CertData */
,aClientDef
 uuid/* Ассоциация с клиентом *//* Ассоциация с клиентом */
,aPersonaData
 uuid/* PersonaData *//* PersonaData */
,aPositionU
 VARCHAR/* Должность *//* Должность */
,aWorkPlace
 VARCHAR/* Место работы *//* Место работы */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Users_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Users_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Users_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Groups_BRIEF  (
 aCURSESSION uuid,
 aGroupsid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_DELETE  (
 aCURSESSION uuid,
 aGroupsid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Groups_SAVE (
 aCURSESSION uuid,
 aGroupsid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Groups_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Groups_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Groups_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_BRIEF  (
 aCURSESSION uuid,
 aGroupUserid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_DELETE  (
 aCURSESSION uuid,
 aGroupUserid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GroupUser_SAVE (
 aCURSESSION uuid,
 aGroupUserid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  GroupUser_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  GroupUser_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSystem" BlockCode=" create or replace function  MTZSystem_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSystem_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZSystem_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  SysLog_BRIEF  (
 aCURSESSION uuid,
 aSysLogid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_DELETE  (
 aCURSESSION uuid,
 aSysLogid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SysLog_SAVE (
 aCURSESSION uuid,
 aSysLogid uuid,
ainstanceid uuid 
,aTheSession
 uuid/* Сессия *//* Сессия */
,athe_Resource
 VARCHAR/* Ресурс *//* Ресурс */
,aLogStructID
 VARCHAR/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,aVERB
 VARCHAR/* Действие *//* Действие */
,aLogInstanceID
 uuid/* Идентификатор документа *//* Идентификатор документа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  SysLog_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  SysLog_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  the_Session_BRIEF  (
 aCURSESSION uuid,
 athe_Sessionid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_DELETE  (
 aCURSESSION uuid,
 athe_Sessionid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  the_Session_SAVE (
 aCURSESSION uuid,
 athe_Sessionid uuid,
ainstanceid uuid 
,aUserRole
 uuid/* Текущая роль пользователя *//* Текущая роль пользователя */
,aClosedAt
 timestamp/* Момент закрытия *//* Момент закрытия */
,aClosed
 integer/* Закрыта *//* Закрыта */
,aUsersid
 uuid/* Пользователь *//* Пользователь */
,aLastAccess
 timestamp/* Последнее подтверждение *//* Последнее подтверждение */
,aStartAt
 timestamp/* Момент открытия *//* Момент открытия */
,aLang
 VARCHAR/* Локализация *//* Локализация */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  the_Session_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  the_Session_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  LogReader_BRIEF  (
 aCURSESSION uuid,
 aLogReaderid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_DELETE  (
 aCURSESSION uuid,
 aLogReaderid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  LogReader_SAVE (
 aCURSESSION uuid,
 aLogReaderid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aAutoStart
 integer/* Автоматизированный запуск *//* Автоматизированный запуск */
,aAutoProgid
 VARCHAR/* Класс для автоматического запуска *//* Класс для автоматического запуска */
,aReadMarker
 timestamp/* Дата последней прочитанной записи *//* Дата последней прочитанной записи */
,aStartInterval
 integer/* Интервал запуска (мин) *//* Интервал запуска (мин) */
,aLastStart
 timestamp/* Дата последнего запуска *//* Дата последнего запуска */
,aLastStop
 timestamp/* Дата последне останвки *//* Дата последне останвки */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  LogReader_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  LogReader_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Verb_BRIEF  (
 aCURSESSION uuid,
 aVerbid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_DELETE  (
 aCURSESSION uuid,
 aVerbid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Verb_SAVE (
 aCURSESSION uuid,
 aVerbid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Verb_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Verb_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Verb_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--ROLES" BlockCode=" create or replace function  ROLES_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_BRIEF  (
 aCURSESSION uuid,
 aROLES_USERid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_DELETE  (
 aCURSESSION uuid,
 aROLES_USERid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_USER_SAVE (
 aCURSESSION uuid,
 aROLES_USERid uuid,
ainstanceid uuid 
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_USER_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_USER_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_BRIEF  (
 aCURSESSION uuid,
 aROLES_MAPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_DELETE  (
 aCURSESSION uuid,
 aROLES_MAPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_MAP_SAVE (
 aCURSESSION uuid,
 aROLES_MAPid uuid,
ainstanceid uuid 
,aTheGroup
 uuid/* Группа *//* Группа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_MAP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_MAP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_BRIEF  (
 aCURSESSION uuid,
 aROLES_DOCid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_DELETE  (
 aCURSESSION uuid,
 aROLES_DOCid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DOC_SAVE (
 aCURSESSION uuid,
 aROLES_DOCid uuid,
ainstanceid uuid 
,aThe_Document
 uuid/* Тип документа *//* Тип документа */
,aThe_Denied
 integer/* Запрещен *//* Запрещен */
,aAllowDeleteDoc
 INTEGER/* Разрешено удаление *//* Разрешено удаление */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DOC_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_DOC_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_BRIEF  (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_DELETE  (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DOC_STATE_SAVE (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aThe_State
 uuid/* Состояние *//* Состояние */
,aThe_Mode
 uuid/* Режим *//* Режим */
,aAllowDelete
 INTEGER/* Можно удалять *//* Можно удалять */
,aStateChangeDisabled
 INTEGER/* Запрещена смена состояния *//* Запрещена смена состояния */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DOC_STATE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_DOC_STATE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_BRIEF  (
 aCURSESSION uuid,
 aROLES_DEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_DELETE  (
 aCURSESSION uuid,
 aROLES_DEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DEF_SAVE (
 aCURSESSION uuid,
 aROLES_DEFid uuid,
ainstanceid uuid 
,aname
 VARCHAR/* Название *//* Название */
,aTheComment
 TEXT/* Описание *//* Описание */
,aRightsSet_Denied
 INTEGER/* Настройка прав запрещена *//* Настройка прав запрещена */
,aFormCFG_Denied
 INTEGER/* Настройки форм запрещены *//* Настройки форм запрещены */
,aListCFG_Denied
 INTEGER/* Настройка журналов запрещена *//* Настройка журналов запрещена */
,aFileExch_Denied
 INTEGER/* Файловый обмен запрещен *//* Файловый обмен запрещен */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_DEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_DEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_BRIEF  (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_DELETE  (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_REPORTS_SAVE (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid,
ainstanceid uuid 
,aThe_Report
 uuid/* Отчёт *//* Отчёт */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_REPORTS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_REPORTS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_BRIEF  (
 aCURSESSION uuid,
 aROLES_WPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_DELETE  (
 aCURSESSION uuid,
 aROLES_WPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_WP_SAVE (
 aCURSESSION uuid,
 aROLES_WPid uuid,
ainstanceid uuid 
,aWP
 uuid/* Приложение *//* Приложение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_WP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_WP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_BRIEF  (
 aCURSESSION uuid,
 aROLES_ACTid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_DELETE  (
 aCURSESSION uuid,
 aROLES_ACTid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_ACT_SAVE (
 aCURSESSION uuid,
 aROLES_ACTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
, aParentRowid uuid 
,aAccesible
 integer/* Доступность *//* Доступность */
,aEntryPoints
 uuid/* Доступные действия *//* Доступные действия */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_ACT_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ROLES_ACT_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZwp" BlockCode=" create or replace function  MTZwp_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZwp_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZwp_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_BRIEF  (
 aCURSESSION uuid,
 aWorkPlaceid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_DELETE  (
 aCURSESSION uuid,
 aWorkPlaceid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  WorkPlace_SAVE (
 aCURSESSION uuid,
 aWorkPlaceid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTheVersion
 VARCHAR/* Версия *//* Версия */
,aThePlatform
 INTEGER/* Платформа реализации *//* Платформа реализации */
,aTheComment
 TEXT/* Примечание *//* Примечание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  WorkPlace_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  WorkPlace_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_BRIEF  (
 aCURSESSION uuid,
 aEntryPointsid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_DELETE  (
 aCURSESSION uuid,
 aEntryPointsid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  EntryPoints_SAVE (
 aCURSESSION uuid,
 aEntryPointsid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aAsToolbarItem
 INTEGER/* Включить в тулбар *//* Включить в тулбар */
,aActionType
 INTEGER/* Вариант действия *//* Вариант действия */
,aTheFilter
 uuid/* Фильтр *//* Фильтр */
,aJournal
 uuid/* Журнал *//* Журнал */
,aReport
 uuid/* Отчет *//* Отчет */
,aDocument
 uuid/* Документ *//* Документ */
,aMethod
 uuid/* Метод *//* Метод */
,aIconFile
 VARCHAR/* Файл картинки *//* Файл картинки */
,aTheExtention
 uuid/* Расширение *//* Расширение */
,aARM
 uuid/* АРМ *//* АРМ */
,aTheComment
 TEXT/* Примечание *//* Примечание */
,aObjectType
 uuid/* Тип документа *//* Тип документа */
,aJournalFixedQuery
 TEXT/* Ограничения к журналу *//* Ограничения к журналу */
,aAllowAdd
 INTEGER/* Разрешено добавление *//* Разрешено добавление */
,aAllowEdit
 INTEGER/* Разрешено редактирование *//* Разрешено редактирование */
,aAllowDel
 INTEGER/* Рарешено удаление *//* Рарешено удаление */
,aAllowFilter
 INTEGER/* Разрешен фильтр *//* Разрешен фильтр */
,aAllowPrint
 INTEGER/* Разрешена печать *//* Разрешена печать */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  EntryPoints_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  EntryPoints_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_BRIEF  (
 aCURSESSION uuid,
 aEPFilterLinkid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_DELETE  (
 aCURSESSION uuid,
 aEPFilterLinkid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  EPFilterLink_SAVE (
 aCURSESSION uuid,
 aEPFilterLinkid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aRowSource
 VARCHAR/* Источник *//* Источник */
,aTheExpression
 TEXT/* Выражение *//* Выражение */
,aFilterField
 VARCHAR/* Поле фильтра *//* Поле фильтра */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  EPFilterLink_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  EPFilterLink_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_BRIEF  (
 aCURSESSION uuid,
 aARMTypesid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_DELETE  (
 aCURSESSION uuid,
 aARMTypesid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMTypes_SAVE (
 aCURSESSION uuid,
 aARMTypesid uuid,
ainstanceid uuid 
,aTheDocumentType
 uuid/* Тип документа *//* Тип документа */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMTypes_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ARMTypes_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_BRIEF  (
 aCURSESSION uuid,
 aARMJournalid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_DELETE  (
 aCURSESSION uuid,
 aARMJournalid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJournal_SAVE (
 aCURSESSION uuid,
 aARMJournalid uuid,
ainstanceid uuid 
,aTheJournal
 uuid/* Журнал *//* Журнал */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJournal_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ARMJournal_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLADDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_DELETE  (
 aCURSESSION uuid,
 aARMJRNLADDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLADD_SAVE (
 aCURSESSION uuid,
 aARMJRNLADDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheExtention
 uuid/* Расширение *//* Расширение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLADD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ARMJRNLADD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLREPid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_DELETE  (
 aCURSESSION uuid,
 aARMJRNLREPid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLREP_SAVE (
 aCURSESSION uuid,
 aARMJRNLREPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,arepname
 VARCHAR/* Название отчета *//* Название отчета */
,aTheReport
 uuid/* Отчет *//* Отчет */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLREP_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ARMJRNLREP_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_DELETE  (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLRUN_SAVE (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheExtention
 uuid/* Расширение *//* Расширение */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  ARMJRNLRUN_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  ARMJRNLRUN_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_DIC" BlockCode=" create or replace function  INV_DIC_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_DIC_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_DIC_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_BRIEF  (
 aCURSESSION uuid,
 aINVD_UPRid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_DELETE  (
 aCURSESSION uuid,
 aINVD_UPRid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_UPR_SAVE (
 aCURSESSION uuid,
 aINVD_UPRid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_UPR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_UPR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_BRIEF  (
 aCURSESSION uuid,
 aINVD_OTDELid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_DELETE  (
 aCURSESSION uuid,
 aINVD_OTDELid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OTDEL_SAVE (
 aCURSESSION uuid,
 aINVD_OTDELid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OTDEL_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_OTDEL_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_BRIEF  (
 aCURSESSION uuid,
 aINVD_BLDid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_DELETE  (
 aCURSESSION uuid,
 aINVD_BLDid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_BLD_SAVE (
 aCURSESSION uuid,
 aINVD_BLDid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aAddr
 TEXT/* Адрес *//* Адрес */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_BLD_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_BLD_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_BRIEF  (
 aCURSESSION uuid,
 aINVD_DRAGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_DELETE  (
 aCURSESSION uuid,
 aINVD_DRAGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_DRAG_SAVE (
 aCURSESSION uuid,
 aINVD_DRAGid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aedIzm
 VARCHAR/* Ед. изм. *//* Ед. изм. */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_DRAG_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_DRAG_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_BRIEF  (
 aCURSESSION uuid,
 aINVD_ORGid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_DELETE  (
 aCURSESSION uuid,
 aINVD_ORGid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_ORG_SAVE (
 aCURSESSION uuid,
 aINVD_ORGid uuid,
ainstanceid uuid 
,aNumPrefix
 integer/* Префикс инв. номера *//* Префикс инв. номера */
,aFullName
 VARCHAR/* Наименование *//* Наименование */
,aSortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aINN
 VARCHAR/* ИНН *//* ИНН */
,aKPP
 VARCHAR/* КПП *//* КПП */
,aUrAddr
 TEXT/* Юридический адрес *//* Юридический адрес */
,aFaktAddr
 TEXT/* Фактический адрес *//* Фактический адрес */
,aPhone
 VARCHAR/* Телефон \ Факс *//* Телефон \ Факс */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_ORG_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_ORG_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_BRIEF  (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_DELETE  (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OSSTATUS_SAVE (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OSSTATUS_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_OSSTATUS_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_BRIEF  (
 aCURSESSION uuid,
 aINVD_OWNERid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_DELETE  (
 aCURSESSION uuid,
 aINVD_OWNERid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OWNER_SAVE (
 aCURSESSION uuid,
 aINVD_OWNERid uuid,
ainstanceid uuid 
,aFamiliName
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OWNER_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_OWNER_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_BRIEF  (
 aCURSESSION uuid,
 aINVD_URid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_DELETE  (
 aCURSESSION uuid,
 aINVD_URid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_UR_SAVE (
 aCURSESSION uuid,
 aINVD_URid uuid,
ainstanceid uuid 
,aFullName
 VARCHAR/* Наименование *//* Наименование */
,aSortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aINN
 VARCHAR/* ИНН *//* ИНН */
,aKPP
 VARCHAR/* КПП *//* КПП */
,aUrAddr
 TEXT/* Юридический адрес *//* Юридический адрес */
,aFaktAddr
 TEXT/* Фактический адрес *//* Фактический адрес */
,aPhone
 VARCHAR/* Телефон \ Факс *//* Телефон \ Факс */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_UR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_UR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_BRIEF  (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_DELETE  (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OSTYPE_SAVE (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
,aShowTech
 INTEGER/* Отображать тех. инф. *//* Отображать тех. инф. */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_OSTYPE_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_OSTYPE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_BRIEF  (
 aCURSESSION uuid,
 aINVD_DIRid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_DELETE  (
 aCURSESSION uuid,
 aINVD_DIRid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_DIR_SAVE (
 aCURSESSION uuid,
 aINVD_DIRid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVD_DIR_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVD_DIR_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZ_Install" BlockCode=" create or replace function  MTZ_Install_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Install_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Install_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_DELETE  (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Build_SAVE (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid,
ainstanceid uuid 
,aPRODUCT_NAME
 VARCHAR/* PRODUCT_NAME *//* PRODUCT_NAME */
,aPRODUCT_VERSION
 VARCHAR/* PRODUCT_VERSION *//* PRODUCT_VERSION */
,aPRODUCT_PUBLISHER
 VARCHAR/* PRODUCT_PUBLISHER *//* PRODUCT_PUBLISHER */
,aPRODUCT_WEB_SITE
 VARCHAR/* PRODUCT_WEB_SITE *//* PRODUCT_WEB_SITE */
,aLicensFilePath
 VARCHAR/* Файл с лицензионным соглашением *//* Файл с лицензионным соглашением */
,aMainFileRef
 uuid/* Главный файл *//* Главный файл */
,aInstallDir
 VARCHAR/* InstallDir *//* InstallDir */
,aShortCutDir
 VARCHAR/* ShortCutDir *//* ShortCutDir */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Build_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ_Inst_Build_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_DELETE  (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Build_Sec_SAVE (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheSection
 uuid/* Секция *//* Секция */
,aTheDescription
 VARCHAR/* Комментарий *//* Комментарий */
,aIsRewriteSectionDesc
 integer/* Перезаписывать комментарий секции *//* Перезаписывать комментарий секции */
,aSEQ
 integer/* Порядок (от 1 до ...) *//* Порядок (от 1 до ...) */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Build_Sec_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ_Inst_Build_Sec_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_DELETE  (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Section_SAVE (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название (Eng) *//* Название (Eng) */
,aIsVisible
 integer/* Видимая *//* Видимая */
,aTheDescription
 VARCHAR/* Комментарий (ToolTip) *//* Комментарий (ToolTip) */
,aIsNotDeletable
 integer/* Обязательная *//* Обязательная */
,aTheTargetPlatform
 INTEGER/* Целевая платформа *//* Целевая платформа */
,aIsCustomSection
 integer/* Custom Section *//* Custom Section */
,aCustomSectionInstall
 uuid/* Custom Section Install *//* Custom Section Install */
,aCustomSectionUnInstall
 uuid/* Custom Section UnInstall *//* Custom Section UnInstall */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Section_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ_Inst_Section_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_DELETE  (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Sec_Files_SAVE (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheSource
 VARCHAR/* Файл или каталог *//* Файл или каталог */
,aIsCOM
 integer/* Является COM объектом *//* Является COM объектом */
,aHaveToRun
 integer/* Обязательно запустить *//* Обязательно запустить */
,aCommanLineParams
 VARCHAR/* Ключи запуска *//* Ключи запуска */
,aSysstemObject
 uuid/* Объект системы *//* Объект системы */
,aTheApplication
 uuid/* Приложение системы *//* Приложение системы */
,aSubDir
 VARCHAR/* Подкаталог *//* Подкаталог */
,aIsShortcut
 integer/* Ярлык в меню *//* Ярлык в меню */
,aShortcutName
 VARCHAR/* Имя ярлыка *//* Имя ярлыка */
,aShortCutInfo
 VARCHAR/* Комментярий ярлыка *//* Комментярий ярлыка */
,aDefaultInterface
 VARCHAR/* Интерфейс по умолчанию *//* Интерфейс по умолчанию */
,aHaveToRunDeinst
 integer/* Запустить при деинсталляции *//* Запустить при деинсталляции */
,aDeinstallComandParam
 VARCHAR/* Ключи деинсталляции *//* Ключи деинсталляции */
,aIsCustomScript
 integer/* Пользовательский скрипт (см. поле Файл или каталог) *//* Пользовательский скрипт (см. поле Файл или каталог) */
,aCustomScriptInstall
 uuid/* Custom Script Install *//* Custom Script Install */
,aCustomScriptUnInstall
 uuid/* Custom Script UnInstall *//* Custom Script UnInstall */
,aSEQ
 integer/* Порядок *//* Порядок */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Sec_Files_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ_Inst_Sec_Files_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_DELETE  (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Common_SAVE (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheInstallScript
 TEXT/* Секция инсталляции *//* Секция инсталляции */
,aSEQ
 integer/* Порядок (сортировка) *//* Порядок (сортировка) */
,aIsDeinstallUSE
 integer/* Использовать при деинсталляции *//* Использовать при деинсталляции */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Inst_Common_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZ_Inst_Common_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDInfoStore" BlockCode=" create or replace function  STDInfoStore_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDInfoStore_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  STDInfoStore_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_BRIEF  (
 aCURSESSION uuid,
 aInfoStoreDefid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_DELETE  (
 aCURSESSION uuid,
 aInfoStoreDefid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  InfoStoreDef_SAVE (
 aCURSESSION uuid,
 aInfoStoreDefid uuid,
ainstanceid uuid 
,aTheGroup
 uuid/* Группа *//* Группа */
,aName
 VARCHAR/* Название *//* Название */
,aInfoStoreType
 INTEGER/* Тип каталога *//* Тип каталога */
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  InfoStoreDef_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  InfoStoreDef_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Folder_BRIEF  (
 aCURSESSION uuid,
 aFolderid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_DELETE  (
 aCURSESSION uuid,
 aFolderid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Folder_SAVE (
 aCURSESSION uuid,
 aFolderid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aFolderType
 INTEGER/* Тип папки *//* Тип папки */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Folder_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Folder_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Folder_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_BRIEF  (
 aCURSESSION uuid,
 aShortcutid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_DELETE  (
 aCURSESSION uuid,
 aShortcutid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Shortcut_SAVE (
 aCURSESSION uuid,
 aShortcutid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aDocItem
 uuid/* Документ *//* Документ */
,aStartMode
 VARCHAR/* Режим *//* Режим */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  Shortcut_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  Shortcut_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZExt" BlockCode=" create or replace function  MTZExt_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_BRIEF  (
 aCURSESSION uuid,
 aMTZExt_defid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_DELETE  (
 aCURSESSION uuid,
 aMTZExt_defid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExt_def_SAVE (
 aCURSESSION uuid,
 aMTZExt_defid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aExtType
 INTEGER/* Тип расширения *//* Тип расширения */
,aTheDescription
 TEXT/* Описание *//* Описание */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExt_def_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZExt_def_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_BRIEF  (
 aCURSESSION uuid,
 aMTZExtRelid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_DELETE  (
 aCURSESSION uuid,
 aMTZExtRelid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExtRel_SAVE (
 aCURSESSION uuid,
 aMTZExtRelid uuid,
ainstanceid uuid 
,aThePlatform
 INTEGER/* Реализация *//* Реализация */
,aTheClassName
 VARCHAR/* Название класса *//* Название класса */
,aTheLibraryName
 VARCHAR/* Название библиотеки *//* Название библиотеки */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExtRel_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  MTZExtRel_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_NUM" BlockCode=" create or replace function  INV_NUM_DELETE(aCURSESSION uuid, ainstanceid uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_NUM_HCL(aCURSESSION uuid, aRowID uuid)returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INV_NUM_propagate(aCURSESSION uuid, aRowID uuid)returns void as $$ begin end; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_BRIEF  (
 aCURSESSION uuid,
 aINVN_DEFid uuid
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_DELETE  (
 aCURSESSION uuid,
 aINVN_DEFid uuid,
 ainstanceid uuid
) returns void as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVN_DEF_SAVE (
 aCURSESSION uuid,
 aINVN_DEFid uuid,
ainstanceid uuid 
,aTheNumber
 integer/* Следующий номер материала *//* Следующий номер материала */
,aTheOrg
 uuid/* Организация *//* Организация */
,aTheOSNumber
 integer/* Следующий номер ОС *//* Следующий номер ОС */
)returns void  as $$ begin end; $$ language 'plpgsql'; 
GO
 create or replace function  INVN_DEF_PARENT_ID  (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_PARENT_T  (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_ISLOCKED  (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_LOCK  (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_HCL(
 aCURSESSION uuid,
 aRowID uuid
) returns integer as $$ begin  return 0 ; end; $$ language 'plpgsql'
GO
 create or replace function  INVN_DEF_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_SINIT  (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$ begin end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_propagate(
 aCURSESSION uuid,
 aRowID uuid
)  returns void as $$ begin end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--functions.Methods" File=""><BlockHolder BlockName="--body" BlockCode=" 

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Custom" File=""><BlockHolder BlockName="--body" BlockCode=" 

/* AdminUnlockAll  Административная функция для 
разблокировки документов*/
create or replace function AdminUnlockAll

(
)  

 RETURNS void AS
$BODY$
begin
update instance set LockUserID = null, LockSessionID=null ;
end;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE


GO

/* GetNewNumber  Следующий номер из нумератора*/
create or replace function GetNewNumber

(athe_Zone VARCHAR/* Зона */

,aNumeratorID uuid/* нумератор */

)  

returns integer as $$ 
declare
anum integer;
an integer;
aid1 uuid;
aid2 uuid;
existsCnt integer;
begin

select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return anum;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return anum;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
return anum;
end;
$$
language 'plpgsql';


GO

/* TestNumber  Проверить наличие номера в нумераторе*/
create or replace function TestNumber

(athe_Zone VARCHAR/* Зона */

,aNumeratorID uuid/* нумератор */

,anum integer/* номер */

)  

 returns integer as $$

declare
aresult integer;
aid1 uuid; 
existsCnt  integer; 
begin 
aresult:=0; 
 
select count(*) into existsCnt from instance where instanceid=aNumeratorID; 
if existsCnt =0 then 
  return aresult; 
end if; 
 
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
 
if existsCnt=0 then 
    return aresult; 
else 
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
  select count(*) into existsCnt from num_values where parentStructRowID=aID1 and the_value=anum; 
 
  if existsCnt=0 then 
      return aresult; 
  else 
     aresult:=1; 
  end if; 
end if; 
return aresult; 
end; 
$$ language 'plpgsql';


GO

/* SessionVerify  Проверка состояния сессии*/
create or replace function SessionVerify

(aCURSESSION uuid/* Сессия */

)  

returns integer as $$
declare
aOK integer;
existsCnt integer;
begin
select Count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;

if  existsCnt&gt;0 then
aOK:=1;
else
aOK :=0;
end if;
return aOK;
end;
$$ language 'plpgsql';


GO

/* GetFreeNumber  Свободный номер из нумератора*/
create or replace function GetFreeNumber

(athe_Zone VARCHAR/* Зона */

,aNumeratorID uuid/* нумератор */

)  

returns integer as $$
declare
anum integer;
an integer;
aid1 uuid;
aid2 uuid;
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return anum;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return anum;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
return anum;
end;
$$
language 'plpgsql';


GO

/* SessionCheckPoint  Автоматическое закрытие &quot;Подвисших&quot; сессий*/
create or replace function SessionCheckPoint

(aCURSESSION uuid/* Текущая сессия */

)  

 
returns void as
$$
declare
aCurs refcursor;
aID uuid;
begin

open aCurs for select the_sessionid id from the_session
where lastAccess &lt; LOCALTIMESTAMP -1;
LOOP
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  
 END IF;
 PERFORM logout (aID);
END LOOP;
close aCurs;


end; $$
language 'plpgsql';


GO

/* RowsToInstances  Получить массив объектов, которые содержат строки*/
create or replace function RowsToInstances

(aRowQueryID uuid/* Идентификатор массива строк */

,aOutputQueryID uuid/* идентификатор масива результатов */

,athe_Table VARCHAR/* Таблица */

,aCURSESSION uuid/* Сессия пльзователя */

)  

 RETURNS void AS
$BODY$ 

declare
aInstanceID uuid; 
existsCnt integer; 
aCurs refcursor;
aID uuid;
begin

open aCurs for select result ID from queryresult where queryresultid =arowqueryID; 
 


loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
  aInstanceID:= RowToInstance (aID, athe_TABLE, aCURSESSION); 
       if not ainstanceid is null then
          select count(*) into existsCnt from queryresult where QUERYRESULTID = aOutputQueryID and RESULT=aInstanceID; 
	  if existsCnt =0 then 
	    insert into queryresult (queryresultid,result) values(aoutputqueryid,ainstanceid); 
	  end if; 
       end if;
END LOOP;

close aCurs; 

end; $BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;


GO

/* GetServerTime  текущее время сервера*/
create or replace function GetServerTime

(
)  

returns timestamp as $$
declare
aServerTime timestamp;
existsCnt integer;
begin
select LOCALTIMESTAMP into aServerTime;
return aServerTime;
end;
$$ language 'plpgsql';


GO

/* SessionTouch  Поддержание сессии*/
create or replace function SessionTouch

(aCURSESSION uuid/* Идентификатор сессии */

)  

returns void as $$

begin
update the_session set lastaccess=LOCALTIMESTAMP where the_sessionid=acursession and closed=0;
end;
$$
  LANGUAGE 'plpgsql' VOLATILE


GO

/* MTZLogin  Открытие сессии*/
create or replace function MTZLogin

(aPWD varchar/* Пароль */

,aUSR VARCHAR/* Имя пользователя */

)  

RETURNS uuid AS
$BODY$
declare
athe_session uuid;
aID uuid; 
aUSERSID uuid; 
asysid uuid; 
existsCnt integer;  
begin 
asysid := null; 
select instanceid into asysid from instance where objtype = 'MTZSYSTEM'; 
athe_session:=null  ; 
if aPWD is null  or aPWD=''
then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 
  then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    select  newid() into aID ; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,localtimestamp,ausersid,0,localtimestamp); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,localtimestamp,ausersid,0,localtimestamp); 
       end if; 
     athe_session:=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1 
  then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   aID:= newid();  
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,localtimestamp,ausersid,0, LOCALTIMESTAMP); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,localtimestamp,ausersid,0, LOCALTIMESTAMP); 
       end if; 
     athe_session:=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     aID:= newid();  
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,localtimestamp,ausersid,0,LOCALTIMESTAMP); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,localtimestamp,ausersid,0,LOCALTIMESTAMP); 
       end if; 
     athe_session:=aid; 
    End if; 
  end if; 
end if; -- password is null 
return athe_session;
end; 
$BODY$
  LANGUAGE 'plpgsql' VOLATILE


GO

/* RowToInstance  Поиск объекта для некоторой строки*/
create or replace function RowToInstance

(athe_RowID uuid/* Row */

,athe_Table VARCHAR/* Part Table Name */

,aCURSESSION uuid/* Session */

)  

 RETURNS uuid AS
$BODY$

declare
aparent varchar(255);
aprev varchar(255);
atmpID  uuid;
atmpRowID  uuid;
athe_InstanceID uuid;
astr varchar(4000);
existsCnt integer;
begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
 -- checking session  --
if  existsCnt =0
  then
    perform raise_application_error(-20000,'Session expired');

    return null;
  end if;

aparent :=athe_table;
atmpID := athe_ROWID;

loop

aprev := aparent;
begin 

aparent := null;
select thevalue into aparent from sysoptions where optiontype = 'PARENT' and  name=aprev;

end;
if aparent is null then
    astr := 'select InstanceID  from ' || aprev || ' where ' || aprev || 'id=$1';
    begin
        athe_InstanceID:=null;
        execute astr into atmpRowID using atmpid; 
        athe_InstanceID:=atmpRowID ;
    end;
    return athe_InstanceID;
else
    astr :='select ParentStructRowID from ' || aprev || ' where ' || aprev || 'id=$1';
    begin
	atmpID := null;
        execute astr into atmpRowID using atmpid;
        atmpID := atmpROWID;
    end;
 end if;
end loop;
end
;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;


GO

/* EraseNumber  Удалить номер из нумератора*/
create or replace function EraseNumber

(aNumeratorID uuid/* нумератор */

,athe_Zone VARCHAR/* Зона */

,anum integer/* номер */

)  

returns void as $$
declare
aid1 uuid;
existsCnt integer;
begin
select count(*) into existsCnt  from instance where instanceid=aNumeratorID;
if existsCnt=0 then
return;
end if;
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    return ;
else
  select num_zonesid into aID1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt  from num_values where parentStructRowID=aID1 ;
  if  existsCnt=0 then
      return;
  else
     delete from num_values where parentStructRowID=aID1 and the_value=anum;
  end if;
end if;
end;
$$ language 'plpgsql';


GO

/* AdminUnlock  Административная функция для 
разблокировки документов*/
create or replace function AdminUnlock

(athe_ID uuid/* Идентификатор документа */

)  

 RETURNS void AS
$BODY$
begin
update instance set LockUserID = null, LockSessionID=null ;
end;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE



GO

/* CheckVerbRight  Проверка прав на действие*/
create or replace function CheckVerbRight

(aCURSESSION uuid/* Сессия */

,athe_resource uuid/* идентификатор стиля прав */

,averb VARCHAR/* Действие */

)  

 returns integer
as $$
begin
 return 1;
end;
$$ language 'plpgsql';



GO

/* Logout  Завершение сессии*/
create or replace function Logout

(aCURSESSION uuid/* Идентификатор сессии */

)  

 RETURNS void AS
$BODY$
declare
existsCnt integer;

begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt &gt;0 then
   begin

    update INSTANCE set LockSessionID =null where LockSessionID=acursession ;
    update the_session set closed=1,closedAt=LOCALTIMESTAMP, changeStamp=LOCALTIMESTAMP where     
    the_sessionid=acursession;
   
  end;  
 End if;
end;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE


GO

/* AutoCloseSession  Автоматическое закрытие протухщих сессий*/
create or replace function AutoCloseSession

(
)  

 
returns void as
$$
declare
aCurs refcursor;
aID uuid;
begin

open aCurs for select the_sessionid id from the_session
where lastAccess &lt; LOCALTIMESTAMP -1;
LOOP
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  
 END IF;
 PERFORM logout (aID);
END LOOP;
close aCurs;


end; $$
language 'plpgsql';



GO

/*V_LOG (V_LOG)*/

create or replace  view V_LOG as 
select syslog.syslogid
,syslog.changestamp
,the_session.StartAt 
,the_session.Closed
,syslog.the_Resource
,syslog.LogStructID
,syslog.LogInstanceID
,syslog.VERB
,users.login
,users.Family
,users.Name
,users.Surname
,instance.name instname
,instance.objtype
,part.caption
,objecttype.the_comment
 from  syslog
join the_session on syslog.thesession=the_session.the_sessionid
join users on the_session.usersid=users.usersid
left join instance on syslog.loginstanceid = instance.instanceid
left join part on syslog.LogStructID = part.name
left join objecttype on instance.objtype =objecttype.name

GO

;

GO

/*Indexes ()*/

CREATE  INDEX Syslog_times ON SysLog(ChangeStamp) 
GO

create index instance_lockuser on instance(lockuserid)

GO

create index instance_locksession on instance(locksessionid)

GO

;

GO

/*V_SYSLOG (V_SYSLOG)*/

create or replace view V_SYSLOG as
select 
syslog.syslogid,syslog.changestamp,syslog.the_Resource,syslog.LogStructID,syslog.VERB,users.login,users.Family,users.Name,users.Surname,syslog.LogInstanceID 
from  syslog 
join the_session on syslog.thesession=the_session.the_sessionid 
join users on the_session.usersid=users.usersid


GO

;

GO

/*V_ROLEENTRY (V_ROLEENTRY)*/

create or replace view V_RoleEntryPoints as
select 
Roles_WP.instanceid ROLEID ,
Roles_WP.WP ARMID,
Roles_ACT.Accesible,
Entrypoints.Name,
Entrypoints.Caption
from ROLES_WP 
join ROLES_ACT on ROLES_WP.ROLES_WPID=ROLES_ACT.parentstructrowid
join entrypoints on 
ROLES_ACT.entrypoints=entrypoints.entrypointsid

GO

;

GO

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Functions.Body" File=""><BlockHolder BlockName="--body" BlockCode=" 

 

create or replace function INSTANCE_OWNER   (
    aCURSESSION uuid ,ainstanceid uuid,
 aOwnerPartName varchar, aOwnerRowID uuid) returns void as $$
 declare 
 existsCnt integer;
begin
select count(*)into existscnt from instance
where instanceid=ainstanceid;
If existsCnt &gt; 0 Then
  if aOwnerPartName is null or aownerRowID is null
  then
     update instance set OwnerPartName=null, OwnerRowid = null where instanceid=ainstanceid ;
  Else
     update instance set OwnerPartName=aOwnerPartName, OwnerRowid = aOwnerRowID where instanceid=ainstanceid ;
  End if;
End if;
end; $$ language 'plpgsql';
GO
 create or replace function  SYSOPTIONS_SAVE    (
   aSysOptionsid uuid,
aName varchar,
aValue varchar ,
aOptionType varchar) returns void as $$
 declare 
existsCnt numeric;
begin
 select count(*) into existsCnt from sysoptions where sysoptionsid=asysoptionsid;
 If existsCnt &gt; 0 Then
  update sysoptions set Name=aName, theValue=aValue, OptionType=aOptionType where sysoptionsid=asysoptionsid ;
 Else
  insert into sysoptions (sysoptionsid, Name, theValue, OptionType)values(asysoptionsid,aName,aValue,aOptionType) ;
 End if;
end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCE_SAVE      (
aCURSESSION uuid,
ainstanceid uuid,
aObjType varchar,
aName varchar
)returns void  as $$
 declare 
 aSSID uuid ;
 atmpID uuid ;
 aSysLogID uuid ;
 aaccess numeric ;
 aSysInstID uuid ;
 aStatusID uuid ;
 existsCnt numeric;
 theObjType varchar(255);
begin
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select  count(*) into existsCnt  from instance where instanceid=ainstanceid;
 If existsCnt &gt; 0 Then
   aaccess:= instance_ISLOCKED (acursession,ainstanceid  );
   If aaccess &gt; 2 Then
      perform  raise_application_error(-20000,'Объект заблокирован другим пользователем.') ;
     return;
   end if;
   select objtype into TheObjType from instance  where  instanceid=ainstanceid ;
   update instance set name = aname where  instanceid=ainstanceid;
   select newid() into aSysLogID  ;
   PERFORM SysLog_SAVE (acursession , aSysLogid, aSysInstID,acursession, 
   cast(aInstanceID as varchar), TheOBJTYPE , 
   'EDIT',   aInstanceID );
 Else
   begin
   select objstatusid into astatusid from objstatus join objecttype on
         objecttype.objecttypeid=objstatus.parentstructrowid and objecttype.name=aobjtype and isStartup&lt;&gt;0;
   exception when others then
      astatusid:=null ;
    end;
   If astatusid Is Null Then
     insert into instance(instanceid,name,objtype,SecurityStyleID) values(ainstanceid,aname,aobjtype,aSSID)         ;
   Else
     insert into instance(instanceid,name,objtype,SecurityStyleID,STATUS) values(ainstanceid,aname,aobjtype,aSSID,aSTATUSID) ;
   end if;
   select newid() into aSysLogid  ;
   
   PERFORM SysLog_SAVE (
     acursession ,
      aSysLogid,aSysInstID, acursession, cast(aInstanceID as varchar), aOBJTYPE , 
     'CREATE',   aInstanceID);
 End  if;
End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_DELETE    (
aCURSESSION uuid,
ainstanceid uuid
) returns void as $$
 declare 
 atmpStr varchar(255) ;
  aStr varchar(4000) ;
  aObjType varchar(255) ;
 aSysInstID uuid ;
    atmpID uuid ;
   aaccess integer;
   aOwnerPartName varchar(255) ;
   aOwnerRowID uuid ;
   aSysLogid uuid ;
    existsCnt integer;
begin
  select Instanceid into aSysInstID from instance where objtype='MTZSystem' ;
  select count(*) into existsCnt from instance where instanceid=ainstanceid;
  If existsCnt &gt; 0 Then
   select  SecurityStyleID, OwnerPartName,OWnerRowID
        Into atmpid, aOwnerpartname, aownerrowid
        from INSTANCE where INSTANCEid=aINSTANCEid ;
   If aOwnerpartname Is Null Or aownerrowid Is Null Then
        select  objtype into aobjtype from instance where instanceid=ainstanceid;
        select 'select ' || DeleteProc ||'($1,$2);' into atmpstr from typelist where name = aobjtype;
        If Not atmpstr Is Null Then
            EXECUTE  atmpstr  using acursession,ainstanceid;
        end if;
        delete from instance where instanceid=ainstanceid ;
        select newid() into aSysLogID;
        PERFORM SysLog_SAVE( acursession , aSysLogid, aSysInstID, acursession,    cast(aInstanceID as varchar),aobjtype ,
        'DELETE',  aInstanceID);
        Else
        -- Owner exists
         astr :='select '|| aownerpartname || 'id  from ' || aownerpartname || ' where ' || aownerpartname ||'id=$1';
         execute   astr into atmpid  using aownerrowid;
         If atmpid = aownerrowid Then
            perform  raise_application_error(-20000,'Этот документ принадлежит другому документу и не может быть удален отдельно.');
           return;
         End if;
         select  objtype into aObjType from instance where instanceid=ainstanceid;
         select 'select ' || DeleteProc ||'($1,$2); ' into atmpstr from typelist where name = aobjtype ;
         If Not atmpstr Is Null Then
           execute  atmpstr using acursession, ainstanceid;
           delete from instance where instanceid=ainstanceid ;
         select newid() into aSysLogID;
         PERFORM SysLog_SAVE (acursession ,
                      aSysLogid, aSysInstID, acursession,   cast(aInstanceID as varchar), aobjtype ,
                      'DELETE',   aInstanceID );
        End if;
     End if;
End if;
end; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_HCL   (
aCURSESSION uuid,
aRowID uuid
)returns integer  as $$
 declare 
aIsLocked  integer;
atmpStr varchar(255) ;
aObjType varchar(255) ;
existscnt integer;
begin
aIsLocked:=0;
 /* select count(*) into existsCnt from instance where instanceid=arowid ;
if existscnt=1
    then
      select objtype into aobjtype  from instance where instanceid=arowid ;
      select 'begin ' || aobjtype || '.' || HCLProc || '(acursession, arowid,aIsLocked); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute  atmpstr;
      End if;
end if; */
 return aIsLocked;
End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_PROPAGATE   (
aCURSESSION uuid,
aRowID uuid
)returns void  as $$
 declare 
atmpStr varchar(255) ;
aObjType varchar(255);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=arowid ;
if existsCnt=1
    then
      select  objtype into aobjtype from instance where instanceid=arowid ;
      select  'begin ' || aobjtype || '.' || propagateProc || '(acursession, arowid); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute  atmpstr;
    End if;
End if;
End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_ISLOCKED   (
 aCURSESSION uuid,
 aRowID uuid
)returns integer  as $$
 declare 
 aUserID uuid ;
 aLockUserID uuid ;
 aLockSessionID uuid ;
 existsCnt integer;
 aIsLocked  integer;
 begin
 aisLocked := 0 ;
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 If existsCnt = 0 Then
    perform  raise_application_error(-20000,'Сессия уже завершена');
   Return 0;
 End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession ;
 select LockUserID, LockSessionID
 Into aLockUserID, aLockSessionID
 from INSTANCE where INSTANCEid=aRowID ;
 If Not aLockUserID Is Null Then
   If aLockUserID &lt;&gt; auserID Then
     aisLocked := 4; /* CheckOut by another user */
     Return aislocked;
   Else
     aisLocked := 2; /* CheckOut by caller */
     Return aislocked;
   end if;
 End if;
 If Not aLockSessionID Is Null Then
   If aLockSessionID &lt;&gt; aCURSESSION Then
     aisLocked := 3 ;/* Lockes by another user */
     Return aislocked ;
   Else
     aisLocked := 1; /* Locked by caller */
     Return aislocked ;
   end if;
 End if;
 aisLocked := 0 ;
     Return aislocked ;
 End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_SINIT    (
aCURSESSION uuid,
aRowID uuid ,
 aSecurityStyleID uuid
)returns void as $$
 declare 
aParentTable varchar(255) ;
 aStyleID uuid ;
 atmpID uuid ;
 aaccess integer ;
 begin
  select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aROWID;
  If aSecurityStyleID Is Null Then
    select  objtype into aParentTable from instance where instanceid=aRowID ;
    select SecurityStyleID  into aStyleID from typelist where name =aParentTable ;
    update Instance set securitystyleid =aStyleID where Instanceid = aRowID;
  Else
    update Instance set securitystyleid =aSecurityStyleID where Instanceid = aRowID ;
  End if;
End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_LOCK     (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer
)returns void  as $$
 declare 
aUserID uuid;
 atmpID uuid;
 aaccess integer ;
 aIsLocked integer ;
 existsCnt integer;
  begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
If existsCnt = 0 Then
     perform  raise_application_error(-20000,'Сессия уже завершена.') ;
    Return ;
End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession;
 aaccess:= Instance_ISLOCKED (aCURSESSION,aROWID);
 if aIsLocked &gt;=3
  then
     perform  raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
 if aIsLocked =0
 then
  aisLocked:= Instance_HCL( acursession,aRowID);
  if aIsLocked &gt;=3
  then
      perform  raise_application_error(-20000,'У данного объекта имеются дочерние строки, которые заблокированы другим пользователем');
     Return ;
  End if;
 End if;
 select  SecurityStyleID into atmpid from INSTANCE where INSTANCEid=aROWID ;
   if  aLockMode =2
   then
    update INSTANCE  set LockUserID =auserID ,LockSessionID =null where Instanceid=aRowID ;
     Return ;
   End if ;
   if  aLockMode =1
   then
    update INSTANCE  set LockUserID =null,LockSessionID =aCURSESSION  where Instanceid=aRowID ;
     Return ;
   End if;
 End; $$ language 'plpgsql';
GO
create or replace function  INSTANCE_UNLOCK (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aUserID uuid ;
 aIsLocked integer ;
 aParentTable varchar(255);
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
if  existsCnt =0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    Return ;
  End if;
 aISLocked:= Instance_ISLOCKED( aCURSESSION,aROWID  );
 if aIsLocked &gt;=3
  then
     perform  raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
   if  aIsLocked =2
   then
    update INSTANCE set LockUserID =null  where Instanceid=aRowID ;
     Return ;
   End if;
   if  aIsLocked =1
   then
    update INSTANCE set LockSessionID =null  where Instanceid=aRowID;
     Return ;
   End if;
 End; $$ language 'plpgsql';
GO
  create or replace function  INSTANCE_BRIEF    (
 aCURSESSION uuid,
 ainstanceid uuid
) returns varchar as $$
 declare 
 aBRIEF  varchar(255);
 atmpStr varchar(255);
 aaccess int ;
 atmpBrief varchar(4000) ;
 atmpID uuid ;
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt  from  the_session where the_sessionid=acursession and closed=0;
If existsCnt = 0 Then
     perform  raise_application_error(-20000,'Сессия уже завершена.') ;
    Return '';
  End if;
If ainstanceid Is Null Then
     aBRIEF:='';
    return aBRIEF;
end if;
 -- Brief body --
  select count(*) into existsCnt  from instance where instanceID=ainstanceID;
If existsCnt = 1 Then
  select  instance_brief_F(instanceid) into aBrief from instance where instanceid=ainstanceid;
 Else
   aBRIEF:= 'неверный идентификатор';
End if;
    aBRIEF:=substr(aBRIEF,1,255);
    return aBRIEF;
End; $$ language 'plpgsql';
GO
  create or replace function  QR_AND_QR  ( aid1 uuid, aid2
    uuid,aidout uuid )returns integer 
as $$
declare
acnt integer;
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, a.result
from QueryResult a
join QueryResult b on b.QueryResultid=aid2 and a.result=b.result
where a.QueryResultid=aid1 ;
select count(*) into acnt from QueryResult where QueryResultid=aidout;
return acnt;
end; $$ language 'plpgsql';
GO
  create or replace function  QR_OR_QR  ( aid1 uuid, aid2 
    uuid,aidout uuid) returns integer 
as $$
declare
acnt integer;
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, result from QueryResult where QueryResultid in (aid1,aid2);
select count(*) into acnt from QueryResult where QueryResultid=aidout;
return acnt;
End; $$ language 'plpgsql';
GO
create or replace function  ROWPARENTS
(aQueryID   uuid
,aRowID uuid/* Row */
,aTable varchar /* Part Table Name */
,aCURSESSION uuid/* the_session */
) returns void as $$
 declare 
astr varchar(4000);
aplevel integer ;
aparent varchar(255) ;
aprev varchar(255) ;
atmpID  uuid ;
atmpRowID  uuid ;
existsCnt integer;
begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'the_session expired') ;
    Return ;
  End if;
aparent :=atable ;
atmpID := aROWID ;
aplevel :=0 ;
delete from RPRESULT where RPRESULTID
  =aQUERYID;
insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,atable,aRowID) ;
LOOP
 aplevel :=aplevel + 1 ;
 aprev := aparent ;
 begin
   select thevalue into aparent from sysoptions where optiontype ='PARENT' and  name=aprev ;
 exception when others then
   aparent := null ;
 end;
 if aparent is null
 then
     astr := 'select InstanceID  from ' || aprev || ' where ' || aprev || 'id=$1' ;
    execute  astr into atmpRowID using atmpid ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,'INSTANCE',atmpRowID);
   return;
 Else
    astr := 'select ParentStructRowID  from ' || aprev || ' where '  || aprev || 'id=$1' ;
    execute  astr into atmpRowID using atmpid ;
    atmpID := atmpROWID ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,aparent,atmpRowID) ;
 End if;
End LOOP;
End; $$ language 'plpgsql';
GO
  create or replace function  INSTANCE_STATUS    (
  aCURSESSION uuid,
  ainstanceid uuid,
  astatusid uuid) returns void 
as $$
 declare 
   aSSID uuid;
   atmpID uuid;
   aSysLogID uuid ;
   aaccess integer;
   aSysInstID uuid ;
   aObjType varchar(255) ;
   existsCnt integer;
  begin
   select Instanceid into aSysInstID from instance where objtype='MTZSystem' ;
   select count(*) into existsCnt from instance where instanceid=ainstanceid;
 If existsCnt = 1 Then
   aaccess:= instance_ISLOCKED( acursession,ainstanceid);
   If aaccess &gt; 2 Then
      perform  raise_application_error(-20000,'Документ заблокирован другим пльзователем.') ;
     Return ;
   End if;
   select objtype into aObjType from instance  where  instanceid=ainstanceid ;
   select count(*) into existsCnt from objstatus
  join objecttype on objstatus.parentstructrowid=objecttype.objecttypeid
  where objecttype.name=aobjtype and objstatusid=astatusid ;
   If existsCnt = 1 Then
     update instance set status = astatusid where  instanceid=ainstanceid ;
     select newid() into aSysLogid;
     PERFORM SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,    cast(aInstanceID as varchar),cast(aSTATUSID as varchar) ,
     'STATUS',   aInstanceID); 
   End if;
 End if;
End; $$ language 'plpgsql';
GO


;

 create or replace  function instance_BRIEF_F  (
 ainstanceid uuid
)returns varchar as  $$
 declare 
 aBRIEF varchar(4000);
 atmpCnt numeric;
 begin
if ainstanceid is null then aBRIEF:=''; return (aBRIEF); end if;
 -- Brief body --
select count(*) into aTmpCnt from instance where instanceID=ainstanceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select aBRIEF
  ||  COALESCE(Name,' ')||'; ' into aBrief
  from instance where  instanceID = ainstanceID;
else 
  aBRIEF:= 'неверный идентификатор';
End if;
 aBRIEF:=substr(aBRIEF,1,255);
  return (aBRIEF);
End; $$ language 'plpgsql';
GO


create or replace function MTZ2JOB_DEF_BRIEF_F  (
 aMTZ2JOB_DEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ2JOB_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(EventDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from MTZ2JOB_DEF  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 select aBRIEF 
  ||  COALESCE(cast(EvenType as varchar),' ') || ';' 
  into aBrief from MTZ2JOB_DEF  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FilterFieldGroup_BRIEF_F  (
 aFilterFieldGroupid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFilterFieldGroupid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from FilterFieldGroup  where  FilterFieldGroupID = aFilterFieldGroupID; 
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from FilterFieldGroup  where  FilterFieldGroupID = aFilterFieldGroupID; 
  select  aBRIEF ||
  (case AllowIgnore 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FileterField_BRIEF_F  (
 aFileterFieldid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFileterFieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FileterField where FileterFieldID=aFileterFieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from FileterField  where  FileterFieldID = aFileterFieldID; 
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from FileterField  where  FileterFieldID = aFileterFieldID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Filters_BRIEF_F  (
 aFiltersid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFiltersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Filters where FiltersID=aFiltersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Filters  where  FiltersID = aFiltersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function SrvMessageInfo_BRIEF_F  (
 aSrvMessageInfoid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSrvMessageInfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SrvMessageInfo where SrvMessageInfoID=aSrvMessageInfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select ForUser
 into atmpID  from SrvMessageInfo  where  SrvMessageInfoID = aSrvMessageInfoID ;
 atmpBrief :=  Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(to_char(msgDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from SrvMessageInfo  where  SrvMessageInfoID = aSrvMessageInfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function JournalColumn_BRIEF_F  (
 aJournalColumnid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aJournalColumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(name as varchar),' ') || ';' 
  into aBrief from JournalColumn  where  JournalColumnID = aJournalColumnID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function JColumnSource_BRIEF_F  (
 aJColumnSourceid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aJColumnSourceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ViewField as varchar),' ') || ';' 
  into aBrief from JColumnSource  where  JColumnSourceID = aJColumnSourceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Journal_BRIEF_F  (
 aJournalid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aJournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Journal where JournalID=aJournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Journal  where  JournalID = aJournalID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function JournalSrc_BRIEF_F  (
 aJournalSrcid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aJournalSrcid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(PartView as varchar),' ') || ';' 
  into aBrief from JournalSrc  where  JournalSrcID = aJournalSrcID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function StateAction_BRIEF_F  (
 aStateActionid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aStateActionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from StateAction where StateActionID=aStateActionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select OnDocStatus
 into atmpID  from StateAction  where  StateActionID = aStateActionID ;
 atmpBrief :=  OBJSTATUS_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_LOCKED_BRIEF_F  (
 aREPD_LOCKEDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_LOCKEDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_LOCKED where REPD_LOCKEDID=aREPD_LOCKEDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(StructType as varchar),' ') || ';' 
  into aBrief from REPD_LOCKED  where  REPD_LOCKEDID = aREPD_LOCKEDID; 
 select aBRIEF 
  ||  COALESCE(cast(ObjectType as varchar),' ') || ';' 
  into aBrief from REPD_LOCKED  where  REPD_LOCKEDID = aREPD_LOCKEDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_RequestQuery_BRIEF_F  (
 aREPD_RequestQueryid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_RequestQueryid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_RequestQuery where REPD_RequestQueryID=aREPD_RequestQueryID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select SourceSrv
 into atmpID  from REPD_RequestQuery  where  REPD_RequestQueryID = aREPD_RequestQueryID ;
 atmpBrief :=  REPD_SRV_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_ResQueryRcv_BRIEF_F  (
 aREPD_ResQueryRcvid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_ResQueryRcvid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_ResQueryRcv where REPD_ResQueryRcvID=aREPD_ResQueryRcvID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select ReceiveRec
 into atmpID  from REPD_ResQueryRcv  where  REPD_ResQueryRcvID = aREPD_ResQueryRcvID ;
 atmpBrief :=  REPD_RecvQ_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_PROV_BRIEF_F  (
 aREPD_PROVid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_PROVid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_PROV where REPD_PROVID=aREPD_PROVID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from REPD_PROV  where  REPD_PROVID = aREPD_PROVID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_SRV_BRIEF_F  (
 aREPD_SRVid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_SRVid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_SRV where REPD_SRVID=aREPD_SRVID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(name as varchar),' ') || ';' 
  into aBrief from REPD_SRV  where  REPD_SRVID = aREPD_SRVID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_SNDTO_BRIEF_F  (
 aREPD_SNDTOid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_SNDTOid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_SNDTO where REPD_SNDTOID=aREPD_SNDTOID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select DestSrv
 into atmpID  from REPD_SNDTO  where  REPD_SNDTOID = aREPD_SNDTOID ;
 atmpBrief :=  REPD_SRV_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_CONST_BRIEF_F  (
 aREPD_CONSTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_CONSTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_CONST where REPD_CONSTID=aREPD_CONSTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from REPD_CONST  where  REPD_CONSTID = aREPD_CONSTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_REPTYPE_BRIEF_F  (
 aREPD_REPTYPEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_REPTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_REPTYPE where REPD_REPTYPEID=aREPD_REPTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  (case ReplicaType 
 when 0
  then 'Весь документ'
 when 2
  then 'Локальный'
 when 1
  then 'Построчно'
 else '.' end ) into aBrief from REPD_REPTYPE where REPD_REPTYPEID=aREPD_REPTYPEID;
select TheObjectType
 into atmpID  from REPD_REPTYPE  where  REPD_REPTYPEID = aREPD_REPTYPEID ;
 atmpBrief :=  OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_SendQ_BRIEF_F  (
 aREPD_SendQid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_SendQid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_SendQ where REPD_SendQID=aREPD_SendQID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FileName as varchar),' ') || ';' 
  into aBrief from REPD_SendQ  where  REPD_SendQID = aREPD_SendQID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function REPD_RecvQ_BRIEF_F  (
 aREPD_RecvQid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aREPD_RecvQid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from REPD_RecvQ where REPD_RecvQID=aREPD_RecvQID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select SourceSrv
 into atmpID  from REPD_RecvQ  where  REPD_RecvQID = aREPD_RecvQID ;
 atmpBrief :=  REPD_SRV_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function invi_DEF_BRIEF_F  (
 ainvi_DEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if ainvi_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from invi_DEF where invi_DEFID=ainvi_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(OrderNum as varchar),' ') || ';' 
  into aBrief from invi_DEF  where  invi_DEFID = ainvi_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_PERSONS_BRIEF_F  (
 aINVI_PERSONSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_PERSONSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_PERSONS where INVI_PERSONSID=aINVI_PERSONSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ThePosition as varchar),' ') || ';' 
  into aBrief from INVI_PERSONS  where  INVI_PERSONSID = aINVI_PERSONSID; 
 select aBRIEF 
  ||  COALESCE(cast(FamiliName as varchar),' ') || ';' 
  into aBrief from INVI_PERSONS  where  INVI_PERSONSID = aINVI_PERSONSID; 
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVI_PERSONS  where  INVI_PERSONSID = aINVI_PERSONSID; 
 select aBRIEF 
  ||  COALESCE(cast(SurName as varchar),' ') || ';' 
  into aBrief from INVI_PERSONS  where  INVI_PERSONSID = aINVI_PERSONSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_BAD_BRIEF_F  (
 aINVI_BADid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_BADid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_BAD where INVI_BADID=aINVI_BADID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(SHCode as varchar),' ') || ';' 
  into aBrief from INVI_BAD  where  INVI_BADID = aINVI_BADID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_CHNG_BRIEF_F  (
 aINVI_CHNGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_CHNGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_CHNG where INVI_CHNGID=aINVI_CHNGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(SHCode as varchar),' ') || ';' 
  into aBrief from INVI_CHNG  where  INVI_CHNGID = aINVI_CHNGID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_OBJ_BRIEF_F  (
 aINVI_OBJid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_OBJid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_OBJ where INVI_OBJID=aINVI_OBJID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheOS
 into atmpID  from INVI_OBJ  where  INVI_OBJID = aINVI_OBJID ;
 atmpBrief :=  INVOS_INFO_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_DONE_BRIEF_F  (
 aINVI_DONEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_DONEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_DONE where INVI_DONEID=aINVI_DONEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(CheckDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVI_DONE  where  INVI_DONEID = aINVI_DONEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVI_UNK_BRIEF_F  (
 aINVI_UNKid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVI_UNKid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVI_UNK where INVI_UNKID=aINVI_UNKID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheRoom as varchar),' ') || ';' 
  into aBrief from INVI_UNK  where  INVI_UNKID = aINVI_UNKID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function STDJournlaExtInfo_BRIEF_F  (
 aSTDJournlaExtInfoid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSTDJournlaExtInfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STDJournlaExtInfo where STDJournlaExtInfoID=aSTDJournlaExtInfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from STDJournlaExtInfo  where  STDJournlaExtInfoID = aSTDJournlaExtInfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function STDJournalExtParam_BRIEF_F  (
 aSTDJournalExtParamid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSTDJournalExtParamid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STDJournalExtParam where STDJournalExtParamID=aSTDJournalExtParamID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FieldName as varchar),' ') || ';' 
  into aBrief from STDJournalExtParam  where  STDJournalExtParamID = aSTDJournalExtParamID; 
 select aBRIEF 
  ||  COALESCE(cast(ParamName as varchar),' ') || ';' 
  into aBrief from STDJournalExtParam  where  STDJournalExtParamID = aSTDJournalExtParamID; 
select TargetPlatform
 into atmpID  from STDJournalExtParam  where  STDJournalExtParamID = aSTDJournalExtParamID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function STDJournalExtFlt_BRIEF_F  (
 aSTDJournalExtFltid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSTDJournalExtFltid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STDJournalExtFlt where STDJournalExtFltID=aSTDJournalExtFltID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ViewSource as varchar),' ') || ';' 
  into aBrief from STDJournalExtFlt  where  STDJournalExtFltID = aSTDJournalExtFltID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function STDJournalExtField_BRIEF_F  (
 aSTDJournalExtFieldid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSTDJournalExtFieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STDJournalExtField where STDJournalExtFieldID=aSTDJournalExtFieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ViewField as varchar),' ') || ';' 
  into aBrief from STDJournalExtField  where  STDJournalExtFieldID = aSTDJournalExtFieldID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDTYPE_BRIEF_F  (
 aFIELDTYPEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from FIELDTYPE  where  FIELDTYPEID = aFIELDTYPEID; 
  select  aBRIEF ||
  (case TypeStyle 
 when 3
  then 'Интервал'
 when 5
  then 'Элемент оформления'
 when 0
  then 'Скалярный тип'
 when 4
  then 'Ссылка'
 when 2
  then 'Перечисление'
 when 1
  then 'Выражение'
 else '.' end ) into aBrief from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDTYPEMAP_BRIEF_F  (
 aFIELDTYPEMAPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDTYPEMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDTYPEMAP  where  FIELDTYPEMAPID = aFIELDTYPEMAPID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(StoageType as varchar),' ') || ';' 
  into aBrief from FIELDTYPEMAP  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ENUMITEM_BRIEF_F  (
 aENUMITEMid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aENUMITEMid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from ENUMITEM  where  ENUMITEMID = aENUMITEMID; 
 select aBRIEF 
  ||  COALESCE(cast(NameValue as varchar),' ') || ';' 
  into aBrief from ENUMITEM  where  ENUMITEMID = aENUMITEMID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function SHAREDMETHOD_BRIEF_F  (
 aSHAREDMETHODid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSHAREDMETHODid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from SHAREDMETHOD  where  SHAREDMETHODID = aSHAREDMETHODID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function SCRIPT_BRIEF_F  (
 aSCRIPTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSCRIPTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from SCRIPT  where  SCRIPTID = aSCRIPTID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PARAMETERS_BRIEF_F  (
 aPARAMETERSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARAMETERSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from PARAMETERS  where  PARAMETERSID = aPARAMETERSID; 
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from PARAMETERS  where  PARAMETERSID = aPARAMETERSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function OBJECTTYPE_BRIEF_F  (
 aOBJECTTYPEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aOBJECTTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Package
 into atmpID  from OBJECTTYPE  where  OBJECTTYPEID = aOBJECTTYPEID ;
 atmpBrief :=  MTZAPP_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(the_Comment as varchar),' ') || ';' 
  into aBrief from OBJECTTYPE  where  OBJECTTYPEID = aOBJECTTYPEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PART_BRIEF_F  (
 aPARTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PART where PARTID=aPARTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from PART  where  PARTID = aPARTID; 
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from PART  where  PARTID = aPARTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PARTMENU_BRIEF_F  (
 aPARTMENUid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARTMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from PARTMENU  where  PARTMENUID = aPARTMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PARTPARAMMAP_BRIEF_F  (
 aPARTPARAMMAPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARTPARAMMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FieldName as varchar),' ') || ';' 
  into aBrief from PARTPARAMMAP  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 select aBRIEF 
  ||  COALESCE(cast(ParamName as varchar),' ') || ';' 
  into aBrief from PARTPARAMMAP  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELD_BRIEF_F  (
 aFIELDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELD where FIELDID=aFIELDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from FIELD  where  FIELDID = aFIELDID; 
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from FIELD  where  FIELDID = aFIELDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDVALIDATOR_BRIEF_F  (
 aFIELDVALIDATORid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDVALIDATOR  where  FIELDVALIDATORID = aFIELDVALIDATORID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDMENU_BRIEF_F  (
 aFIELDMENUid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from FIELDMENU  where  FIELDMENUID = aFIELDMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDPARAMMAP_BRIEF_F  (
 aFIELDPARAMMAPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDPARAMMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FieldName as varchar),' ') || ';' 
  into aBrief from FIELDPARAMMAP  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 select aBRIEF 
  ||  COALESCE(cast(ParamName as varchar),' ') || ';' 
  into aBrief from FIELDPARAMMAP  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FldExtenders_BRIEF_F  (
 aFldExtendersid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFldExtendersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from FldExtenders  where  FldExtendersID = aFldExtendersID; 
select TargetPlatform
 into atmpID  from FldExtenders  where  FldExtendersID = aFldExtendersID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(TheObject as varchar),' ') || ';' 
  into aBrief from FldExtenders  where  FldExtendersID = aFldExtendersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDEXPRESSION_BRIEF_F  (
 aFIELDEXPRESSIONid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDEXPRESSIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDEXPRESSION  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function DINAMICFILTERSCRIPT_BRIEF_F  (
 aDINAMICFILTERSCRIPTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aDINAMICFILTERSCRIPTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from DINAMICFILTERSCRIPT  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDSRCDEF_BRIEF_F  (
 aFIELDSRCDEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDSRCDEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(DataSource as varchar),' ') || ';' 
  into aBrief from FIELDSRCDEF  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PARTVIEW_BRIEF_F  (
 aPARTVIEWid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARTVIEWid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from PARTVIEW  where  PARTVIEWID = aPARTVIEWID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ViewColumn_BRIEF_F  (
 aViewColumnid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aViewColumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ViewColumn where ViewColumnID=aViewColumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from ViewColumn  where  ViewColumnID = aViewColumnID; 
select FromPart
 into atmpID  from ViewColumn  where  ViewColumnID = aViewColumnID ;
 atmpBrief :=  PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  (case Aggregation 
 when 5
  then 'MAX'
 when 1
  then 'AVG'
 when 3
  then 'SUM'
 when 2
  then 'COUNT'
 when 4
  then 'MIN'
 when 6
  then 'CUSTOM'
 when 0
  then 'none'
 else '.' end ) into aBrief from ViewColumn where ViewColumnID=aViewColumnID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function PARTVIEW_LNK_BRIEF_F  (
 aPARTVIEW_LNKid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aPARTVIEW_LNKid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheView
 into atmpID  from PARTVIEW_LNK  where  PARTVIEW_LNKID = aPARTVIEW_LNKID ;
 atmpBrief :=  PARTVIEW_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ExtenderInterface_BRIEF_F  (
 aExtenderInterfaceid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aExtenderInterfaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID; 
select TargetPlatform
 into atmpID  from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(TheObject as varchar),' ') || ';' 
  into aBrief from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function VALIDATOR_BRIEF_F  (
 aVALIDATORid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from VALIDATOR  where  VALIDATORID = aVALIDATORID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function UNIQUECONSTRAINT_BRIEF_F  (
 aUNIQUECONSTRAINTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aUNIQUECONSTRAINTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from UNIQUECONSTRAINT  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
  select  aBRIEF ||
  (case PerParent 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function CONSTRAINTFIELD_BRIEF_F  (
 aCONSTRAINTFIELDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aCONSTRAINTFIELDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheField
 into atmpID  from CONSTRAINTFIELD  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID ;
 atmpBrief :=  FIELD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INSTANCEVALIDATOR_BRIEF_F  (
 aINSTANCEVALIDATORid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINSTANCEVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from INSTANCEVALIDATOR  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function OBJSTATUS_BRIEF_F  (
 aOBJSTATUSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aOBJSTATUSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(name as varchar),' ') || ';' 
  into aBrief from OBJSTATUS  where  OBJSTATUSID = aOBJSTATUSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function NEXTSTATE_BRIEF_F  (
 aNEXTSTATEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aNEXTSTATEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheState
 into atmpID  from NEXTSTATE  where  NEXTSTATEID = aNEXTSTATEID ;
 atmpBrief :=  OBJSTATUS_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function OBJECTMODE_BRIEF_F  (
 aOBJECTMODEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aOBJECTMODEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from OBJECTMODE  where  OBJECTMODEID = aOBJECTMODEID; 
  select  aBRIEF ||
  (case DefaultMode 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function STRUCTRESTRICTION_BRIEF_F  (
 aSTRUCTRESTRICTIONid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSTRUCTRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Struct
 into atmpID  from STRUCTRESTRICTION  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID ;
 atmpBrief :=  PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  (case AllowRead 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  (case AllowAdd 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  (case AllowEdit 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  (case AllowDelete 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function FIELDRESTRICTION_BRIEF_F  (
 aFIELDRESTRICTIONid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFIELDRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select ThePart
 into atmpID  from FIELDRESTRICTION  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID ;
 atmpBrief :=  PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
select TheField
 into atmpID  from FIELDRESTRICTION  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID ;
 atmpBrief :=  FIELD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  (case AllowRead 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
  select  aBRIEF ||
  (case AllowModify 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function METHODRESTRICTION_BRIEF_F  (
 aMETHODRESTRICTIONid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMETHODRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Method
 into atmpID  from METHODRESTRICTION  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID ;
 atmpBrief :=  SHAREDMETHOD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  (case IsRestricted 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function TYPEMENU_BRIEF_F  (
 aTYPEMENUid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aTYPEMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from TYPEMENU  where  TYPEMENUID = aTYPEMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZAPP_BRIEF_F  (
 aMTZAPPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZAPPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from MTZAPP  where  MTZAPPID = aMTZAPPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ParentPackage_BRIEF_F  (
 aParentPackageid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aParentPackageid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ParentPackage where ParentPackageID=aParentPackageID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Package
 into atmpID  from ParentPackage  where  ParentPackageID = aParentPackageID ;
 atmpBrief :=  MTZAPP_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GENPACKAGE_BRIEF_F  (
 aGENPACKAGEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGENPACKAGEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from GENPACKAGE  where  GENPACKAGEID = aGENPACKAGEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GENERATOR_TARGET_BRIEF_F  (
 aGENERATOR_TARGETid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGENERATOR_TARGETid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from GENERATOR_TARGET  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
  select  aBRIEF ||
  (case TargetType 
 when 0
  then 'СУБД'
 when 4
  then 'АРМ'
 when 3
  then 'Документация'
 when 1
  then 'МОДЕЛЬ'
 when 2
  then 'Приложение'
 else '.' end ) into aBrief from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GENMANUALCODE_BRIEF_F  (
 aGENMANUALCODEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGENMANUALCODEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from GENMANUALCODE  where  GENMANUALCODEID = aGENMANUALCODEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GENCONTROLS_BRIEF_F  (
 aGENCONTROLSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGENCONTROLSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ControlProgID as varchar),' ') || ';' 
  into aBrief from GENCONTROLS  where  GENCONTROLSID = aGENCONTROLSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GENREFERENCE_BRIEF_F  (
 aGENREFERENCEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGENREFERENCEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from GENREFERENCE  where  GENREFERENCEID = aGENREFERENCEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function LocalizeInfo_BRIEF_F  (
 aLocalizeInfoid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aLocalizeInfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(LangFull as varchar),' ') || ';' 
  into aBrief from LocalizeInfo  where  LocalizeInfoID = aLocalizeInfoID; 
 select aBRIEF 
  ||  COALESCE(cast(LangShort as varchar),' ') || ';' 
  into aBrief from LocalizeInfo  where  LocalizeInfoID = aLocalizeInfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Num_zones_BRIEF_F  (
 aNum_zonesid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aNum_zonesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_zones where Num_zonesID=aNum_zonesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ZoneMask as varchar),' ') || ';' 
  into aBrief from Num_zones  where  Num_zonesID = aNum_zonesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Num_Values_BRIEF_F  (
 aNum_Valuesid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aNum_Valuesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(the_Value as varchar),' ') || ';' 
  into aBrief from Num_Values  where  Num_ValuesID = aNum_ValuesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Num_head_BRIEF_F  (
 aNum_headid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aNum_headid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_head where Num_headID=aNum_headID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Num_head  where  Num_headID = aNum_headID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Ext_Photos_BRIEF_F  (
 aExt_Photosid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aExt_Photosid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Ext_Photos where Ext_PhotosID=aExt_PhotosID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from Ext_Photos  where  Ext_PhotosID = aExt_PhotosID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Ext_Photo_Call_BRIEF_F  (
 aExt_Photo_Callid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aExt_Photo_Callid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Ext_Photo_Call where Ext_Photo_CallID=aExt_Photo_CallID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TargetPlatform
 into atmpID  from Ext_Photo_Call  where  Ext_Photo_CallID = aExt_Photo_CallID ;
 atmpBrief :=  GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVF_DEF_BRIEF_F  (
 aINVF_DEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVF_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVF_DEF where INVF_DEFID=aINVF_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ThePath as varchar),' ') || ';' 
  into aBrief from INVF_DEF  where  INVF_DEFID = aINVF_DEFID; 
 select aBRIEF 
  ||  COALESCE(cast(TheHash as varchar),' ') || ';' 
  into aBrief from INVF_DEF  where  INVF_DEFID = aINVF_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZSEC_RIGHT_BRIEF_F  (
 aMTZSEC_RIGHTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZSEC_RIGHTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZSEC_RIGHT where MTZSEC_RIGHTID=aMTZSEC_RIGHTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheGroup
 into atmpID  from MTZSEC_RIGHT  where  MTZSEC_RIGHTID = aMTZSEC_RIGHTID ;
 atmpBrief :=  Groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(ProtectedItem as varchar),' ') || ';' 
  into aBrief from MTZSEC_RIGHT  where  MTZSEC_RIGHTID = aMTZSEC_RIGHTID; 
  select  aBRIEF ||
  (case Allow 
 when -1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from MTZSEC_RIGHT where MTZSEC_RIGHTID=aMTZSEC_RIGHTID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_RENT_BRIEF_F  (
 aINVOS_RENTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_RENTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_RENT where INVOS_RENTID=aINVOS_RENTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(StartDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_RENT  where  INVOS_RENTID = aINVOS_RENTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_HIST_BRIEF_F  (
 aINVOS_HISTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_HISTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_HIST where INVOS_HISTID=aINVOS_HISTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(ComplNumber as varchar),' ') || ';' 
  into aBrief from INVOS_HIST  where  INVOS_HISTID = aINVOS_HISTID; 
select TheOwner
 into atmpID  from INVOS_HIST  where  INVOS_HISTID = aINVOS_HISTID ;
 atmpBrief :=  INVD_OWNER_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_OFFRULE_BRIEF_F  (
 aINVOS_OFFRULEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_OFFRULEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_OFFRULE where INVOS_OFFRULEID=aINVOS_OFFRULEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(INFO as varchar),' ') || ';' 
  into aBrief from INVOS_OFFRULE  where  INVOS_OFFRULEID = aINVOS_OFFRULEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_SROK_BRIEF_F  (
 aINVOS_SROKid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_SROKid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_SROK where INVOS_SROKID=aINVOS_SROKID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(RecalcDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_SROK  where  INVOS_SROKID = aINVOS_SROKID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_TECH_BRIEF_F  (
 aINVOS_TECHid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_TECHid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_TECH where INVOS_TECHID=aINVOS_TECHID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Computer_Name as varchar),' ') || ';' 
  into aBrief from INVOS_TECH  where  INVOS_TECHID = aINVOS_TECHID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_WINSOFT_BRIEF_F  (
 aINVOS_WINSOFTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_WINSOFTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_WINSOFT where INVOS_WINSOFTID=aINVOS_WINSOFTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_WINSOFT  where  INVOS_WINSOFTID = aINVOS_WINSOFTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_COMP_BRIEF_F  (
 aINVOS_COMPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_COMPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_COMP where INVOS_COMPID=aINVOS_COMPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_COMP  where  INVOS_COMPID = aINVOS_COMPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_HARD_BRIEF_F  (
 aINVOS_HARDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_HARDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_HARD where INVOS_HARDID=aINVOS_HARDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_HARD  where  INVOS_HARDID = aINVOS_HARDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_CURCFG_BRIEF_F  (
 aINVOS_CURCFGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_CURCFGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_CURCFG where INVOS_CURCFGID=aINVOS_CURCFGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_CURCFG  where  INVOS_CURCFGID = aINVOS_CURCFGID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_CFGCH_BRIEF_F  (
 aINVOS_CFGCHid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_CFGCHid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_CFGCH where INVOS_CFGCHID=aINVOS_CFGCHID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(ChDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_CFGCH  where  INVOS_CFGCHID = aINVOS_CFGCHID; 
 select aBRIEF 
  ||  COALESCE(cast(ChNum as varchar),' ') || ';' 
  into aBrief from INVOS_CFGCH  where  INVOS_CFGCHID = aINVOS_CFGCHID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_DEVICES_BRIEF_F  (
 aINVOS_DEVICESid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_DEVICESid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_DEVICES where INVOS_DEVICESID=aINVOS_DEVICESID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_DEVICES  where  INVOS_DEVICESID = aINVOS_DEVICESID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_DRAG_BRIEF_F  (
 aINVOS_DRAGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_DRAGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_DRAG where INVOS_DRAGID=aINVOS_DRAGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select DragMet
 into atmpID  from INVOS_DRAG  where  INVOS_DRAGID = aINVOS_DRAGID ;
 atmpBrief :=  INVD_DRAG_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_DOCS_BRIEF_F  (
 aINVOS_DOCSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_DOCSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_DOCS where INVOS_DOCSID=aINVOS_DOCSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_INV_BRIEF_F  (
 aINVOS_INVid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_INVid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_INV where INVOS_INVID=aINVOS_INVID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Inventory
 into atmpID  from INVOS_INV  where  INVOS_INVID = aINVOS_INVID ;
 atmpBrief :=  invi_DEF_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_LIZING_BRIEF_F  (
 aINVOS_LIZINGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_LIZINGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_LIZING where INVOS_LIZINGID=aINVOS_LIZINGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(DocNumber as varchar),' ') || ';' 
  into aBrief from INVOS_LIZING  where  INVOS_LIZINGID = aINVOS_LIZINGID; 
 select aBRIEF 
  ||  COALESCE(to_char(TheDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_LIZING  where  INVOS_LIZINGID = aINVOS_LIZINGID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_CNSRV_BRIEF_F  (
 aINVOS_CNSRVid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_CNSRVid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_CNSRV where INVOS_CNSRVID=aINVOS_CNSRVID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(DocNumber as varchar),' ') || ';' 
  into aBrief from INVOS_CNSRV  where  INVOS_CNSRVID = aINVOS_CNSRVID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_INFO_BRIEF_F  (
 aINVOS_INFOid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_INFOid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_INFO where INVOS_INFOID=aINVOS_INFOID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheOrg
 into atmpID  from INVOS_INFO  where  INVOS_INFOID = aINVOS_INFOID ;
 atmpBrief :=  INVD_ORG_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
select OSType
 into atmpID  from INVOS_INFO  where  INVOS_INFOID = aINVOS_INFOID ;
 atmpBrief :=  INVD_OSTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVOS_INFO  where  INVOS_INFOID = aINVOS_INFOID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_MOD_BRIEF_F  (
 aINVOS_MODid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_MODid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_MOD where INVOS_MODID=aINVOS_MODID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(DocNumber as varchar),' ') || ';' 
  into aBrief from INVOS_MOD  where  INVOS_MODID = aINVOS_MODID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_CMNT_BRIEF_F  (
 aINVOS_CMNTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_CMNTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_CMNT where INVOS_CMNTID=aINVOS_CMNTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(TheDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_CMNT  where  INVOS_CMNTID = aINVOS_CMNTID; 
 select aBRIEF 
  ||  COALESCE(cast(Info as varchar),' ') || ';' 
  into aBrief from INVOS_CMNT  where  INVOS_CMNTID = aINVOS_CMNTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_CODE_BRIEF_F  (
 aINVOS_CODEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_CODEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_CODE where INVOS_CODEID=aINVOS_CODEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(VisibleCode as varchar),' ') || ';' 
  into aBrief from INVOS_CODE  where  INVOS_CODEID = aINVOS_CODEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_REPAIR_BRIEF_F  (
 aINVOS_REPAIRid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_REPAIRid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_REPAIR where INVOS_REPAIRID=aINVOS_REPAIRID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(to_char(StartDate,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from INVOS_REPAIR  where  INVOS_REPAIRID = aINVOS_REPAIRID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVOS_PLACE_BRIEF_F  (
 aINVOS_PLACEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVOS_PLACEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVOS_PLACE where INVOS_PLACEID=aINVOS_PLACEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Reports_BRIEF_F  (
 aReportsid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aReportsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Reports where ReportsID=aReportsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Reports  where  ReportsID = aReportsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function RPTStruct_BRIEF_F  (
 aRPTStructid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aRPTStructid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTStruct where RPTStructID=aRPTStructID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from RPTStruct  where  RPTStructID = aRPTStructID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function RPTFields_BRIEF_F  (
 aRPTFieldsid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aRPTFieldsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from RPTFields  where  RPTFieldsID = aRPTFieldsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function RPTFormula_BRIEF_F  (
 aRPTFormulaid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aRPTFormulaid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from RPTFormula  where  RPTFormulaID = aRPTFormulaID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Users_BRIEF_F  (
 aUsersid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aUsersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Users where UsersID=aUsersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Family as varchar),' ') || ';' 
  into aBrief from Users  where  UsersID = aUsersID; 
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Users  where  UsersID = aUsersID; 
 select aBRIEF 
  ||  COALESCE(cast(SurName as varchar),' ') || ';' 
  into aBrief from Users  where  UsersID = aUsersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Groups_BRIEF_F  (
 aGroupsid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGroupsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Groups where GroupsID=aGroupsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Groups  where  GroupsID = aGroupsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function GroupUser_BRIEF_F  (
 aGroupUserid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aGroupUserid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GroupUser where GroupUserID=aGroupUserID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheUser
 into atmpID  from GroupUser  where  GroupUserID = aGroupUserID ;
 atmpBrief :=  Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function SysLog_BRIEF_F  (
 aSysLogid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aSysLogid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SysLog where SysLogID=aSysLogID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheSession
 into atmpID  from SysLog  where  SysLogID = aSysLogID ;
 atmpBrief :=  the_Session_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  COALESCE(cast(LogStructID as varchar),' ') || ';' 
  into aBrief from SysLog  where  SysLogID = aSysLogID; 
 select aBRIEF 
  ||  COALESCE(cast(VERB as varchar),' ') || ';' 
  into aBrief from SysLog  where  SysLogID = aSysLogID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function the_Session_BRIEF_F  (
 athe_Sessionid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if athe_Sessionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from the_Session where the_SessionID=athe_SessionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select UserRole
 into atmpID  from the_Session  where  the_SessionID = athe_SessionID ;
 atmpBrief :=  Groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  (case Closed 
 when 1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from the_Session where the_SessionID=athe_SessionID;
select Usersid
 into atmpID  from the_Session  where  the_SessionID = athe_SessionID ;
 atmpBrief :=  Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function LogReader_BRIEF_F  (
 aLogReaderid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aLogReaderid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from LogReader where LogReaderID=aLogReaderID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from LogReader  where  LogReaderID = aLogReaderID; 
 select aBRIEF 
  ||  COALESCE(to_char(ReadMarker,'DD.MM.YYYY HH24:MI:SS'),' ') || ';' 
  into aBrief from LogReader  where  LogReaderID = aLogReaderID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Verb_BRIEF_F  (
 aVerbid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aVerbid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Verb where VerbID=aVerbID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Verb  where  VerbID = aVerbID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_USER_BRIEF_F  (
 aROLES_USERid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_USERid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheUser
 into atmpID  from ROLES_USER  where  ROLES_USERID = aROLES_USERID ;
 atmpBrief :=  Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_MAP_BRIEF_F  (
 aROLES_MAPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_MAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheGroup
 into atmpID  from ROLES_MAP  where  ROLES_MAPID = aROLES_MAPID ;
 atmpBrief :=  Groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_DOC_BRIEF_F  (
 aROLES_DOCid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_DOCid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_Document
 into atmpID  from ROLES_DOC  where  ROLES_DOCID = aROLES_DOCID ;
 atmpBrief :=  OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_DOC_STATE_BRIEF_F  (
 aROLES_DOC_STATEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_DOC_STATEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_State
 into atmpID  from ROLES_DOC_STATE  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID ;
 atmpBrief :=  OBJSTATUS_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
select The_Mode
 into atmpID  from ROLES_DOC_STATE  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID ;
 atmpBrief :=  OBJECTMODE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_DEF_BRIEF_F  (
 aROLES_DEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(name as varchar),' ') || ';' 
  into aBrief from ROLES_DEF  where  ROLES_DEFID = aROLES_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_REPORTS_BRIEF_F  (
 aROLES_REPORTSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_REPORTSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_Report
 into atmpID  from ROLES_REPORTS  where  ROLES_REPORTSID = aROLES_REPORTSID ;
 atmpBrief:=  Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_WP_BRIEF_F  (
 aROLES_WPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_WPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select WP
 into atmpID  from ROLES_WP  where  ROLES_WPID = aROLES_WPID ;
 atmpBrief:=  Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ROLES_ACT_BRIEF_F  (
 aROLES_ACTid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aROLES_ACTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  (case Accesible 
 when 1
  then 'Да'
 when 0
  then 'Нет'
 else '.' end ) into aBrief from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
select EntryPoints
 into atmpID  from ROLES_ACT  where  ROLES_ACTID = aROLES_ACTID ;
 atmpBrief :=  EntryPoints_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function WorkPlace_BRIEF_F  (
 aWorkPlaceid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aWorkPlaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from WorkPlace  where  WorkPlaceID = aWorkPlaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function EntryPoints_BRIEF_F  (
 aEntryPointsid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aEntryPointsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from EntryPoints  where  EntryPointsID = aEntryPointsID; 
 select aBRIEF 
  ||  COALESCE(cast(Caption as varchar),' ') || ';' 
  into aBrief from EntryPoints  where  EntryPointsID = aEntryPointsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function EPFilterLink_BRIEF_F  (
 aEPFilterLinkid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aEPFilterLinkid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(RowSource as varchar),' ') || ';' 
  into aBrief from EPFilterLink  where  EPFilterLinkID = aEPFilterLinkID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ARMTypes_BRIEF_F  (
 aARMTypesid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aARMTypesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMTypes where ARMTypesID=aARMTypesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheDocumentType
 into atmpID  from ARMTypes  where  ARMTypesID = aARMTypesID ;
 atmpBrief :=  OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ARMJournal_BRIEF_F  (
 aARMJournalid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aARMJournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJournal where ARMJournalID=aARMJournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheJournal
 into atmpID  from ARMJournal  where  ARMJournalID = aARMJournalID ;
 atmpBrief:=  Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ARMJRNLADD_BRIEF_F  (
 aARMJRNLADDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aARMJRNLADDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from ARMJRNLADD  where  ARMJRNLADDID = aARMJRNLADDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ARMJRNLREP_BRIEF_F  (
 aARMJRNLREPid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aARMJRNLREPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(repname as varchar),' ') || ';' 
  into aBrief from ARMJRNLREP  where  ARMJRNLREPID = aARMJRNLREPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function ARMJRNLRUN_BRIEF_F  (
 aARMJRNLRUNid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aARMJRNLRUNid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from ARMJRNLRUN  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_UPR_BRIEF_F  (
 aINVD_UPRid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_UPRid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_UPR where INVD_UPRID=aINVD_UPRID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_UPR  where  INVD_UPRID = aINVD_UPRID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_OTDEL_BRIEF_F  (
 aINVD_OTDELid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_OTDELid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_OTDEL where INVD_OTDELID=aINVD_OTDELID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_OTDEL  where  INVD_OTDELID = aINVD_OTDELID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_BLD_BRIEF_F  (
 aINVD_BLDid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_BLDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_BLD where INVD_BLDID=aINVD_BLDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_BLD  where  INVD_BLDID = aINVD_BLDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_DRAG_BRIEF_F  (
 aINVD_DRAGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_DRAGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_DRAG where INVD_DRAGID=aINVD_DRAGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_DRAG  where  INVD_DRAGID = aINVD_DRAGID; 
 select aBRIEF 
  ||  COALESCE(cast(edIzm as varchar),' ') || ';' 
  into aBrief from INVD_DRAG  where  INVD_DRAGID = aINVD_DRAGID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_ORG_BRIEF_F  (
 aINVD_ORGid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_ORGid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_ORG where INVD_ORGID=aINVD_ORGID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FullName as varchar),' ') || ';' 
  into aBrief from INVD_ORG  where  INVD_ORGID = aINVD_ORGID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_OSSTATUS_BRIEF_F  (
 aINVD_OSSTATUSid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_OSSTATUSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_OSSTATUS where INVD_OSSTATUSID=aINVD_OSSTATUSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_OSSTATUS  where  INVD_OSSTATUSID = aINVD_OSSTATUSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_OWNER_BRIEF_F  (
 aINVD_OWNERid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_OWNERid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_OWNER where INVD_OWNERID=aINVD_OWNERID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FamiliName as varchar),' ') || ';' 
  into aBrief from INVD_OWNER  where  INVD_OWNERID = aINVD_OWNERID; 
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_OWNER  where  INVD_OWNERID = aINVD_OWNERID; 
 select aBRIEF 
  ||  COALESCE(cast(SurName as varchar),' ') || ';' 
  into aBrief from INVD_OWNER  where  INVD_OWNERID = aINVD_OWNERID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_UR_BRIEF_F  (
 aINVD_URid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_URid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_UR where INVD_URID=aINVD_URID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(FullName as varchar),' ') || ';' 
  into aBrief from INVD_UR  where  INVD_URID = aINVD_URID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_OSTYPE_BRIEF_F  (
 aINVD_OSTYPEid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_OSTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_OSTYPE where INVD_OSTYPEID=aINVD_OSTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_OSTYPE  where  INVD_OSTYPEID = aINVD_OSTYPEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVD_DIR_BRIEF_F  (
 aINVD_DIRid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVD_DIRid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVD_DIR where INVD_DIRID=aINVD_DIRID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from INVD_DIR  where  INVD_DIRID = aINVD_DIRID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZ_Inst_Build_BRIEF_F  (
 aMTZ_Inst_Buildid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ_Inst_Buildid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ_Inst_Build where MTZ_Inst_BuildID=aMTZ_Inst_BuildID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(PRODUCT_NAME as varchar),' ') || ';' 
  into aBrief from MTZ_Inst_Build  where  MTZ_Inst_BuildID = aMTZ_Inst_BuildID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZ_Inst_Build_Sec_BRIEF_F  (
 aMTZ_Inst_Build_Secid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ_Inst_Build_Secid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ_Inst_Build_Sec where MTZ_Inst_Build_SecID=aMTZ_Inst_Build_SecID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheSection
 into atmpID  from MTZ_Inst_Build_Sec  where  MTZ_Inst_Build_SecID = aMTZ_Inst_Build_SecID ;
 atmpBrief :=  MTZ_Inst_Section_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZ_Inst_Section_BRIEF_F  (
 aMTZ_Inst_Sectionid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ_Inst_Sectionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ_Inst_Section where MTZ_Inst_SectionID=aMTZ_Inst_SectionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from MTZ_Inst_Section  where  MTZ_Inst_SectionID = aMTZ_Inst_SectionID; 
  select  aBRIEF ||
  (case TheTargetPlatform 
 when 2
  then 'JAVA'
 when 3
  then 'OTHER'
 when 1
  then 'DOTNET'
 when 0
  then 'VB6'
 else '.' end ) into aBrief from MTZ_Inst_Section where MTZ_Inst_SectionID=aMTZ_Inst_SectionID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZ_Inst_Sec_Files_BRIEF_F  (
 aMTZ_Inst_Sec_Filesid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ_Inst_Sec_Filesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_FilesID=aMTZ_Inst_Sec_FilesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheSource as varchar),' ') || ';' 
  into aBrief from MTZ_Inst_Sec_Files  where  MTZ_Inst_Sec_FilesID = aMTZ_Inst_Sec_FilesID; 
select SysstemObject
 into atmpID  from MTZ_Inst_Sec_Files  where  MTZ_Inst_Sec_FilesID = aMTZ_Inst_Sec_FilesID ;
 atmpBrief :=  OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
select TheApplication
 into atmpID  from MTZ_Inst_Sec_Files  where  MTZ_Inst_Sec_FilesID = aMTZ_Inst_Sec_FilesID ;
 atmpBrief :=  MTZAPP_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZ_Inst_Common_BRIEF_F  (
 aMTZ_Inst_Commonid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZ_Inst_Commonid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ_Inst_Common where MTZ_Inst_CommonID=aMTZ_Inst_CommonID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheName as varchar),' ') || ';' 
  into aBrief from MTZ_Inst_Common  where  MTZ_Inst_CommonID = aMTZ_Inst_CommonID; 
 select aBRIEF 
  ||  COALESCE(cast(SEQ as varchar),' ') || ';' 
  into aBrief from MTZ_Inst_Common  where  MTZ_Inst_CommonID = aMTZ_Inst_CommonID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function InfoStoreDef_BRIEF_F  (
 aInfoStoreDefid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aInfoStoreDefid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from InfoStoreDef  where  InfoStoreDefID = aInfoStoreDefID; 
  select  aBRIEF ||
  (case InfoStoreType 
 when 2
  then 'Групповой'
 when 1
  then 'Персональный'
 when 0
  then ' Общий'
 else '.' end ) into aBrief from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Folder_BRIEF_F  (
 aFolderid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aFolderid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Folder where FolderID=aFolderID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from Folder  where  FolderID = aFolderID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function Shortcut_BRIEF_F  (
 aShortcutid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aShortcutid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Shortcut where ShortcutID=aShortcutID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select DocItem
 into atmpID  from Shortcut  where  ShortcutID = aShortcutID ;
 atmpBrief:=  Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZExt_def_BRIEF_F  (
 aMTZExt_defid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZExt_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(Name as varchar),' ') || ';' 
  into aBrief from MTZExt_def  where  MTZExt_defID = aMTZExt_defID; 
  select  aBRIEF ||
  (case ExtType 
 when 1
  then 'OnFormExt'
 when 7
  then 'CodeGenerator'
 when 3
  then 'JrnlAddExt'
 when 6
  then 'VerifyRowExt'
 when 0
  then 'StatusExt'
 when 8
  then 'ARMGenerator'
 when 5
  then 'DefaultExt'
 when 2
  then 'CustomExt'
 when 4
  then 'JrnlRunExt'
 else '.' end ) into aBrief from MTZExt_def where MTZExt_defID=aMTZExt_defID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function MTZExtRel_BRIEF_F  (
 aMTZExtRelid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aMTZExtRelid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  (case ThePlatform 
 when 2
  then 'JAVA'
 when 3
  then 'OTHER'
 when 1
  then 'DOTNET'
 when 0
  then 'VB6'
 else '.' end ) into aBrief from MTZExtRel where MTZExtRelID=aMTZExtRelID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO



create or replace function INVN_DEF_BRIEF_F  (
 aINVN_DEFid uuid
) returns varchar as $$ 
 declare 
 aBRIEF varchar(255);
 atmpStr varchar(255);
 atmpBrief varchar(2000);
 atmpID uuid;
 atmpCnt Numeric;
 begin  
if aINVN_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INVN_DEF where INVN_DEFID=aINVN_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  COALESCE(cast(TheNumber as varchar),' ') || ';' 
  into aBrief from INVN_DEF  where  INVN_DEFID = aINVN_DEFID; 
select TheOrg
 into atmpID  from INVN_DEF  where  INVN_DEFID = aINVN_DEFID ;
 atmpBrief :=  INVD_ORG_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || COALESCE(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--functions.Type.Body" File=""><BlockHolder BlockName="--body" BlockCode=" 

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZ2JOB" BlockCode=" create or replace function  MTZ2JOB_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZ2JOB'
then
Open aCurs  for select MTZ2JOB_DEF.MTZ2JOB_DEFid ID from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ2JOB_DEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ2JOB_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZ2JOB'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select MTZ2JOB_DEF.MTZ2JOB_DEFid ID from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZ2JOB_DEF_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ2JOB_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZ2JOB'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select MTZ2JOB_DEF.MTZ2JOB_DEFid id from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ2JOB_DEF_SINIT( acursession,aid,assid);
 PERFORM MTZ2JOB_DEF_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  MTZ2JOB_DEF_BRIEF  (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ2JOB_DEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ2JOB_DEF_BRIEF_F(aMTZ2JOB_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_DELETE /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ2JOB_DEF_ISLOCKED( acursession,aMTZ2JOB_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ2JOB_DEFid as varchar),   'MTZ2JOB_DEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ2JOB_DEF' and OwnerRowID=aMTZ2JOB_DEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ2JOB_DEF 
  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отложенное событие*/
 create or replace function  MTZ2JOB_DEF_SAVE /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aMTZ2JOB_DEFid uuid,
ainstanceid uuid 
,aEventDate
 timestamp/* Отложено до *//* Отложено до */
,aEvenType
 VARCHAR/* Тип события *//* Тип события */
,aThruObject
 uuid/* Объект - причина события *//* Объект - причина события */
,aThruState
 uuid/* Состояние - причина *//* Состояние - причина */
,aNextState
 uuid/* Состояние после обработки *//* Состояние после обработки */
,aProcessDate
 timestamp/* Момент обработки *//* Момент обработки */
,aProcessed
 INTEGER/* Обработан *//* Обработан */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ2JOB_DEF_ISLOCKED( acursession,aMTZ2JOB_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ2JOB_DEFid as varchar),  'MTZ2JOB_DEF',
 'EDITROW',  aInstanceID);
 update  MTZ2JOB_DEF set ChangeStamp=localtimestamp
,
  EventDate=aEventDate
,
  EvenType=aEvenType
,
  ThruObject=aThruObject
,
  ThruState=aThruState
,
  NextState=aNextState
,
  ProcessDate=aProcessDate
,
  Processed=aProcessed
  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ2JOB_DEFid as varchar),  'MTZ2JOB_DEF',
 'CREATEROW',  aInstanceID);
 insert into   MTZ2JOB_DEF
 (  MTZ2JOB_DEFID 
,InstanceID
,EventDate

,EvenType

,ThruObject

,ThruState

,NextState

,ProcessDate

,Processed

 ) values ( aMTZ2JOB_DEFID 
,aInstanceID
,aEventDate

,aEvenType

,aThruObject

,aThruState

,aNextState

,aProcessDate

,aProcessed

 ); 
 PERFORM MTZ2JOB_DEF_SINIT( aCURSESSION,aMTZ2JOB_DEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ2JOB_DEF_PARENT_T /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ2JOB_DEF_PARENT_ID /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZ2JOB_DEF where  MTZ2JOB_DEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_ISLOCKED /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_LOCK /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ2JOB_DEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ2JOB_DEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ2JOB_DEF set LockUserID =auserID ,LockSessionID =null where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ2JOB_DEF set LockUserID =null,LockSessionID =aCURSESSION  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_HCL /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_UNLOCK /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ2JOB_DEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ2JOB_DEF set LockUserID =null  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ2JOB_DEF set LockSessionID =null  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_SINIT /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ2JOB_DEF_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ2JOB_DEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ2JOB_DEF set securitystyleid =aStyleID where MTZ2JOB_DEFid = aRowID;
else 
 update MTZ2JOB_DEF set securitystyleid =aSecurityStyleID where MTZ2JOB_DEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ2JOB_DEF_propagate /*Описание отложенного события*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZFltr" BlockCode=" create or replace function  MTZFltr_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZFltr'
then
Open aCurs  for select FilterFieldGroup.FilterFieldGroupid ID from FilterFieldGroup where  FilterFieldGroup.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM FilterFieldGroup_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Filters.Filtersid ID from Filters where  Filters.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Filters_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZFltr_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZFltr'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select FilterFieldGroup.FilterFieldGroupid ID from FilterFieldGroup where  FilterFieldGroup.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from FilterFieldGroup where FilterFieldGroupid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= FilterFieldGroup_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Filters.Filtersid ID from Filters where  Filters.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Filters where Filtersid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Filters_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZFltr_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZFltr'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select FilterFieldGroup.FilterFieldGroupid id from FilterFieldGroup where  FilterFieldGroup.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM FilterFieldGroup_SINIT( acursession,aid,assid);
 PERFORM FilterFieldGroup_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Filters.Filtersid id from Filters where  Filters.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Filters_SINIT( acursession,aid,assid);
 PERFORM Filters_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  FilterFieldGroup_BRIEF  (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFilterFieldGroupid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0
 then
  aBRIEF:= FilterFieldGroup_BRIEF_F(aFilterFieldGroupid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_DELETE /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FilterFieldGroup_ISLOCKED( acursession,aFilterFieldGroupid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FilterFieldGroup');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aFilterFieldGroupid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FileterField_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFilterFieldGroupid as varchar),   'FilterFieldGroup',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FilterFieldGroup' and OwnerRowID=aFilterFieldGroupid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FilterFieldGroup 
  where  FilterFieldGroupID = aFilterFieldGroupID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Группа полей фильтра*/
 create or replace function  FilterFieldGroup_SAVE /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aFilterFieldGroupid uuid,
ainstanceid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aAllowIgnore
 INTEGER/* Можно отключать *//* Можно отключать */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FilterFieldGroup_ISLOCKED( acursession,aFilterFieldGroupid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FilterFieldGroup');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFilterFieldGroupid as varchar),  'FilterFieldGroup',
 'EDITROW',  aInstanceID);
 update  FilterFieldGroup set ChangeStamp=localtimestamp
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  AllowIgnore=aAllowIgnore
  where  FilterFieldGroupID = aFilterFieldGroupID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FilterFieldGroup');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFilterFieldGroupid as varchar),  'FilterFieldGroup',
 'CREATEROW',  aInstanceID);
 insert into   FilterFieldGroup
 (  FilterFieldGroupID 
,InstanceID
,sequence

,Name

,Caption

,AllowIgnore

 ) values ( aFilterFieldGroupID 
,aInstanceID
,asequence

,aName

,aCaption

,aAllowIgnore

 ); 
 PERFORM FilterFieldGroup_SINIT( aCURSESSION,aFilterFieldGroupid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FilterFieldGroup_PARENT_T /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FilterFieldGroup_PARENT_ID /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from FilterFieldGroup where  FilterFieldGroupid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_ISLOCKED /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FilterFieldGroup where FilterFieldGroupid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_LOCK /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FilterFieldGroup_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FilterFieldGroup_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FilterFieldGroup set LockUserID =auserID ,LockSessionID =null where FilterFieldGroupid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FilterFieldGroup set LockUserID =null,LockSessionID =aCURSESSION  where FilterFieldGroupid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_HCL /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FileterField where FileterFieldid=row_FileterField.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FileterField_HCL (acursession,row_FileterField.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_UNLOCK /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FilterFieldGroup_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FilterFieldGroup set LockUserID =null  where FilterFieldGroupid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FilterFieldGroup set LockSessionID =null  where FilterFieldGroupid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_SINIT /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FilterFieldGroup_parent_T( aCURSESSION,aROWID);
 aParentID:= FilterFieldGroup_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FilterFieldGroup set securitystyleid =aStyleID where FilterFieldGroupid = aRowID;
else 
 update FilterFieldGroup set securitystyleid =aSecurityStyleID where FilterFieldGroupid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FilterFieldGroup_propagate /*Группа полей фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FilterFieldGroup where FilterFieldGroupid=aRowid;
open aCurs for select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FileterField_SINIT( acursession,aid,assid);
 PERFORM  FileterField_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  FileterField_BRIEF  (
 aCURSESSION uuid,
 aFileterFieldid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFileterFieldid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0
 then
  aBRIEF:= FileterField_BRIEF_F(aFileterFieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FileterField_DELETE /*Поле фильтра*/ (
 aCURSESSION uuid,
 aFileterFieldid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FileterField_ISLOCKED( acursession,aFileterFieldid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FileterField');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFileterFieldid as varchar),   'FileterField',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FileterField' and OwnerRowID=aFileterFieldid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FileterField 
  where  FileterFieldID = aFileterFieldID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Поле фильтра*/
 create or replace function  FileterField_SAVE /*Поле фильтра*/ (
 aCURSESSION uuid,
 aFileterFieldid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aFieldSize
 integer/* Размер *//* Размер */
,aRefType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,aRefToPart
 uuid/* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,aValueArray
 INTEGER/* Массив значений *//* Массив значений */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FileterField_ISLOCKED( acursession,aFileterFieldid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FileterField');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFileterFieldid as varchar),  'FileterField',
 'EDITROW',  aInstanceID);
 update  FileterField set ChangeStamp=localtimestamp
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  FieldType=aFieldType
,
  FieldSize=aFieldSize
,
  RefType=aRefType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
,
  ValueArray=aValueArray
  where  FileterFieldID = aFileterFieldID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FilterFieldGroup_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FileterField');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFileterFieldid as varchar),  'FileterField',
 'CREATEROW',  aInstanceID);
 insert into   FileterField
 (  FileterFieldID 
,ParentStructRowID
,sequence

,Name

,Caption

,FieldType

,FieldSize

,RefType

,RefToType

,RefToPart

,ValueArray

 ) values ( aFileterFieldID 
,aParentStructRowID
,asequence

,aName

,aCaption

,aFieldType

,aFieldSize

,aRefType

,aRefToType

,aRefToPart

,aValueArray

 ); 
 PERFORM FileterField_SINIT( aCURSESSION,aFileterFieldid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FileterField_PARENT_T /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FilterFieldGroup';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FileterField_PARENT_ID /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FileterField where  FileterFieldid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FileterField_ISLOCKED /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FileterField where FileterFieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FileterField_LOCK /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FileterField_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FileterField_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FileterField set LockUserID =auserID ,LockSessionID =null where FileterFieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FileterField set LockUserID =null,LockSessionID =aCURSESSION  where FileterFieldid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FileterField_HCL /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FileterField_UNLOCK /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FileterField_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FileterField set LockUserID =null  where FileterFieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FileterField set LockSessionID =null  where FileterFieldid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FileterField_SINIT /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FileterField_parent_T( aCURSESSION,aROWID);
 aParentID:= FileterField_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FileterField set securitystyleid =aStyleID where FileterFieldid = aRowID;
else 
 update FileterField set securitystyleid =aSecurityStyleID where FileterFieldid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FileterField_propagate /*Поле фильтра*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FileterField where FileterFieldid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Filters_BRIEF  (
 aCURSESSION uuid,
 aFiltersid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFiltersid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0
 then
  aBRIEF:= Filters_BRIEF_F(aFiltersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Filters_DELETE /*Фильтр*/ (
 aCURSESSION uuid,
 aFiltersid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Filters_ISLOCKED( acursession,aFiltersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Filters');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='Filters' and OwnerRowID=aFiltersid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Filters 
  where  FiltersID = aFiltersID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Фильтр*/
 create or replace function  Filters_SAVE /*Фильтр*/ (
 aCURSESSION uuid,
 aFiltersid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Filters_ISLOCKED( acursession,aFiltersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Filters');
    return;
  end if;
 -- update row  --
 update  Filters set ChangeStamp=localtimestamp
,
  Name=aName
,
  TheCaption=aTheCaption
,
  TheComment=aTheComment
  where  FiltersID = aFiltersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Filters');
    return;
  end if;
select Count(*) into existsCnt from Filters where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Filters&gt;');
    return;
 End if;
 insert into   Filters
 (  FiltersID 
,InstanceID
,Name

,TheCaption

,TheComment

 ) values ( aFiltersID 
,aInstanceID
,aName

,aTheCaption

,aTheComment

 ); 
 PERFORM Filters_SINIT( aCURSESSION,aFiltersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Filters_PARENT_T /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Filters_PARENT_ID /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Filters where  Filtersid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Filters_ISLOCKED /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Filters where Filtersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Filters_LOCK /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Filters_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Filters_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Filters set LockUserID =auserID ,LockSessionID =null where Filtersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Filters set LockUserID =null,LockSessionID =aCURSESSION  where Filtersid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Filters_HCL /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Filters_UNLOCK /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Filters_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Filters set LockUserID =null  where Filtersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Filters set LockSessionID =null  where Filtersid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Filters_SINIT /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Filters_parent_T( aCURSESSION,aROWID);
 aParentID:= Filters_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Filters set securitystyleid =aStyleID where Filtersid = aRowID;
else 
 update Filters set securitystyleid =aSecurityStyleID where Filtersid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Filters_propagate /*Фильтр*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Filters where Filtersid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSrvMsg" BlockCode=" create or replace function  MTZSrvMsg_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZSrvMsg'
then
Open aCurs  for select SrvMessageInfo.SrvMessageInfoid ID from SrvMessageInfo where  SrvMessageInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SrvMessageInfo_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSrvMsg_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZSrvMsg'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select SrvMessageInfo.SrvMessageInfoid ID from SrvMessageInfo where  SrvMessageInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SrvMessageInfo where SrvMessageInfoid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= SrvMessageInfo_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSrvMsg_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZSrvMsg'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select SrvMessageInfo.SrvMessageInfoid id from SrvMessageInfo where  SrvMessageInfo.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SrvMessageInfo_SINIT( acursession,aid,assid);
 PERFORM SrvMessageInfo_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  SrvMessageInfo_BRIEF  (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSrvMessageInfoid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from SrvMessageInfo where SrvMessageInfoID=aSrvMessageInfoID;
if existsCnt &gt;0
 then
  aBRIEF:= SrvMessageInfo_BRIEF_F(aSrvMessageInfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_DELETE /*Суть сообщения*/ (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SrvMessageInfo where SrvMessageInfoID=aSrvMessageInfoID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  SrvMessageInfo_ISLOCKED( acursession,aSrvMessageInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SrvMessageInfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='SrvMessageInfo' and OwnerRowID=aSrvMessageInfoid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  SrvMessageInfo 
  where  SrvMessageInfoID = aSrvMessageInfoID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Суть сообщения*/
 create or replace function  SrvMessageInfo_SAVE /*Суть сообщения*/ (
 aCURSESSION uuid,
 aSrvMessageInfoid uuid,
ainstanceid uuid 
,aForUser
 uuid/* Для пользователя *//* Для пользователя */
,amsgDate
 timestamp/* Дата *//* Дата */
,aMsgInfo
 TEXT/* Текст сообщения *//* Текст сообщения */
,aTheDocument
 uuid/* Документ *//* Документ */
,aReadTime
 timestamp/* Время прочтения *//* Время прочтения */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SrvMessageInfo where SrvMessageInfoID=aSrvMessageInfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  SrvMessageInfo_ISLOCKED( acursession,aSrvMessageInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SrvMessageInfo');
    return;
  end if;
 -- update row  --
 update  SrvMessageInfo set ChangeStamp=localtimestamp
,
  ForUser=aForUser
,
  msgDate=amsgDate
,
  MsgInfo=aMsgInfo
,
  TheDocument=aTheDocument
,
  ReadTime=aReadTime
  where  SrvMessageInfoID = aSrvMessageInfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SrvMessageInfo');
    return;
  end if;
select Count(*) into existsCnt from SrvMessageInfo where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;SrvMessageInfo&gt;');
    return;
 End if;
 insert into   SrvMessageInfo
 (  SrvMessageInfoID 
,InstanceID
,ForUser

,msgDate

,MsgInfo

,TheDocument

,ReadTime

 ) values ( aSrvMessageInfoID 
,aInstanceID
,aForUser

,amsgDate

,aMsgInfo

,aTheDocument

,aReadTime

 ); 
 PERFORM SrvMessageInfo_SINIT( aCURSESSION,aSrvMessageInfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  SrvMessageInfo_PARENT_T /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  SrvMessageInfo_PARENT_ID /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from SrvMessageInfo where  SrvMessageInfoid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_ISLOCKED /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SrvMessageInfo where SrvMessageInfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_LOCK /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= SrvMessageInfo_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= SrvMessageInfo_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update SrvMessageInfo set LockUserID =auserID ,LockSessionID =null where SrvMessageInfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SrvMessageInfo set LockUserID =null,LockSessionID =aCURSESSION  where SrvMessageInfoid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_HCL /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_UNLOCK /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= SrvMessageInfo_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SrvMessageInfo set LockUserID =null  where SrvMessageInfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SrvMessageInfo set LockSessionID =null  where SrvMessageInfoid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_SINIT /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=SrvMessageInfo_parent_T( aCURSESSION,aROWID);
 aParentID:= SrvMessageInfo_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update SrvMessageInfo set securitystyleid =aStyleID where SrvMessageInfoid = aRowID;
else 
 update SrvMessageInfo set securitystyleid =aSecurityStyleID where SrvMessageInfoid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  SrvMessageInfo_propagate /*Суть сообщения*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from SrvMessageInfo where SrvMessageInfoid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZJrnl" BlockCode=" create or replace function  MTZJrnl_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZJrnl'
then
Open aCurs  for select JournalColumn.JournalColumnid ID from JournalColumn where  JournalColumn.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM JournalColumn_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Journal.Journalid ID from Journal where  Journal.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Journal_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select JournalSrc.JournalSrcid ID from JournalSrc where  JournalSrc.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM JournalSrc_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZJrnl_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZJrnl'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select JournalColumn.JournalColumnid ID from JournalColumn where  JournalColumn.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from JournalColumn where JournalColumnid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= JournalColumn_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Journal.Journalid ID from Journal where  Journal.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Journal where Journalid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Journal_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select JournalSrc.JournalSrcid ID from JournalSrc where  JournalSrc.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from JournalSrc where JournalSrcid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= JournalSrc_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZJrnl_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZJrnl'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select JournalColumn.JournalColumnid id from JournalColumn where  JournalColumn.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM JournalColumn_SINIT( acursession,aid,assid);
 PERFORM JournalColumn_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Journal.Journalid id from Journal where  Journal.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Journal_SINIT( acursession,aid,assid);
 PERFORM Journal_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select JournalSrc.JournalSrcid id from JournalSrc where  JournalSrc.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM JournalSrc_SINIT( acursession,aid,assid);
 PERFORM JournalSrc_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  JournalColumn_BRIEF  (
 aCURSESSION uuid,
 aJournalColumnid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aJournalColumnid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0
 then
  aBRIEF:= JournalColumn_BRIEF_F(aJournalColumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_DELETE /*Колонки журнала*/ (
 aCURSESSION uuid,
 aJournalColumnid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  JournalColumn_ISLOCKED( acursession,aJournalColumnid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JournalColumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aJournalColumnid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  JColumnSource_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aJournalColumnid as varchar),   'JournalColumn',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='JournalColumn' and OwnerRowID=aJournalColumnid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  JournalColumn 
  where  JournalColumnID = aJournalColumnID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Колонки журнала*/
 create or replace function  JournalColumn_SAVE /*Колонки журнала*/ (
 aCURSESSION uuid,
 aJournalColumnid uuid,
ainstanceid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aname
 VARCHAR/* Название *//* Название */
,aColumnAlignment
 integer/* Выравнивание *//* Выравнивание */
,aColSort
 INTEGER/* Сортировка колонки *//* Сортировка колонки */
,aGroupAggregation
 INTEGER/* Аггрегация при группировке *//* Аггрегация при группировке */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  JournalColumn_ISLOCKED( acursession,aJournalColumnid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalColumn');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aJournalColumnid as varchar),  'JournalColumn',
 'EDITROW',  aInstanceID);
 update  JournalColumn set ChangeStamp=localtimestamp
,
  sequence=asequence
,
  name=aname
,
  ColumnAlignment=aColumnAlignment
,
  ColSort=aColSort
,
  GroupAggregation=aGroupAggregation
  where  JournalColumnID = aJournalColumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalColumn');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aJournalColumnid as varchar),  'JournalColumn',
 'CREATEROW',  aInstanceID);
 insert into   JournalColumn
 (  JournalColumnID 
,InstanceID
,sequence

,name

,ColumnAlignment

,ColSort

,GroupAggregation

 ) values ( aJournalColumnID 
,aInstanceID
,asequence

,aname

,aColumnAlignment

,aColSort

,aGroupAggregation

 ); 
 PERFORM JournalColumn_SINIT( aCURSESSION,aJournalColumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  JournalColumn_PARENT_T /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  JournalColumn_PARENT_ID /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from JournalColumn where  JournalColumnid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_ISLOCKED /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JournalColumn where JournalColumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_LOCK /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= JournalColumn_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= JournalColumn_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update JournalColumn set LockUserID =auserID ,LockSessionID =null where JournalColumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JournalColumn set LockUserID =null,LockSessionID =aCURSESSION  where JournalColumnid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_HCL /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from JColumnSource where JColumnSourceid=row_JColumnSource.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= JColumnSource_HCL (acursession,row_JColumnSource.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  JournalColumn_UNLOCK /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= JournalColumn_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JournalColumn set LockUserID =null  where JournalColumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JournalColumn set LockSessionID =null  where JournalColumnid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_SINIT /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=JournalColumn_parent_T( aCURSESSION,aROWID);
 aParentID:= JournalColumn_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update JournalColumn set securitystyleid =aStyleID where JournalColumnid = aRowID;
else 
 update JournalColumn set securitystyleid =aSecurityStyleID where JournalColumnid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  JournalColumn_propagate /*Колонки журнала*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from JournalColumn where JournalColumnid=aRowid;
open aCurs for select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  JColumnSource_SINIT( acursession,aid,assid);
 PERFORM  JColumnSource_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  JColumnSource_BRIEF  (
 aCURSESSION uuid,
 aJColumnSourceid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aJColumnSourceid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0
 then
  aBRIEF:= JColumnSource_BRIEF_F(aJColumnSourceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_DELETE /*Состав колонки*/ (
 aCURSESSION uuid,
 aJColumnSourceid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  JColumnSource_ISLOCKED( acursession,aJColumnSourceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JColumnSource');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aJColumnSourceid as varchar),   'JColumnSource',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='JColumnSource' and OwnerRowID=aJColumnSourceid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  JColumnSource 
  where  JColumnSourceID = aJColumnSourceID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Состав колонки*/
 create or replace function  JColumnSource_SAVE /*Состав колонки*/ (
 aCURSESSION uuid,
 aJColumnSourceid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aSrcPartView
 uuid/* Представление *//* Представление */
,aViewField
 VARCHAR/* Поле представления *//* Поле представления */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  JColumnSource_ISLOCKED( acursession,aJColumnSourceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JColumnSource');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aJColumnSourceid as varchar),  'JColumnSource',
 'EDITROW',  aInstanceID);
 update  JColumnSource set ChangeStamp=localtimestamp
,
  SrcPartView=aSrcPartView
,
  ViewField=aViewField
  where  JColumnSourceID = aJColumnSourceID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from JColumnSource where ParentStructRowID=aParentStructRowID 
 and SrcPartView=aSrcPartView;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JColumnSource');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= JournalColumn_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JColumnSource');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aJColumnSourceid as varchar),  'JColumnSource',
 'CREATEROW',  aInstanceID);
 insert into   JColumnSource
 (  JColumnSourceID 
,ParentStructRowID
,SrcPartView

,ViewField

 ) values ( aJColumnSourceID 
,aParentStructRowID
,aSrcPartView

,aViewField

 ); 
 PERFORM JColumnSource_SINIT( aCURSESSION,aJColumnSourceid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from JColumnSource where ParentStructRowID=aParentStructRowID 
 and SrcPartView=aSrcPartView;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JColumnSource');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  JColumnSource_PARENT_T /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'JournalColumn';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  JColumnSource_PARENT_ID /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from JColumnSource where  JColumnSourceid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_ISLOCKED /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JColumnSource where JColumnSourceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_LOCK /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= JColumnSource_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= JColumnSource_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update JColumnSource set LockUserID =auserID ,LockSessionID =null where JColumnSourceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JColumnSource set LockUserID =null,LockSessionID =aCURSESSION  where JColumnSourceid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_HCL /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  JColumnSource_UNLOCK /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= JColumnSource_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JColumnSource set LockUserID =null  where JColumnSourceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JColumnSource set LockSessionID =null  where JColumnSourceid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_SINIT /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=JColumnSource_parent_T( aCURSESSION,aROWID);
 aParentID:= JColumnSource_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update JColumnSource set securitystyleid =aStyleID where JColumnSourceid = aRowID;
else 
 update JColumnSource set securitystyleid =aSecurityStyleID where JColumnSourceid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  JColumnSource_propagate /*Состав колонки*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from JColumnSource where JColumnSourceid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Journal_BRIEF  (
 aCURSESSION uuid,
 aJournalid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aJournalid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0
 then
  aBRIEF:= Journal_BRIEF_F(aJournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Journal_DELETE /*Журнал*/ (
 aCURSESSION uuid,
 aJournalid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Journal_ISLOCKED( acursession,aJournalid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Journal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aJournalid as varchar),   'Journal',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Journal' and OwnerRowID=aJournalid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Journal 
  where  JournalID = aJournalID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Журнал*/
 create or replace function  Journal_SAVE /*Журнал*/ (
 aCURSESSION uuid,
 aJournalid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Journal_ISLOCKED( acursession,aJournalid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Journal');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aJournalid as varchar),  'Journal',
 'EDITROW',  aInstanceID);
 update  Journal set ChangeStamp=localtimestamp
,
  Name=aName
,
  the_Alias=athe_Alias
,
  TheComment=aTheComment
  where  JournalID = aJournalID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Journal where 1=1  
 and the_Alias=athe_Alias;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Journal');
    return;
  end if;
select Count(*) into existsCnt from Journal where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Journal&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aJournalid as varchar),  'Journal',
 'CREATEROW',  aInstanceID);
 insert into   Journal
 (  JournalID 
,InstanceID
,Name

,the_Alias

,TheComment

 ) values ( aJournalID 
,aInstanceID
,aName

,athe_Alias

,aTheComment

 ); 
 PERFORM Journal_SINIT( aCURSESSION,aJournalid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Journal where 1=1  
 and the_Alias=athe_Alias;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Journal_PARENT_T /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Journal_PARENT_ID /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Journal where  Journalid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Journal_ISLOCKED /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Journal where Journalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Journal_LOCK /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Journal_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Journal_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Journal set LockUserID =auserID ,LockSessionID =null where Journalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Journal set LockUserID =null,LockSessionID =aCURSESSION  where Journalid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Journal_HCL /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Journal_UNLOCK /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Journal_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Journal set LockUserID =null  where Journalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Journal set LockSessionID =null  where Journalid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Journal_SINIT /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Journal_parent_T( aCURSESSION,aROWID);
 aParentID:= Journal_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Journal set securitystyleid =aStyleID where Journalid = aRowID;
else 
 update Journal set securitystyleid =aSecurityStyleID where Journalid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Journal_propagate /*Журнал*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Journal where Journalid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  JournalSrc_BRIEF  (
 aCURSESSION uuid,
 aJournalSrcid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aJournalSrcid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0
 then
  aBRIEF:= JournalSrc_BRIEF_F(aJournalSrcid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_DELETE /*Источники журнала*/ (
 aCURSESSION uuid,
 aJournalSrcid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  JournalSrc_ISLOCKED( acursession,aJournalSrcid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JournalSrc');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aJournalSrcid as varchar),   'JournalSrc',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='JournalSrc' and OwnerRowID=aJournalSrcid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  JournalSrc 
  where  JournalSrcID = aJournalSrcID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Источники журнала*/
 create or replace function  JournalSrc_SAVE /*Источники журнала*/ (
 aCURSESSION uuid,
 aJournalSrcid uuid,
ainstanceid uuid 
,aPartView
 uuid/* Представление *//* Представление */
,aOnRun
 INTEGER/* При открытии *//* При открытии */
,aOpenMode
 VARCHAR/* Режим открытия *//* Режим открытия */
,aViewAlias
 VARCHAR/* Псевдоним представления *//* Псевдоним представления */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  JournalSrc_ISLOCKED( acursession,aJournalSrcid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalSrc');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aJournalSrcid as varchar),  'JournalSrc',
 'EDITROW',  aInstanceID);
 update  JournalSrc set ChangeStamp=localtimestamp
,
  PartView=aPartView
,
  OnRun=aOnRun
,
  OpenMode=aOpenMode
,
  ViewAlias=aViewAlias
  where  JournalSrcID = aJournalSrcID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from JournalSrc where InstanceID=aInstanceID 
 and PartView=aPartView;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JournalSrc');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalSrc');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aJournalSrcid as varchar),  'JournalSrc',
 'CREATEROW',  aInstanceID);
 insert into   JournalSrc
 (  JournalSrcID 
,InstanceID
,PartView

,OnRun

,OpenMode

,ViewAlias

 ) values ( aJournalSrcID 
,aInstanceID
,aPartView

,aOnRun

,aOpenMode

,aViewAlias

 ); 
 PERFORM JournalSrc_SINIT( aCURSESSION,aJournalSrcid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from JournalSrc where InstanceID=aInstanceID 
 and PartView=aPartView;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JournalSrc');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  JournalSrc_PARENT_T /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  JournalSrc_PARENT_ID /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from JournalSrc where  JournalSrcid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_ISLOCKED /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JournalSrc where JournalSrcid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_LOCK /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= JournalSrc_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= JournalSrc_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update JournalSrc set LockUserID =auserID ,LockSessionID =null where JournalSrcid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JournalSrc set LockUserID =null,LockSessionID =aCURSESSION  where JournalSrcid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_HCL /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  JournalSrc_UNLOCK /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= JournalSrc_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JournalSrc set LockUserID =null  where JournalSrcid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JournalSrc set LockSessionID =null  where JournalSrcid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_SINIT /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=JournalSrc_parent_T( aCURSESSION,aROWID);
 aParentID:= JournalSrc_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update JournalSrc set securitystyleid =aStyleID where JournalSrcid = aRowID;
else 
 update JournalSrc set securitystyleid =aSecurityStyleID where JournalSrcid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  JournalSrc_propagate /*Источники журнала*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from JournalSrc where JournalSrcid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZStateSrv" BlockCode=" create or replace function  MTZStateSrv_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZStateSrv'
then
Open aCurs  for select StateAction.StateActionid ID from StateAction where  StateAction.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM StateAction_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZStateSrv_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZStateSrv'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select StateAction.StateActionid ID from StateAction where  StateAction.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from StateAction where StateActionid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= StateAction_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZStateSrv_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZStateSrv'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select StateAction.StateActionid id from StateAction where  StateAction.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM StateAction_SINIT( acursession,aid,assid);
 PERFORM StateAction_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  StateAction_BRIEF  (
 aCURSESSION uuid,
 aStateActionid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aStateActionid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from StateAction where StateActionID=aStateActionID;
if existsCnt &gt;0
 then
  aBRIEF:= StateAction_BRIEF_F(aStateActionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  StateAction_DELETE /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aStateActionid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from StateAction where StateActionID=aStateActionID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  StateAction_ISLOCKED( acursession,aStateActionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=StateAction');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aStateActionid as varchar),   'StateAction',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='StateAction' and OwnerRowID=aStateActionid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  StateAction 
  where  StateActionID = aStateActionID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Дейсвие при смене*/
 create or replace function  StateAction_SAVE /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aStateActionid uuid,
ainstanceid uuid 
,aOnDocStatus
 uuid/* При входе в состояие *//* При входе в состояие */
,aNewSecurityStyle
 uuid/* Установить стиль защиты *//* Установить стиль защиты */
,aClearSecurity
 INTEGER/* Сбросить стиль защиты *//* Сбросить стиль защиты */
,aLibraryFile
 VARCHAR/* Библиотека-обработчик *//* Библиотека-обработчик */
,aActionClass
 VARCHAR/* Класс для обработки *//* Класс для обработки */
,aActionScript
 TEXT/* Скрипт для исполнения *//* Скрипт для исполнения */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from StateAction where StateActionID=aStateActionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  StateAction_ISLOCKED( acursession,aStateActionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=StateAction');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aStateActionid as varchar),  'StateAction',
 'EDITROW',  aInstanceID);
 update  StateAction set ChangeStamp=localtimestamp
,
  OnDocStatus=aOnDocStatus
,
  NewSecurityStyle=aNewSecurityStyle
,
  ClearSecurity=aClearSecurity
,
  LibraryFile=aLibraryFile
,
  ActionClass=aActionClass
,
  ActionScript=aActionScript
  where  StateActionID = aStateActionID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from StateAction where 1=1  
 and OnDocStatus=aOnDocStatus;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=StateAction');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=StateAction');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aStateActionid as varchar),  'StateAction',
 'CREATEROW',  aInstanceID);
 insert into   StateAction
 (  StateActionID 
,InstanceID
,OnDocStatus

,NewSecurityStyle

,ClearSecurity

,LibraryFile

,ActionClass

,ActionScript

 ) values ( aStateActionID 
,aInstanceID
,aOnDocStatus

,aNewSecurityStyle

,aClearSecurity

,aLibraryFile

,aActionClass

,aActionScript

 ); 
 PERFORM StateAction_SINIT( aCURSESSION,aStateActionid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from StateAction where 1=1  
 and OnDocStatus=aOnDocStatus;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=StateAction');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  StateAction_PARENT_T /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  StateAction_PARENT_ID /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from StateAction where  StateActionid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  StateAction_ISLOCKED /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from StateAction where StateActionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  StateAction_LOCK /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= StateAction_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= StateAction_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update StateAction set LockUserID =auserID ,LockSessionID =null where StateActionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update StateAction set LockUserID =null,LockSessionID =aCURSESSION  where StateActionid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  StateAction_HCL /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  StateAction_UNLOCK /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= StateAction_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update StateAction set LockUserID =null  where StateActionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update StateAction set LockSessionID =null  where StateActionid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  StateAction_SINIT /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=StateAction_parent_T( aCURSESSION,aROWID);
 aParentID:= StateAction_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update StateAction set securitystyleid =aStyleID where StateActionid = aRowID;
else 
 update StateAction set securitystyleid =aSecurityStyleID where StateActionid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  StateAction_propagate /*Дейсвие при смене*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from StateAction where StateActionid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--REPD" BlockCode=" create or replace function  REPD_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='REPD'
then
Open aCurs  for select REPD_LOCKED.REPD_LOCKEDid ID from REPD_LOCKED where  REPD_LOCKED.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_LOCKED_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select REPD_RequestQuery.REPD_RequestQueryid ID from REPD_RequestQuery where  REPD_RequestQuery.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_RequestQuery_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select REPD_PROV.REPD_PROVid ID from REPD_PROV where  REPD_PROV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_PROV_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select REPD_SRV.REPD_SRVid ID from REPD_SRV where  REPD_SRV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_SRV_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select REPD_SendQ.REPD_SendQid ID from REPD_SendQ where  REPD_SendQ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_SendQ_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select REPD_RecvQ.REPD_RecvQid ID from REPD_RecvQ where  REPD_RecvQ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_RecvQ_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'REPD'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select REPD_LOCKED.REPD_LOCKEDid ID from REPD_LOCKED where  REPD_LOCKED.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_LOCKED where REPD_LOCKEDid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_LOCKED_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select REPD_RequestQuery.REPD_RequestQueryid ID from REPD_RequestQuery where  REPD_RequestQuery.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_RequestQuery where REPD_RequestQueryid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_RequestQuery_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select REPD_PROV.REPD_PROVid ID from REPD_PROV where  REPD_PROV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_PROV where REPD_PROVid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_PROV_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select REPD_SRV.REPD_SRVid ID from REPD_SRV where  REPD_SRV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_SRV where REPD_SRVid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_SRV_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select REPD_SendQ.REPD_SendQid ID from REPD_SendQ where  REPD_SendQ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_SendQ where REPD_SendQid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_SendQ_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select REPD_RecvQ.REPD_RecvQid ID from REPD_RecvQ where  REPD_RecvQ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from REPD_RecvQ where REPD_RecvQid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= REPD_RecvQ_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  REPD_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'REPD'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select REPD_LOCKED.REPD_LOCKEDid id from REPD_LOCKED where  REPD_LOCKED.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_LOCKED_SINIT( acursession,aid,assid);
 PERFORM REPD_LOCKED_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select REPD_RequestQuery.REPD_RequestQueryid id from REPD_RequestQuery where  REPD_RequestQuery.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_RequestQuery_SINIT( acursession,aid,assid);
 PERFORM REPD_RequestQuery_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select REPD_PROV.REPD_PROVid id from REPD_PROV where  REPD_PROV.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_PROV_SINIT( acursession,aid,assid);
 PERFORM REPD_PROV_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select REPD_SRV.REPD_SRVid id from REPD_SRV where  REPD_SRV.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_SRV_SINIT( acursession,aid,assid);
 PERFORM REPD_SRV_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select REPD_SendQ.REPD_SendQid id from REPD_SendQ where  REPD_SendQ.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_SendQ_SINIT( acursession,aid,assid);
 PERFORM REPD_SendQ_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select REPD_RecvQ.REPD_RecvQid id from REPD_RecvQ where  REPD_RecvQ.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM REPD_RecvQ_SINIT( acursession,aid,assid);
 PERFORM REPD_RecvQ_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  REPD_LOCKED_BRIEF  (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_LOCKEDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_LOCKED where REPD_LOCKEDID=aREPD_LOCKEDID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_LOCKED_BRIEF_F(aREPD_LOCKEDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_DELETE /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_LOCKED where REPD_LOCKEDID=aREPD_LOCKEDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_LOCKED_ISLOCKED( acursession,aREPD_LOCKEDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_LOCKED');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_LOCKEDid as varchar),   'REPD_LOCKED',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_LOCKED' and OwnerRowID=aREPD_LOCKEDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_LOCKED 
  where  REPD_LOCKEDID = aREPD_LOCKEDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Очередь заблокированных объектов*/
 create or replace function  REPD_LOCKED_SAVE /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aREPD_LOCKEDid uuid,
ainstanceid uuid 
,aLastTry
 timestamp/* Последняя разработка *//* Последняя разработка */
,aSourceFile
 VARCHAR/* Файл данных *//* Файл данных */
,aReplicaRowID
 uuid/* Идентификатор строки реплики *//* Идентификатор строки реплики */
,aFirstTry
 timestamp/* Первая обработка *//* Первая обработка */
,aStructType
 VARCHAR/* Тип строки *//* Тип строки */
,aObjectType
 VARCHAR/* Тип объекта *//* Тип объекта */
,aThe_RowID
 uuid/* Идетнификатор строки *//* Идетнификатор строки */
,aThe_InstanceID
 uuid/* Объект *//* Объект */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aPartCount
 integer/* PartCount *//* PartCount */
,aPartNumber
 integer/* PartNumber *//* PartNumber */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_LOCKED where REPD_LOCKEDID=aREPD_LOCKEDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_LOCKED_ISLOCKED( acursession,aREPD_LOCKEDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_LOCKED');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_LOCKEDid as varchar),  'REPD_LOCKED',
 'EDITROW',  aInstanceID);
 update  REPD_LOCKED set ChangeStamp=localtimestamp
,
  LastTry=aLastTry
,
  SourceFile=aSourceFile
,
  ReplicaRowID=aReplicaRowID
,
  FirstTry=aFirstTry
,
  StructType=aStructType
,
  ObjectType=aObjectType
,
  The_RowID=aThe_RowID
,
  The_InstanceID=aThe_InstanceID
,
  ReplicaPackID=aReplicaPackID
,
  PartCount=aPartCount
,
  PartNumber=aPartNumber
  where  REPD_LOCKEDID = aREPD_LOCKEDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_LOCKED');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_LOCKEDid as varchar),  'REPD_LOCKED',
 'CREATEROW',  aInstanceID);
 insert into   REPD_LOCKED
 (  REPD_LOCKEDID 
,InstanceID
,LastTry

,SourceFile

,ReplicaRowID

,FirstTry

,StructType

,ObjectType

,The_RowID

,The_InstanceID

,ReplicaPackID

,PartCount

,PartNumber

 ) values ( aREPD_LOCKEDID 
,aInstanceID
,aLastTry

,aSourceFile

,aReplicaRowID

,aFirstTry

,aStructType

,aObjectType

,aThe_RowID

,aThe_InstanceID

,aReplicaPackID

,aPartCount

,aPartNumber

 ); 
 PERFORM REPD_LOCKED_SINIT( aCURSESSION,aREPD_LOCKEDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_LOCKED_PARENT_T /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_LOCKED_PARENT_ID /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_LOCKED where  REPD_LOCKEDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_ISLOCKED /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_LOCKED where REPD_LOCKEDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_LOCK /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_LOCKED_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_LOCKED_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_LOCKED set LockUserID =auserID ,LockSessionID =null where REPD_LOCKEDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_LOCKED set LockUserID =null,LockSessionID =aCURSESSION  where REPD_LOCKEDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_HCL /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_UNLOCK /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_LOCKED_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_LOCKED set LockUserID =null  where REPD_LOCKEDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_LOCKED set LockSessionID =null  where REPD_LOCKEDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_SINIT /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_LOCKED_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_LOCKED_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_LOCKED set securitystyleid =aStyleID where REPD_LOCKEDid = aRowID;
else 
 update REPD_LOCKED set securitystyleid =aSecurityStyleID where REPD_LOCKEDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_LOCKED_propagate /*Очередь заблокированных объектов*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_LOCKED where REPD_LOCKEDid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_RequestQuery_BRIEF  (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_RequestQueryid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_RequestQuery where REPD_RequestQueryID=aREPD_RequestQueryID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_RequestQuery_BRIEF_F(aREPD_RequestQueryid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_DELETE /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_RequestQuery where REPD_RequestQueryID=aREPD_RequestQueryID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_RequestQuery_ISLOCKED( acursession,aREPD_RequestQueryid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_RequestQuery');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select REPD_ResQueryRcv.REPD_ResQueryRcvid ID from REPD_ResQueryRcv where  REPD_ResQueryRcv.ParentStructRowID = aREPD_RequestQueryid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_ResQueryRcv_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_RequestQueryid as varchar),   'REPD_RequestQuery',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_RequestQuery' and OwnerRowID=aREPD_RequestQueryid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_RequestQuery 
  where  REPD_RequestQueryID = aREPD_RequestQueryID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Запрос данных на объект\ строку*/
 create or replace function  REPD_RequestQuery_SAVE /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aREPD_RequestQueryid uuid,
ainstanceid uuid 
,aTheRowID
 uuid/* TheRowID *//* TheRowID */
,aReqPartName
 VARCHAR/* ReqPartName *//* ReqPartName */
,aObjectID
 uuid/* ObjectID *//* ObjectID */
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aSendRecord
 uuid/* SendRecord *//* SendRecord */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aProvider
 uuid/* Provider *//* Provider */
,aReqTypeName
 VARCHAR/* ReqTypeName *//* ReqTypeName */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_RequestQuery where REPD_RequestQueryID=aREPD_RequestQueryID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_RequestQuery_ISLOCKED( acursession,aREPD_RequestQueryid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_RequestQuery');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_RequestQueryid as varchar),  'REPD_RequestQuery',
 'EDITROW',  aInstanceID);
 update  REPD_RequestQuery set ChangeStamp=localtimestamp
,
  TheRowID=aTheRowID
,
  ReqPartName=aReqPartName
,
  ObjectID=aObjectID
,
  SourceSrv=aSourceSrv
,
  SendRecord=aSendRecord
,
  DestSrv=aDestSrv
,
  Provider=aProvider
,
  ReqTypeName=aReqTypeName
  where  REPD_RequestQueryID = aREPD_RequestQueryID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_RequestQuery');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_RequestQueryid as varchar),  'REPD_RequestQuery',
 'CREATEROW',  aInstanceID);
 insert into   REPD_RequestQuery
 (  REPD_RequestQueryID 
,InstanceID
,TheRowID

,ReqPartName

,ObjectID

,SourceSrv

,SendRecord

,DestSrv

,Provider

,ReqTypeName

 ) values ( aREPD_RequestQueryID 
,aInstanceID
,aTheRowID

,aReqPartName

,aObjectID

,aSourceSrv

,aSendRecord

,aDestSrv

,aProvider

,aReqTypeName

 ); 
 PERFORM REPD_RequestQuery_SINIT( aCURSESSION,aREPD_RequestQueryid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_RequestQuery_PARENT_T /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RequestQuery_PARENT_ID /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_RequestQuery where  REPD_RequestQueryid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_ISLOCKED /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_RequestQuery where REPD_RequestQueryid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_LOCK /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_RequestQuery_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_RequestQuery_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_RequestQuery set LockUserID =auserID ,LockSessionID =null where REPD_RequestQueryid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_RequestQuery set LockUserID =null,LockSessionID =aCURSESSION  where REPD_RequestQueryid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_HCL /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select REPD_ResQueryRcv.REPD_ResQueryRcvid ID from REPD_ResQueryRcv where  REPD_ResQueryRcv.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from REPD_ResQueryRcv where REPD_ResQueryRcvid=row_REPD_ResQueryRcv.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= REPD_ResQueryRcv_HCL (acursession,row_REPD_ResQueryRcv.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_UNLOCK /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_RequestQuery_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_RequestQuery set LockUserID =null  where REPD_RequestQueryid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_RequestQuery set LockSessionID =null  where REPD_RequestQueryid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_SINIT /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_RequestQuery_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_RequestQuery_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_RequestQuery set securitystyleid =aStyleID where REPD_RequestQueryid = aRowID;
else 
 update REPD_RequestQuery set securitystyleid =aSecurityStyleID where REPD_RequestQueryid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_RequestQuery_propagate /*Запрос данных на объект\ строку*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_RequestQuery where REPD_RequestQueryid=aRowid;
open aCurs for select REPD_ResQueryRcv.REPD_ResQueryRcvid ID from REPD_ResQueryRcv where  REPD_ResQueryRcv.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_ResQueryRcv_SINIT( acursession,aid,assid);
 PERFORM  REPD_ResQueryRcv_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_ResQueryRcv_BRIEF  (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_ResQueryRcvid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_ResQueryRcv where REPD_ResQueryRcvID=aREPD_ResQueryRcvID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_ResQueryRcv_BRIEF_F(aREPD_ResQueryRcvid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_DELETE /*Результат запроса*/ (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_ResQueryRcv where REPD_ResQueryRcvID=aREPD_ResQueryRcvID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_ResQueryRcv_ISLOCKED( acursession,aREPD_ResQueryRcvid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_ResQueryRcv');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_ResQueryRcvid as varchar),   'REPD_ResQueryRcv',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_ResQueryRcv' and OwnerRowID=aREPD_ResQueryRcvid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_ResQueryRcv 
  where  REPD_ResQueryRcvID = aREPD_ResQueryRcvID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Результат запроса*/
 create or replace function  REPD_ResQueryRcv_SAVE /*Результат запроса*/ (
 aCURSESSION uuid,
 aREPD_ResQueryRcvid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aReceiveRec
 uuid/* ReceiveRec *//* ReceiveRec */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_ResQueryRcv where REPD_ResQueryRcvID=aREPD_ResQueryRcvID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_ResQueryRcv_ISLOCKED( acursession,aREPD_ResQueryRcvid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_ResQueryRcv');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_ResQueryRcvid as varchar),  'REPD_ResQueryRcv',
 'EDITROW',  aInstanceID);
 update  REPD_ResQueryRcv set ChangeStamp=localtimestamp
,
  ReceiveRec=aReceiveRec
  where  REPD_ResQueryRcvID = aREPD_ResQueryRcvID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= REPD_RequestQuery_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_ResQueryRcv');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_ResQueryRcvid as varchar),  'REPD_ResQueryRcv',
 'CREATEROW',  aInstanceID);
 insert into   REPD_ResQueryRcv
 (  REPD_ResQueryRcvID 
,ParentStructRowID
,ReceiveRec

 ) values ( aREPD_ResQueryRcvID 
,aParentStructRowID
,aReceiveRec

 ); 
 PERFORM REPD_ResQueryRcv_SINIT( aCURSESSION,aREPD_ResQueryRcvid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_ResQueryRcv_PARENT_T /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'REPD_RequestQuery';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_ResQueryRcv_PARENT_ID /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from REPD_ResQueryRcv where  REPD_ResQueryRcvid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_ISLOCKED /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_ResQueryRcv where REPD_ResQueryRcvid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_LOCK /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_ResQueryRcv_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_ResQueryRcv_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_ResQueryRcv set LockUserID =auserID ,LockSessionID =null where REPD_ResQueryRcvid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_ResQueryRcv set LockUserID =null,LockSessionID =aCURSESSION  where REPD_ResQueryRcvid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_HCL /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_UNLOCK /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_ResQueryRcv_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_ResQueryRcv set LockUserID =null  where REPD_ResQueryRcvid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_ResQueryRcv set LockSessionID =null  where REPD_ResQueryRcvid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_SINIT /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_ResQueryRcv_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_ResQueryRcv_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_ResQueryRcv set securitystyleid =aStyleID where REPD_ResQueryRcvid = aRowID;
else 
 update REPD_ResQueryRcv set securitystyleid =aSecurityStyleID where REPD_ResQueryRcvid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_ResQueryRcv_propagate /*Результат запроса*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_ResQueryRcv where REPD_ResQueryRcvid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_PROV_BRIEF  (
 aCURSESSION uuid,
 aREPD_PROVid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_PROVid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_PROV where REPD_PROVID=aREPD_PROVID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_PROV_BRIEF_F(aREPD_PROVid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_DELETE /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aREPD_PROVid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_PROV where REPD_PROVID=aREPD_PROVID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_PROV_ISLOCKED( acursession,aREPD_PROVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_PROV');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_PROVid as varchar),   'REPD_PROV',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_PROV' and OwnerRowID=aREPD_PROVid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_PROV 
  where  REPD_PROVID = aREPD_PROVID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Провайдер репликациии*/
 create or replace function  REPD_PROV_SAVE /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aREPD_PROVid uuid,
ainstanceid uuid 
,aAssemblyName
 VARCHAR/* AssemblyName *//* AssemblyName */
,aClassName
 VARCHAR/* ClassName *//* ClassName */
,aName
 VARCHAR/* Name *//* Name */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_PROV where REPD_PROVID=aREPD_PROVID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_PROV_ISLOCKED( acursession,aREPD_PROVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_PROV');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_PROVid as varchar),  'REPD_PROV',
 'EDITROW',  aInstanceID);
 update  REPD_PROV set ChangeStamp=localtimestamp
,
  AssemblyName=aAssemblyName
,
  ClassName=aClassName
,
  Name=aName
  where  REPD_PROVID = aREPD_PROVID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_PROV');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_PROVid as varchar),  'REPD_PROV',
 'CREATEROW',  aInstanceID);
 insert into   REPD_PROV
 (  REPD_PROVID 
,InstanceID
,AssemblyName

,ClassName

,Name

 ) values ( aREPD_PROVID 
,aInstanceID
,aAssemblyName

,aClassName

,aName

 ); 
 PERFORM REPD_PROV_SINIT( aCURSESSION,aREPD_PROVid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_PROV_PARENT_T /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_PROV_PARENT_ID /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_PROV where  REPD_PROVid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_ISLOCKED /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_PROV where REPD_PROVid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_LOCK /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_PROV_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_PROV_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_PROV set LockUserID =auserID ,LockSessionID =null where REPD_PROVid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_PROV set LockUserID =null,LockSessionID =aCURSESSION  where REPD_PROVid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_HCL /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_UNLOCK /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_PROV_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_PROV set LockUserID =null  where REPD_PROVid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_PROV set LockSessionID =null  where REPD_PROVid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_SINIT /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_PROV_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_PROV_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_PROV set securitystyleid =aStyleID where REPD_PROVid = aRowID;
else 
 update REPD_PROV set securitystyleid =aSecurityStyleID where REPD_PROVid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_PROV_propagate /*Провайдер репликациии*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_PROV where REPD_PROVid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_SRV_BRIEF  (
 aCURSESSION uuid,
 aREPD_SRVid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_SRVid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_SRV where REPD_SRVID=aREPD_SRVID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_SRV_BRIEF_F(aREPD_SRVid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_DELETE /*Узлы репликации*/ (
 aCURSESSION uuid,
 aREPD_SRVid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_SRV where REPD_SRVID=aREPD_SRVID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_SRV_ISLOCKED( acursession,aREPD_SRVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_SRV');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select REPD_SNDTO.REPD_SNDTOid ID from REPD_SNDTO where  REPD_SNDTO.ParentStructRowID = aREPD_SRVid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_SNDTO_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_SRVid as varchar),   'REPD_SRV',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_SRV' and OwnerRowID=aREPD_SRVid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_SRV 
  where  REPD_SRVID = aREPD_SRVID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Узлы репликации*/
 create or replace function  REPD_SRV_SAVE /*Узлы репликации*/ (
 aCURSESSION uuid,
 aREPD_SRVid uuid,
ainstanceid uuid 
,aObj3
 uuid/* Obj3 *//* Obj3 */
,aname
 VARCHAR/* Название *//* Название */
,aObj2
 uuid/* Obj2 *//* Obj2 */
,aObj1
 uuid/* Obj1 *//* Obj1 */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_SRV where REPD_SRVID=aREPD_SRVID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_SRV_ISLOCKED( acursession,aREPD_SRVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SRV');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_SRVid as varchar),  'REPD_SRV',
 'EDITROW',  aInstanceID);
 update  REPD_SRV set ChangeStamp=localtimestamp
,
  Obj3=aObj3
,
  name=aname
,
  Obj2=aObj2
,
  Obj1=aObj1
  where  REPD_SRVID = aREPD_SRVID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SRV');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_SRVid as varchar),  'REPD_SRV',
 'CREATEROW',  aInstanceID);
 insert into   REPD_SRV
 (  REPD_SRVID 
,InstanceID
,Obj3

,name

,Obj2

,Obj1

 ) values ( aREPD_SRVID 
,aInstanceID
,aObj3

,aname

,aObj2

,aObj1

 ); 
 PERFORM REPD_SRV_SINIT( aCURSESSION,aREPD_SRVid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_SRV_PARENT_T /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SRV_PARENT_ID /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_SRV where  REPD_SRVid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_ISLOCKED /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_SRV where REPD_SRVid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_LOCK /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_SRV_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_SRV_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_SRV set LockUserID =auserID ,LockSessionID =null where REPD_SRVid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_SRV set LockUserID =null,LockSessionID =aCURSESSION  where REPD_SRVid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_HCL /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select REPD_SNDTO.REPD_SNDTOid ID from REPD_SNDTO where  REPD_SNDTO.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from REPD_SNDTO where REPD_SNDTOid=row_REPD_SNDTO.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= REPD_SNDTO_HCL (acursession,row_REPD_SNDTO.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_UNLOCK /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_SRV_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_SRV set LockUserID =null  where REPD_SRVid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_SRV set LockSessionID =null  where REPD_SRVid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_SINIT /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_SRV_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_SRV_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_SRV set securitystyleid =aStyleID where REPD_SRVid = aRowID;
else 
 update REPD_SRV set securitystyleid =aSecurityStyleID where REPD_SRVid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SRV_propagate /*Узлы репликации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_SRV where REPD_SRVid=aRowid;
open aCurs for select REPD_SNDTO.REPD_SNDTOid ID from REPD_SNDTO where  REPD_SNDTO.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_SNDTO_SINIT( acursession,aid,assid);
 PERFORM  REPD_SNDTO_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_SNDTO_BRIEF  (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_SNDTOid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_SNDTO where REPD_SNDTOID=aREPD_SNDTOID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_SNDTO_BRIEF_F(aREPD_SNDTOid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_DELETE /*Получатели реплик*/ (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_SNDTO where REPD_SNDTOID=aREPD_SNDTOID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_SNDTO_ISLOCKED( acursession,aREPD_SNDTOid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_SNDTO');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select REPD_CONST.REPD_CONSTid ID from REPD_CONST where  REPD_CONST.ParentStructRowID = aREPD_SNDTOid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_CONST_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select REPD_REPTYPE.REPD_REPTYPEid ID from REPD_REPTYPE where  REPD_REPTYPE.ParentStructRowID = aREPD_SNDTOid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_REPTYPE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_SNDTOid as varchar),   'REPD_SNDTO',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_SNDTO' and OwnerRowID=aREPD_SNDTOid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_SNDTO 
  where  REPD_SNDTOID = aREPD_SNDTOID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Получатели реплик*/
 create or replace function  REPD_SNDTO_SAVE /*Получатели реплик*/ (
 aCURSESSION uuid,
 aREPD_SNDTOid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aLastScan
 timestamp/* Last scan *//* Last scan */
,aConfig
 TEXT/* Config *//* Config */
,aLastReceive
 timestamp/* Last Receive *//* Last Receive */
,aProvider
 uuid/* Provider *//* Provider */
,aWork_Start
 time/* Начало работы (время) *//* Начало работы (время) */
,aWork_End
 time/* Окончание работы (время) *//* Окончание работы (время) */
,aThe_Interval
 integer/* Интервал *//* Интервал */
,aIsActive
 INTEGER/* Активен *//* Активен */
,aLastApproveLog
 timestamp/* Последнее подтверждение (лог) *//* Последнее подтверждение (лог) */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_SNDTO where REPD_SNDTOID=aREPD_SNDTOID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_SNDTO_ISLOCKED( acursession,aREPD_SNDTOid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SNDTO');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_SNDTOid as varchar),  'REPD_SNDTO',
 'EDITROW',  aInstanceID);
 update  REPD_SNDTO set ChangeStamp=localtimestamp
,
  DestSrv=aDestSrv
,
  LastScan=aLastScan
,
  Config=aConfig
,
  LastReceive=aLastReceive
,
  Provider=aProvider
,
  Work_Start=aWork_Start
,
  Work_End=aWork_End
,
  The_Interval=aThe_Interval
,
  IsActive=aIsActive
,
  LastApproveLog=aLastApproveLog
  where  REPD_SNDTOID = aREPD_SNDTOID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= REPD_SRV_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SNDTO');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_SNDTOid as varchar),  'REPD_SNDTO',
 'CREATEROW',  aInstanceID);
 insert into   REPD_SNDTO
 (  REPD_SNDTOID 
,ParentStructRowID
,DestSrv

,LastScan

,Config

,LastReceive

,Provider

,Work_Start

,Work_End

,The_Interval

,IsActive

,LastApproveLog

 ) values ( aREPD_SNDTOID 
,aParentStructRowID
,aDestSrv

,aLastScan

,aConfig

,aLastReceive

,aProvider

,aWork_Start

,aWork_End

,aThe_Interval

,aIsActive

,aLastApproveLog

 ); 
 PERFORM REPD_SNDTO_SINIT( aCURSESSION,aREPD_SNDTOid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_SNDTO_PARENT_T /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'REPD_SRV';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SNDTO_PARENT_ID /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from REPD_SNDTO where  REPD_SNDTOid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_ISLOCKED /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_SNDTO where REPD_SNDTOid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_LOCK /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_SNDTO_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_SNDTO_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_SNDTO set LockUserID =auserID ,LockSessionID =null where REPD_SNDTOid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_SNDTO set LockUserID =null,LockSessionID =aCURSESSION  where REPD_SNDTOid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_HCL /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select REPD_CONST.REPD_CONSTid ID from REPD_CONST where  REPD_CONST.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from REPD_CONST where REPD_CONSTid=row_REPD_CONST.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= REPD_CONST_HCL (acursession,row_REPD_CONST.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select REPD_REPTYPE.REPD_REPTYPEid ID from REPD_REPTYPE where  REPD_REPTYPE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from REPD_REPTYPE where REPD_REPTYPEid=row_REPD_REPTYPE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= REPD_REPTYPE_HCL (acursession,row_REPD_REPTYPE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_UNLOCK /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_SNDTO_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_SNDTO set LockUserID =null  where REPD_SNDTOid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_SNDTO set LockSessionID =null  where REPD_SNDTOid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_SINIT /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_SNDTO_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_SNDTO_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_SNDTO set securitystyleid =aStyleID where REPD_SNDTOid = aRowID;
else 
 update REPD_SNDTO set securitystyleid =aSecurityStyleID where REPD_SNDTOid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SNDTO_propagate /*Получатели реплик*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_SNDTO where REPD_SNDTOid=aRowid;
open aCurs for select REPD_CONST.REPD_CONSTid ID from REPD_CONST where  REPD_CONST.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_CONST_SINIT( acursession,aid,assid);
 PERFORM  REPD_CONST_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select REPD_REPTYPE.REPD_REPTYPEid ID from REPD_REPTYPE where  REPD_REPTYPE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  REPD_REPTYPE_SINIT( acursession,aid,assid);
 PERFORM  REPD_REPTYPE_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_CONST_BRIEF  (
 aCURSESSION uuid,
 aREPD_CONSTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_CONSTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_CONST where REPD_CONSTID=aREPD_CONSTID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_CONST_BRIEF_F(aREPD_CONSTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_DELETE /**/ (
 aCURSESSION uuid,
 aREPD_CONSTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_CONST where REPD_CONSTID=aREPD_CONSTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_CONST_ISLOCKED( acursession,aREPD_CONSTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_CONST');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_CONSTid as varchar),   'REPD_CONST',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_CONST' and OwnerRowID=aREPD_CONSTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_CONST 
  where  REPD_CONSTID = aREPD_CONSTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Константы к запросу*/
 create or replace function  REPD_CONST_SAVE /**/ (
 aCURSESSION uuid,
 aREPD_CONSTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheValue
 VARCHAR/* Значение *//* Значение */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_CONST where REPD_CONSTID=aREPD_CONSTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_CONST_ISLOCKED( acursession,aREPD_CONSTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_CONST');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_CONSTid as varchar),  'REPD_CONST',
 'EDITROW',  aInstanceID);
 update  REPD_CONST set ChangeStamp=localtimestamp
,
  Name=aName
,
  TheValue=aTheValue
  where  REPD_CONSTID = aREPD_CONSTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= REPD_SNDTO_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_CONST');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_CONSTid as varchar),  'REPD_CONST',
 'CREATEROW',  aInstanceID);
 insert into   REPD_CONST
 (  REPD_CONSTID 
,ParentStructRowID
,Name

,TheValue

 ) values ( aREPD_CONSTID 
,aParentStructRowID
,aName

,aTheValue

 ); 
 PERFORM REPD_CONST_SINIT( aCURSESSION,aREPD_CONSTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_CONST_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'REPD_SNDTO';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_CONST_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from REPD_CONST where  REPD_CONSTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_CONST where REPD_CONSTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_CONST_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_CONST_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_CONST set LockUserID =auserID ,LockSessionID =null where REPD_CONSTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_CONST set LockUserID =null,LockSessionID =aCURSESSION  where REPD_CONSTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_CONST_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_CONST set LockUserID =null  where REPD_CONSTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_CONST set LockSessionID =null  where REPD_CONSTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_CONST_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_CONST_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_CONST set securitystyleid =aStyleID where REPD_CONSTid = aRowID;
else 
 update REPD_CONST set securitystyleid =aSecurityStyleID where REPD_CONSTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_CONST_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_CONST where REPD_CONSTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_REPTYPE_BRIEF  (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_REPTYPEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_REPTYPE where REPD_REPTYPEID=aREPD_REPTYPEID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_REPTYPE_BRIEF_F(aREPD_REPTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_DELETE /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_REPTYPE where REPD_REPTYPEID=aREPD_REPTYPEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_REPTYPE_ISLOCKED( acursession,aREPD_REPTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_REPTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_REPTYPEid as varchar),   'REPD_REPTYPE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_REPTYPE' and OwnerRowID=aREPD_REPTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_REPTYPE 
  where  REPD_REPTYPEID = aREPD_REPTYPEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Тип репликации документов*/
 create or replace function  REPD_REPTYPE_SAVE /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aREPD_REPTYPEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aReplicaType
 INTEGER/* Тип репликации *//* Тип репликации */
,aTheObjectType
 uuid/* Тип объекта *//* Тип объекта */
,aUseFilter
 INTEGER/* Фильтровать по условию *//* Фильтровать по условию */
,aRepConditonQRY
 TEXT/* Условие репликации *//* Условие репликации */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_REPTYPE where REPD_REPTYPEID=aREPD_REPTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_REPTYPE_ISLOCKED( acursession,aREPD_REPTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_REPTYPE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_REPTYPEid as varchar),  'REPD_REPTYPE',
 'EDITROW',  aInstanceID);
 update  REPD_REPTYPE set ChangeStamp=localtimestamp
,
  ReplicaType=aReplicaType
,
  TheObjectType=aTheObjectType
,
  UseFilter=aUseFilter
,
  RepConditonQRY=aRepConditonQRY
  where  REPD_REPTYPEID = aREPD_REPTYPEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= REPD_SNDTO_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_REPTYPE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_REPTYPEid as varchar),  'REPD_REPTYPE',
 'CREATEROW',  aInstanceID);
 insert into   REPD_REPTYPE
 (  REPD_REPTYPEID 
,ParentStructRowID
,ReplicaType

,TheObjectType

,UseFilter

,RepConditonQRY

 ) values ( aREPD_REPTYPEID 
,aParentStructRowID
,aReplicaType

,aTheObjectType

,aUseFilter

,aRepConditonQRY

 ); 
 PERFORM REPD_REPTYPE_SINIT( aCURSESSION,aREPD_REPTYPEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_REPTYPE_PARENT_T /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'REPD_SNDTO';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_REPTYPE_PARENT_ID /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from REPD_REPTYPE where  REPD_REPTYPEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_ISLOCKED /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_REPTYPE where REPD_REPTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_LOCK /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_REPTYPE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_REPTYPE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_REPTYPE set LockUserID =auserID ,LockSessionID =null where REPD_REPTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_REPTYPE set LockUserID =null,LockSessionID =aCURSESSION  where REPD_REPTYPEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_HCL /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_UNLOCK /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_REPTYPE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_REPTYPE set LockUserID =null  where REPD_REPTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_REPTYPE set LockSessionID =null  where REPD_REPTYPEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_SINIT /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_REPTYPE_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_REPTYPE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_REPTYPE set securitystyleid =aStyleID where REPD_REPTYPEid = aRowID;
else 
 update REPD_REPTYPE set securitystyleid =aSecurityStyleID where REPD_REPTYPEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_REPTYPE_propagate /*Описание типа репликации документов для узла*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_REPTYPE where REPD_REPTYPEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_SendQ_BRIEF  (
 aCURSESSION uuid,
 aREPD_SendQid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_SendQid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_SendQ where REPD_SendQID=aREPD_SendQID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_SendQ_BRIEF_F(aREPD_SendQid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_DELETE /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aREPD_SendQid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_SendQ where REPD_SendQID=aREPD_SendQID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_SendQ_ISLOCKED( acursession,aREPD_SendQid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_SendQ');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_SendQid as varchar),   'REPD_SendQ',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_SendQ' and OwnerRowID=aREPD_SendQid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_SendQ 
  where  REPD_SendQID = aREPD_SendQID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Очередь отсылки*/
 create or replace function  REPD_SendQ_SAVE /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aREPD_SendQid uuid,
ainstanceid uuid 
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aConfig
 TEXT/* Config *//* Config */
,aSentDate
 timestamp/* SentDate *//* SentDate */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aProvider
 uuid/* Provider *//* Provider */
,aAcknowelge
 INTEGER/* Acknowelge *//* Acknowelge */
,aSendSize
 integer/* SendSize *//* SendSize */
,aCheckDate
 timestamp/* CheckDate *//* CheckDate */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aFileName
 VARCHAR/* FileName *//* FileName */
,aPartCount
 integer/* Количество частей *//* Количество частей */
,aPartNumber
 integer/* Часть *//* Часть */
,aSent
 integer/* Sent *//* Sent */
,aReplicatorPointer
 timestamp/* Указатель репликации *//* Указатель репликации */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_SendQ where REPD_SendQID=aREPD_SendQID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_SendQ_ISLOCKED( acursession,aREPD_SendQid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SendQ');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_SendQid as varchar),  'REPD_SendQ',
 'EDITROW',  aInstanceID);
 update  REPD_SendQ set ChangeStamp=localtimestamp
,
  SourceSrv=aSourceSrv
,
  Config=aConfig
,
  SentDate=aSentDate
,
  DestSrv=aDestSrv
,
  Provider=aProvider
,
  Acknowelge=aAcknowelge
,
  SendSize=aSendSize
,
  CheckDate=aCheckDate
,
  ReplicaPackID=aReplicaPackID
,
  FileName=aFileName
,
  PartCount=aPartCount
,
  PartNumber=aPartNumber
,
  Sent=aSent
,
  ReplicatorPointer=aReplicatorPointer
  where  REPD_SendQID = aREPD_SendQID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_SendQ');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_SendQid as varchar),  'REPD_SendQ',
 'CREATEROW',  aInstanceID);
 insert into   REPD_SendQ
 (  REPD_SendQID 
,InstanceID
,SourceSrv

,Config

,SentDate

,DestSrv

,Provider

,Acknowelge

,SendSize

,CheckDate

,ReplicaPackID

,FileName

,PartCount

,PartNumber

,Sent

,ReplicatorPointer

 ) values ( aREPD_SendQID 
,aInstanceID
,aSourceSrv

,aConfig

,aSentDate

,aDestSrv

,aProvider

,aAcknowelge

,aSendSize

,aCheckDate

,aReplicaPackID

,aFileName

,aPartCount

,aPartNumber

,aSent

,aReplicatorPointer

 ); 
 PERFORM REPD_SendQ_SINIT( aCURSESSION,aREPD_SendQid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_SendQ_PARENT_T /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_SendQ_PARENT_ID /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_SendQ where  REPD_SendQid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_ISLOCKED /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_SendQ where REPD_SendQid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_LOCK /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_SendQ_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_SendQ_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_SendQ set LockUserID =auserID ,LockSessionID =null where REPD_SendQid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_SendQ set LockUserID =null,LockSessionID =aCURSESSION  where REPD_SendQid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_HCL /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_UNLOCK /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_SendQ_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_SendQ set LockUserID =null  where REPD_SendQid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_SendQ set LockSessionID =null  where REPD_SendQid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_SINIT /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_SendQ_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_SendQ_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_SendQ set securitystyleid =aStyleID where REPD_SendQid = aRowID;
else 
 update REPD_SendQ set securitystyleid =aSecurityStyleID where REPD_SendQid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_SendQ_propagate /*Очередь отсылки*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_SendQ where REPD_SendQid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  REPD_RecvQ_BRIEF  (
 aCURSESSION uuid,
 aREPD_RecvQid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aREPD_RecvQid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from REPD_RecvQ where REPD_RecvQID=aREPD_RecvQID;
if existsCnt &gt;0
 then
  aBRIEF:= REPD_RecvQ_BRIEF_F(aREPD_RecvQid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_DELETE /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aREPD_RecvQid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from REPD_RecvQ where REPD_RecvQID=aREPD_RecvQID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  REPD_RecvQ_ISLOCKED( acursession,aREPD_RecvQid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=REPD_RecvQ');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aREPD_RecvQid as varchar),   'REPD_RecvQ',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='REPD_RecvQ' and OwnerRowID=aREPD_RecvQid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  REPD_RecvQ 
  where  REPD_RecvQID = aREPD_RecvQID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Очередь полученых реплик*/
 create or replace function  REPD_RecvQ_SAVE /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aREPD_RecvQid uuid,
ainstanceid uuid 
,aTheRowID
 uuid/* TheRowID *//* TheRowID */
,aReceived
 timestamp/* Received *//* Received */
,aProvider
 uuid/* Provider *//* Provider */
,aRecvSize
 integer/* RecvSize *//* RecvSize */
,aSourceSrv
 uuid/* SourceSrv *//* SourceSrv */
,aDestSrv
 uuid/* DestSrv *//* DestSrv */
,aAcknowelge
 INTEGER/* Acknowelge *//* Acknowelge */
,aReplicaPackID
 uuid/* ReplicaPackID *//* ReplicaPackID */
,aPartCount
 integer/* Количество частей *//* Количество частей */
,aPartNumber
 integer/* Часть *//* Часть */
,aFileName
 VARCHAR/* FileName *//* FileName */
,aCompleted
 INTEGER/* Completed *//* Completed */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from REPD_RecvQ where REPD_RecvQID=aREPD_RecvQID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  REPD_RecvQ_ISLOCKED( acursession,aREPD_RecvQid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_RecvQ');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aREPD_RecvQid as varchar),  'REPD_RecvQ',
 'EDITROW',  aInstanceID);
 update  REPD_RecvQ set ChangeStamp=localtimestamp
,
  TheRowID=aTheRowID
,
  Received=aReceived
,
  Provider=aProvider
,
  RecvSize=aRecvSize
,
  SourceSrv=aSourceSrv
,
  DestSrv=aDestSrv
,
  Acknowelge=aAcknowelge
,
  ReplicaPackID=aReplicaPackID
,
  PartCount=aPartCount
,
  PartNumber=aPartNumber
,
  FileName=aFileName
,
  Completed=aCompleted
  where  REPD_RecvQID = aREPD_RecvQID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=REPD_RecvQ');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aREPD_RecvQid as varchar),  'REPD_RecvQ',
 'CREATEROW',  aInstanceID);
 insert into   REPD_RecvQ
 (  REPD_RecvQID 
,InstanceID
,TheRowID

,Received

,Provider

,RecvSize

,SourceSrv

,DestSrv

,Acknowelge

,ReplicaPackID

,PartCount

,PartNumber

,FileName

,Completed

 ) values ( aREPD_RecvQID 
,aInstanceID
,aTheRowID

,aReceived

,aProvider

,aRecvSize

,aSourceSrv

,aDestSrv

,aAcknowelge

,aReplicaPackID

,aPartCount

,aPartNumber

,aFileName

,aCompleted

 ); 
 PERFORM REPD_RecvQ_SINIT( aCURSESSION,aREPD_RecvQid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  REPD_RecvQ_PARENT_T /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  REPD_RecvQ_PARENT_ID /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from REPD_RecvQ where  REPD_RecvQid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_ISLOCKED /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from REPD_RecvQ where REPD_RecvQid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_LOCK /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= REPD_RecvQ_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= REPD_RecvQ_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update REPD_RecvQ set LockUserID =auserID ,LockSessionID =null where REPD_RecvQid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update REPD_RecvQ set LockUserID =null,LockSessionID =aCURSESSION  where REPD_RecvQid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_HCL /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_UNLOCK /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= REPD_RecvQ_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update REPD_RecvQ set LockUserID =null  where REPD_RecvQid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update REPD_RecvQ set LockSessionID =null  where REPD_RecvQid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_SINIT /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=REPD_RecvQ_parent_T( aCURSESSION,aROWID);
 aParentID:= REPD_RecvQ_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update REPD_RecvQ set securitystyleid =aStyleID where REPD_RecvQid = aRowID;
else 
 update REPD_RecvQ set securitystyleid =aSecurityStyleID where REPD_RecvQid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  REPD_RecvQ_propagate /*Очередь полученых реплик*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from REPD_RecvQ where REPD_RecvQid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_INV" BlockCode=" create or replace function  INV_INV_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='INV_INV'
then
Open aCurs  for select invi_DEF.invi_DEFid ID from invi_DEF where  invi_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM invi_DEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_PERSONS.INVI_PERSONSid ID from INVI_PERSONS where  INVI_PERSONS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_PERSONS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_BAD.INVI_BADid ID from INVI_BAD where  INVI_BAD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_BAD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_CHNG.INVI_CHNGid ID from INVI_CHNG where  INVI_CHNG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_CHNG_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_OBJ.INVI_OBJid ID from INVI_OBJ where  INVI_OBJ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_OBJ_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_DONE.INVI_DONEid ID from INVI_DONE where  INVI_DONE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_DONE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVI_UNK.INVI_UNKid ID from INVI_UNK where  INVI_UNK.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_UNK_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_INV_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'INV_INV'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select invi_DEF.invi_DEFid ID from invi_DEF where  invi_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from invi_DEF where invi_DEFid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= invi_DEF_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_PERSONS.INVI_PERSONSid ID from INVI_PERSONS where  INVI_PERSONS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_PERSONS where INVI_PERSONSid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_PERSONS_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_BAD.INVI_BADid ID from INVI_BAD where  INVI_BAD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_BAD where INVI_BADid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_BAD_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_CHNG.INVI_CHNGid ID from INVI_CHNG where  INVI_CHNG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_CHNG where INVI_CHNGid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_CHNG_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_OBJ.INVI_OBJid ID from INVI_OBJ where  INVI_OBJ.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_OBJ where INVI_OBJid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_OBJ_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_DONE.INVI_DONEid ID from INVI_DONE where  INVI_DONE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_DONE where INVI_DONEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_DONE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVI_UNK.INVI_UNKid ID from INVI_UNK where  INVI_UNK.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVI_UNK where INVI_UNKid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVI_UNK_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_INV_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'INV_INV'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select invi_DEF.invi_DEFid id from invi_DEF where  invi_DEF.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM invi_DEF_SINIT( acursession,aid,assid);
 PERFORM invi_DEF_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_PERSONS.INVI_PERSONSid id from INVI_PERSONS where  INVI_PERSONS.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_PERSONS_SINIT( acursession,aid,assid);
 PERFORM INVI_PERSONS_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_BAD.INVI_BADid id from INVI_BAD where  INVI_BAD.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_BAD_SINIT( acursession,aid,assid);
 PERFORM INVI_BAD_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_CHNG.INVI_CHNGid id from INVI_CHNG where  INVI_CHNG.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_CHNG_SINIT( acursession,aid,assid);
 PERFORM INVI_CHNG_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_OBJ.INVI_OBJid id from INVI_OBJ where  INVI_OBJ.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_OBJ_SINIT( acursession,aid,assid);
 PERFORM INVI_OBJ_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_DONE.INVI_DONEid id from INVI_DONE where  INVI_DONE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_DONE_SINIT( acursession,aid,assid);
 PERFORM INVI_DONE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVI_UNK.INVI_UNKid id from INVI_UNK where  INVI_UNK.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVI_UNK_SINIT( acursession,aid,assid);
 PERFORM INVI_UNK_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  invi_DEF_BRIEF  (
 aCURSESSION uuid,
 ainvi_DEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if ainvi_DEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from invi_DEF where invi_DEFID=ainvi_DEFID;
if existsCnt &gt;0
 then
  aBRIEF:= invi_DEF_BRIEF_F(ainvi_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_DELETE /*Описание*/ (
 aCURSESSION uuid,
 ainvi_DEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from invi_DEF where invi_DEFID=ainvi_DEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  invi_DEF_ISLOCKED( acursession,ainvi_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=invi_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( ainvi_DEFid as varchar),   'invi_DEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='invi_DEF' and OwnerRowID=ainvi_DEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  invi_DEF 
  where  invi_DEFID = ainvi_DEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание*/
 create or replace function  invi_DEF_SAVE /*Описание*/ (
 aCURSESSION uuid,
 ainvi_DEFid uuid,
ainstanceid uuid 
,aOrderNum
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала инвентаризации *//* Дата начала инвентаризации */
,aEndDate
 date/* Дата завершения инвентаризации *//* Дата завершения инвентаризации */
,aTheOrg
 uuid/* Юр. лицо *//* Юр. лицо */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprev
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aTheOwner
 uuid/* Владелец *//* Владелец */
,aBuilding
 uuid/* Здание *//* Здание */
,aTheFlow
 VARCHAR/* Этаж *//* Этаж */
,aTheRoom
 VARCHAR/* Комната *//* Комната */
,aTheWorkPlace
 VARCHAR/* Рабочее место *//* Рабочее место */
,aMatOtv
 uuid/* МОЛ *//* МОЛ */
,aInfo
 TEXT/* Примечания *//* Примечания */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from invi_DEF where invi_DEFID=ainvi_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  invi_DEF_ISLOCKED( acursession,ainvi_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=invi_DEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(ainvi_DEFid as varchar),  'invi_DEF',
 'EDITROW',  aInstanceID);
 update  invi_DEF set ChangeStamp=localtimestamp
,
  OrderNum=aOrderNum
,
  StartDate=aStartDate
,
  EndDate=aEndDate
,
  TheOrg=aTheOrg
,
  DIrection=aDIrection
,
  Uprev=aUprev
,
  Otdel=aOtdel
,
  TheOwner=aTheOwner
,
  Building=aBuilding
,
  TheFlow=aTheFlow
,
  TheRoom=aTheRoom
,
  TheWorkPlace=aTheWorkPlace
,
  MatOtv=aMatOtv
,
  Info=aInfo
  where  invi_DEFID = ainvi_DEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=invi_DEF');
    return;
  end if;
select Count(*) into existsCnt from invi_DEF where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;invi_DEF&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(ainvi_DEFid as varchar),  'invi_DEF',
 'CREATEROW',  aInstanceID);
 insert into   invi_DEF
 (  invi_DEFID 
,InstanceID
,OrderNum

,StartDate

,EndDate

,TheOrg

,DIrection

,Uprev

,Otdel

,TheOwner

,Building

,TheFlow

,TheRoom

,TheWorkPlace

,MatOtv

,Info

 ) values ( ainvi_DEFID 
,aInstanceID
,aOrderNum

,aStartDate

,aEndDate

,aTheOrg

,aDIrection

,aUprev

,aOtdel

,aTheOwner

,aBuilding

,aTheFlow

,aTheRoom

,aTheWorkPlace

,aMatOtv

,aInfo

 ); 
 PERFORM invi_DEF_SINIT( aCURSESSION,ainvi_DEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  invi_DEF_PARENT_T /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  invi_DEF_PARENT_ID /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from invi_DEF where  invi_DEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_ISLOCKED /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from invi_DEF where invi_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_LOCK /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= invi_DEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= invi_DEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update invi_DEF set LockUserID =auserID ,LockSessionID =null where invi_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update invi_DEF set LockUserID =null,LockSessionID =aCURSESSION  where invi_DEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_HCL /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  invi_DEF_UNLOCK /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= invi_DEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update invi_DEF set LockUserID =null  where invi_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update invi_DEF set LockSessionID =null  where invi_DEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_SINIT /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=invi_DEF_parent_T( aCURSESSION,aROWID);
 aParentID:= invi_DEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update invi_DEF set securitystyleid =aStyleID where invi_DEFid = aRowID;
else 
 update invi_DEF set securitystyleid =aSecurityStyleID where invi_DEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  invi_DEF_propagate /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from invi_DEF where invi_DEFid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_PERSONS_BRIEF  (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_PERSONSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_PERSONS where INVI_PERSONSID=aINVI_PERSONSID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_PERSONS_BRIEF_F(aINVI_PERSONSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_DELETE /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_PERSONS where INVI_PERSONSID=aINVI_PERSONSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_PERSONS_ISLOCKED( acursession,aINVI_PERSONSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_PERSONS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_PERSONSid as varchar),   'INVI_PERSONS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_PERSONS' and OwnerRowID=aINVI_PERSONSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_PERSONS 
  where  INVI_PERSONSID = aINVI_PERSONSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Состав комисии*/
 create or replace function  INVI_PERSONS_SAVE /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aINVI_PERSONSid uuid,
ainstanceid uuid 
,aThePosition
 VARCHAR/* Должность *//* Должность */
,aFamiliName
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_PERSONS where INVI_PERSONSID=aINVI_PERSONSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_PERSONS_ISLOCKED( acursession,aINVI_PERSONSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_PERSONS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_PERSONSid as varchar),  'INVI_PERSONS',
 'EDITROW',  aInstanceID);
 update  INVI_PERSONS set ChangeStamp=localtimestamp
,
  ThePosition=aThePosition
,
  FamiliName=aFamiliName
,
  Name=aName
,
  SurName=aSurName
  where  INVI_PERSONSID = aINVI_PERSONSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_PERSONS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_PERSONSid as varchar),  'INVI_PERSONS',
 'CREATEROW',  aInstanceID);
 insert into   INVI_PERSONS
 (  INVI_PERSONSID 
,InstanceID
,ThePosition

,FamiliName

,Name

,SurName

 ) values ( aINVI_PERSONSID 
,aInstanceID
,aThePosition

,aFamiliName

,aName

,aSurName

 ); 
 PERFORM INVI_PERSONS_SINIT( aCURSESSION,aINVI_PERSONSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_PERSONS_PARENT_T /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_PERSONS_PARENT_ID /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_PERSONS where  INVI_PERSONSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_ISLOCKED /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_PERSONS where INVI_PERSONSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_LOCK /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_PERSONS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_PERSONS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_PERSONS set LockUserID =auserID ,LockSessionID =null where INVI_PERSONSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_PERSONS set LockUserID =null,LockSessionID =aCURSESSION  where INVI_PERSONSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_HCL /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_UNLOCK /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_PERSONS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_PERSONS set LockUserID =null  where INVI_PERSONSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_PERSONS set LockSessionID =null  where INVI_PERSONSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_SINIT /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_PERSONS_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_PERSONS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_PERSONS set securitystyleid =aStyleID where INVI_PERSONSid = aRowID;
else 
 update INVI_PERSONS set securitystyleid =aSecurityStyleID where INVI_PERSONSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_PERSONS_propagate /*Состав инвентаризационной комисии*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_PERSONS where INVI_PERSONSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_BAD_BRIEF  (
 aCURSESSION uuid,
 aINVI_BADid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_BADid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_BAD where INVI_BADID=aINVI_BADID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_BAD_BRIEF_F(aINVI_BADid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_DELETE /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aINVI_BADid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_BAD where INVI_BADID=aINVI_BADID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_BAD_ISLOCKED( acursession,aINVI_BADid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_BAD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_BADid as varchar),   'INVI_BAD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_BAD' and OwnerRowID=aINVI_BADid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_BAD 
  where  INVI_BADID = aINVI_BADID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Неверные штрихкоды*/
 create or replace function  INVI_BAD_SAVE /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aINVI_BADid uuid,
ainstanceid uuid 
,aSHCode
 VARCHAR/* Штрихкод *//* Штрихкод */
,aInfo
 TEXT/* Описание объекта *//* Описание объекта */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_BAD where INVI_BADID=aINVI_BADID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_BAD_ISLOCKED( acursession,aINVI_BADid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_BAD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_BADid as varchar),  'INVI_BAD',
 'EDITROW',  aInstanceID);
 update  INVI_BAD set ChangeStamp=localtimestamp
,
  SHCode=aSHCode
,
  Info=aInfo
  where  INVI_BADID = aINVI_BADID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_BAD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_BADid as varchar),  'INVI_BAD',
 'CREATEROW',  aInstanceID);
 insert into   INVI_BAD
 (  INVI_BADID 
,InstanceID
,SHCode

,Info

 ) values ( aINVI_BADID 
,aInstanceID
,aSHCode

,aInfo

 ); 
 PERFORM INVI_BAD_SINIT( aCURSESSION,aINVI_BADid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_BAD_PARENT_T /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_BAD_PARENT_ID /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_BAD where  INVI_BADid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_ISLOCKED /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_BAD where INVI_BADid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_LOCK /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_BAD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_BAD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_BAD set LockUserID =auserID ,LockSessionID =null where INVI_BADid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_BAD set LockUserID =null,LockSessionID =aCURSESSION  where INVI_BADid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_HCL /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_UNLOCK /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_BAD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_BAD set LockUserID =null  where INVI_BADid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_BAD set LockSessionID =null  where INVI_BADid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_SINIT /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_BAD_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_BAD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_BAD set securitystyleid =aStyleID where INVI_BADid = aRowID;
else 
 update INVI_BAD set securitystyleid =aSecurityStyleID where INVI_BADid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_BAD_propagate /*Неверно наклеенные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_BAD where INVI_BADid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_CHNG_BRIEF  (
 aCURSESSION uuid,
 aINVI_CHNGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_CHNGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_CHNG where INVI_CHNGID=aINVI_CHNGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_CHNG_BRIEF_F(aINVI_CHNGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_DELETE /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aINVI_CHNGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_CHNG where INVI_CHNGID=aINVI_CHNGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_CHNG_ISLOCKED( acursession,aINVI_CHNGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_CHNG');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_CHNGid as varchar),   'INVI_CHNG',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_CHNG' and OwnerRowID=aINVI_CHNGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_CHNG 
  where  INVI_CHNGID = aINVI_CHNGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Требуют замены*/
 create or replace function  INVI_CHNG_SAVE /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aINVI_CHNGid uuid,
ainstanceid uuid 
,aSHCode
 VARCHAR/* Штрихкод *//* Штрихкод */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_CHNG where INVI_CHNGID=aINVI_CHNGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_CHNG_ISLOCKED( acursession,aINVI_CHNGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_CHNG');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_CHNGid as varchar),  'INVI_CHNG',
 'EDITROW',  aInstanceID);
 update  INVI_CHNG set ChangeStamp=localtimestamp
,
  SHCode=aSHCode
  where  INVI_CHNGID = aINVI_CHNGID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_CHNG');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_CHNGid as varchar),  'INVI_CHNG',
 'CREATEROW',  aInstanceID);
 insert into   INVI_CHNG
 (  INVI_CHNGID 
,InstanceID
,SHCode

 ) values ( aINVI_CHNGID 
,aInstanceID
,aSHCode

 ); 
 PERFORM INVI_CHNG_SINIT( aCURSESSION,aINVI_CHNGid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_CHNG_PARENT_T /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_CHNG_PARENT_ID /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_CHNG where  INVI_CHNGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_ISLOCKED /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_CHNG where INVI_CHNGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_LOCK /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_CHNG_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_CHNG_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_CHNG set LockUserID =auserID ,LockSessionID =null where INVI_CHNGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_CHNG set LockUserID =null,LockSessionID =aCURSESSION  where INVI_CHNGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_HCL /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_UNLOCK /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_CHNG_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_CHNG set LockUserID =null  where INVI_CHNGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_CHNG set LockSessionID =null  where INVI_CHNGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_SINIT /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_CHNG_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_CHNG_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_CHNG set securitystyleid =aStyleID where INVI_CHNGid = aRowID;
else 
 update INVI_CHNG set securitystyleid =aSecurityStyleID where INVI_CHNGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_CHNG_propagate /*Нечитаемые, или испорченные штрихкоды*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_CHNG where INVI_CHNGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_OBJ_BRIEF  (
 aCURSESSION uuid,
 aINVI_OBJid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_OBJid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_OBJ where INVI_OBJID=aINVI_OBJID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_OBJ_BRIEF_F(aINVI_OBJid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_DELETE /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_OBJid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_OBJ where INVI_OBJID=aINVI_OBJID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_OBJ_ISLOCKED( acursession,aINVI_OBJid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_OBJ');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_OBJid as varchar),   'INVI_OBJ',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_OBJ' and OwnerRowID=aINVI_OBJid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_OBJ 
  where  INVI_OBJID = aINVI_OBJID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Объекты инвентаризации*/
 create or replace function  INVI_OBJ_SAVE /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_OBJid uuid,
ainstanceid uuid 
,aTheOS
 uuid/* Основное средство *//* Основное средство */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_OBJ where INVI_OBJID=aINVI_OBJID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_OBJ_ISLOCKED( acursession,aINVI_OBJid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_OBJ');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_OBJid as varchar),  'INVI_OBJ',
 'EDITROW',  aInstanceID);
 update  INVI_OBJ set ChangeStamp=localtimestamp
,
  TheOS=aTheOS
  where  INVI_OBJID = aINVI_OBJID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_OBJ');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_OBJid as varchar),  'INVI_OBJ',
 'CREATEROW',  aInstanceID);
 insert into   INVI_OBJ
 (  INVI_OBJID 
,InstanceID
,TheOS

 ) values ( aINVI_OBJID 
,aInstanceID
,aTheOS

 ); 
 PERFORM INVI_OBJ_SINIT( aCURSESSION,aINVI_OBJid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_OBJ_PARENT_T /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_OBJ_PARENT_ID /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_OBJ where  INVI_OBJid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_ISLOCKED /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_OBJ where INVI_OBJid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_LOCK /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_OBJ_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_OBJ_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_OBJ set LockUserID =auserID ,LockSessionID =null where INVI_OBJid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_OBJ set LockUserID =null,LockSessionID =aCURSESSION  where INVI_OBJid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_HCL /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_UNLOCK /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_OBJ_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_OBJ set LockUserID =null  where INVI_OBJid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_OBJ set LockSessionID =null  where INVI_OBJid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_SINIT /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_OBJ_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_OBJ_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_OBJ set securitystyleid =aStyleID where INVI_OBJid = aRowID;
else 
 update INVI_OBJ set securitystyleid =aSecurityStyleID where INVI_OBJid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_OBJ_propagate /*Объекты инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_OBJ where INVI_OBJid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_DONE_BRIEF  (
 aCURSESSION uuid,
 aINVI_DONEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_DONEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_DONE where INVI_DONEID=aINVI_DONEID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_DONE_BRIEF_F(aINVI_DONEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_DELETE /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_DONEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_DONE where INVI_DONEID=aINVI_DONEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_DONE_ISLOCKED( acursession,aINVI_DONEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_DONE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_DONEid as varchar),   'INVI_DONE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_DONE' and OwnerRowID=aINVI_DONEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_DONE 
  where  INVI_DONEID = aINVI_DONEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отметки об инвентаризации*/
 create or replace function  INVI_DONE_SAVE /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_DONEid uuid,
ainstanceid uuid 
,aCheckDate
 timestamp/* Дата проверки *//* Дата проверки */
,aTheOS
 uuid/* Основное средство *//* Основное средство */
,aOSStatus
 uuid/* Состояние *//* Состояние */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_DONE where INVI_DONEID=aINVI_DONEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_DONE_ISLOCKED( acursession,aINVI_DONEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_DONE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_DONEid as varchar),  'INVI_DONE',
 'EDITROW',  aInstanceID);
 update  INVI_DONE set ChangeStamp=localtimestamp
,
  CheckDate=aCheckDate
,
  TheOS=aTheOS
,
  OSStatus=aOSStatus
  where  INVI_DONEID = aINVI_DONEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_DONE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_DONEid as varchar),  'INVI_DONE',
 'CREATEROW',  aInstanceID);
 insert into   INVI_DONE
 (  INVI_DONEID 
,InstanceID
,CheckDate

,TheOS

,OSStatus

 ) values ( aINVI_DONEID 
,aInstanceID
,aCheckDate

,aTheOS

,aOSStatus

 ); 
 PERFORM INVI_DONE_SINIT( aCURSESSION,aINVI_DONEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_DONE_PARENT_T /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_DONE_PARENT_ID /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_DONE where  INVI_DONEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_ISLOCKED /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_DONE where INVI_DONEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_LOCK /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_DONE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_DONE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_DONE set LockUserID =auserID ,LockSessionID =null where INVI_DONEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_DONE set LockUserID =null,LockSessionID =aCURSESSION  where INVI_DONEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_HCL /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_UNLOCK /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_DONE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_DONE set LockUserID =null  where INVI_DONEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_DONE set LockSessionID =null  where INVI_DONEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_SINIT /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_DONE_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_DONE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_DONE set securitystyleid =aStyleID where INVI_DONEid = aRowID;
else 
 update INVI_DONE set securitystyleid =aSecurityStyleID where INVI_DONEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_DONE_propagate /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_DONE where INVI_DONEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVI_UNK_BRIEF  (
 aCURSESSION uuid,
 aINVI_UNKid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVI_UNKid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVI_UNK where INVI_UNKID=aINVI_UNKID;
if existsCnt &gt;0
 then
  aBRIEF:= INVI_UNK_BRIEF_F(aINVI_UNKid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_DELETE /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_UNKid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVI_UNK where INVI_UNKID=aINVI_UNKID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVI_UNK_ISLOCKED( acursession,aINVI_UNKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVI_UNK');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVI_UNKid as varchar),   'INVI_UNK',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVI_UNK' and OwnerRowID=aINVI_UNKid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVI_UNK 
  where  INVI_UNKID = aINVI_UNKID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Неучтенные объекты*/
 create or replace function  INVI_UNK_SAVE /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aINVI_UNKid uuid,
ainstanceid uuid 
,aTheRoom
 VARCHAR/* Помещение *//* Помещение */
,aInfo
 TEXT/* Описание объекта *//* Описание объекта */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVI_UNK where INVI_UNKID=aINVI_UNKID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVI_UNK_ISLOCKED( acursession,aINVI_UNKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_UNK');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVI_UNKid as varchar),  'INVI_UNK',
 'EDITROW',  aInstanceID);
 update  INVI_UNK set ChangeStamp=localtimestamp
,
  TheRoom=aTheRoom
,
  Info=aInfo
  where  INVI_UNKID = aINVI_UNKID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVI_UNK');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVI_UNKid as varchar),  'INVI_UNK',
 'CREATEROW',  aInstanceID);
 insert into   INVI_UNK
 (  INVI_UNKID 
,InstanceID
,TheRoom

,Info

 ) values ( aINVI_UNKID 
,aInstanceID
,aTheRoom

,aInfo

 ); 
 PERFORM INVI_UNK_SINIT( aCURSESSION,aINVI_UNKid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVI_UNK_PARENT_T /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVI_UNK_PARENT_ID /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVI_UNK where  INVI_UNKid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_ISLOCKED /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVI_UNK where INVI_UNKid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_LOCK /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVI_UNK_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVI_UNK_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVI_UNK set LockUserID =auserID ,LockSessionID =null where INVI_UNKid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVI_UNK set LockUserID =null,LockSessionID =aCURSESSION  where INVI_UNKid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_HCL /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_UNLOCK /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVI_UNK_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVI_UNK set LockUserID =null  where INVI_UNKid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVI_UNK set LockSessionID =null  where INVI_UNKid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_SINIT /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVI_UNK_parent_T( aCURSESSION,aROWID);
 aParentID:= INVI_UNK_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVI_UNK set securitystyleid =aStyleID where INVI_UNKid = aRowID;
else 
 update INVI_UNK set securitystyleid =aSecurityStyleID where INVI_UNKid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVI_UNK_propagate /*Неучтенные объекты, без штрихкодов обнаруженные в процессе инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVI_UNK where INVI_UNKid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDJournalExt" BlockCode=" create or replace function  STDJournalExt_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='STDJournalExt'
then
Open aCurs  for select STDJournlaExtInfo.STDJournlaExtInfoid ID from STDJournlaExtInfo where  STDJournlaExtInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournlaExtInfo_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select STDJournalExtParam.STDJournalExtParamid ID from STDJournalExtParam where  STDJournalExtParam.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournalExtParam_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select STDJournalExtFlt.STDJournalExtFltid ID from STDJournalExtFlt where  STDJournalExtFlt.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournalExtFlt_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExt_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'STDJournalExt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select STDJournlaExtInfo.STDJournlaExtInfoid ID from STDJournlaExtInfo where  STDJournlaExtInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from STDJournlaExtInfo where STDJournlaExtInfoid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= STDJournlaExtInfo_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select STDJournalExtParam.STDJournalExtParamid ID from STDJournalExtParam where  STDJournalExtParam.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from STDJournalExtParam where STDJournalExtParamid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= STDJournalExtParam_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select STDJournalExtFlt.STDJournalExtFltid ID from STDJournalExtFlt where  STDJournalExtFlt.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from STDJournalExtFlt where STDJournalExtFltid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= STDJournalExtFlt_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDJournalExt_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'STDJournalExt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select STDJournlaExtInfo.STDJournlaExtInfoid id from STDJournlaExtInfo where  STDJournlaExtInfo.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournlaExtInfo_SINIT( acursession,aid,assid);
 PERFORM STDJournlaExtInfo_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select STDJournalExtParam.STDJournalExtParamid id from STDJournalExtParam where  STDJournalExtParam.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournalExtParam_SINIT( acursession,aid,assid);
 PERFORM STDJournalExtParam_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select STDJournalExtFlt.STDJournalExtFltid id from STDJournalExtFlt where  STDJournalExtFlt.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM STDJournalExtFlt_SINIT( acursession,aid,assid);
 PERFORM STDJournalExtFlt_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  STDJournlaExtInfo_BRIEF  (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSTDJournlaExtInfoid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from STDJournlaExtInfo where STDJournlaExtInfoID=aSTDJournlaExtInfoID;
if existsCnt &gt;0
 then
  aBRIEF:= STDJournlaExtInfo_BRIEF_F(aSTDJournlaExtInfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_DELETE /**/ (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STDJournlaExtInfo where STDJournlaExtInfoID=aSTDJournlaExtInfoID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  STDJournlaExtInfo_ISLOCKED( acursession,aSTDJournlaExtInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STDJournlaExtInfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='STDJournlaExtInfo' and OwnerRowID=aSTDJournlaExtInfoid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  STDJournlaExtInfo 
  where  STDJournlaExtInfoID = aSTDJournlaExtInfoID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание расширения Журнал*/
 create or replace function  STDJournlaExtInfo_SAVE /**/ (
 aCURSESSION uuid,
 aSTDJournlaExtInfoid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheJournalRef
 uuid/* Журнал *//* Журнал */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STDJournlaExtInfo where STDJournlaExtInfoID=aSTDJournlaExtInfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  STDJournlaExtInfo_ISLOCKED( acursession,aSTDJournlaExtInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournlaExtInfo');
    return;
  end if;
 -- update row  --
 update  STDJournlaExtInfo set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  TheJournalRef=aTheJournalRef
  where  STDJournlaExtInfoID = aSTDJournlaExtInfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournlaExtInfo');
    return;
  end if;
select Count(*) into existsCnt from STDJournlaExtInfo where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;STDJournlaExtInfo&gt;');
    return;
 End if;
 insert into   STDJournlaExtInfo
 (  STDJournlaExtInfoID 
,InstanceID
,TheName

,TheJournalRef

 ) values ( aSTDJournlaExtInfoID 
,aInstanceID
,aTheName

,aTheJournalRef

 ); 
 PERFORM STDJournlaExtInfo_SINIT( aCURSESSION,aSTDJournlaExtInfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  STDJournlaExtInfo_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  STDJournlaExtInfo_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from STDJournlaExtInfo where  STDJournlaExtInfoid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STDJournlaExtInfo where STDJournlaExtInfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= STDJournlaExtInfo_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= STDJournlaExtInfo_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update STDJournlaExtInfo set LockUserID =auserID ,LockSessionID =null where STDJournlaExtInfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STDJournlaExtInfo set LockUserID =null,LockSessionID =aCURSESSION  where STDJournlaExtInfoid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= STDJournlaExtInfo_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STDJournlaExtInfo set LockUserID =null  where STDJournlaExtInfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STDJournlaExtInfo set LockSessionID =null  where STDJournlaExtInfoid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=STDJournlaExtInfo_parent_T( aCURSESSION,aROWID);
 aParentID:= STDJournlaExtInfo_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update STDJournlaExtInfo set securitystyleid =aStyleID where STDJournlaExtInfoid = aRowID;
else 
 update STDJournlaExtInfo set securitystyleid =aSecurityStyleID where STDJournlaExtInfoid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournlaExtInfo_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from STDJournlaExtInfo where STDJournlaExtInfoid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  STDJournalExtParam_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSTDJournalExtParamid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from STDJournalExtParam where STDJournalExtParamID=aSTDJournalExtParamID;
if existsCnt &gt;0
 then
  aBRIEF:= STDJournalExtParam_BRIEF_F(aSTDJournalExtParamid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_DELETE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STDJournalExtParam where STDJournalExtParamID=aSTDJournalExtParamID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  STDJournalExtParam_ISLOCKED( acursession,aSTDJournalExtParamid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STDJournalExtParam');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='STDJournalExtParam' and OwnerRowID=aSTDJournalExtParamid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  STDJournalExtParam 
  where  STDJournalExtParamID = aSTDJournalExtParamID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Параметры*/
 create or replace function  STDJournalExtParam_SAVE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtParamid uuid,
ainstanceid uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STDJournalExtParam where STDJournalExtParamID=aSTDJournalExtParamID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  STDJournalExtParam_ISLOCKED( acursession,aSTDJournalExtParamid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtParam');
    return;
  end if;
 -- update row  --
 update  STDJournalExtParam set ChangeStamp=localtimestamp
,
  FieldName=aFieldName
,
  ParamName=aParamName
,
  TargetPlatform=aTargetPlatform
  where  STDJournalExtParamID = aSTDJournalExtParamID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtParam');
    return;
  end if;
 insert into   STDJournalExtParam
 (  STDJournalExtParamID 
,InstanceID
,FieldName

,ParamName

,TargetPlatform

 ) values ( aSTDJournalExtParamID 
,aInstanceID
,aFieldName

,aParamName

,aTargetPlatform

 ); 
 PERFORM STDJournalExtParam_SINIT( aCURSESSION,aSTDJournalExtParamid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  STDJournalExtParam_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtParam_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from STDJournalExtParam where  STDJournalExtParamid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STDJournalExtParam where STDJournalExtParamid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtParam_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= STDJournalExtParam_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update STDJournalExtParam set LockUserID =auserID ,LockSessionID =null where STDJournalExtParamid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STDJournalExtParam set LockUserID =null,LockSessionID =aCURSESSION  where STDJournalExtParamid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtParam_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STDJournalExtParam set LockUserID =null  where STDJournalExtParamid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STDJournalExtParam set LockSessionID =null  where STDJournalExtParamid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=STDJournalExtParam_parent_T( aCURSESSION,aROWID);
 aParentID:= STDJournalExtParam_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update STDJournalExtParam set securitystyleid =aStyleID where STDJournalExtParamid = aRowID;
else 
 update STDJournalExtParam set securitystyleid =aSecurityStyleID where STDJournalExtParamid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtParam_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from STDJournalExtParam where STDJournalExtParamid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  STDJournalExtFlt_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSTDJournalExtFltid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from STDJournalExtFlt where STDJournalExtFltID=aSTDJournalExtFltID;
if existsCnt &gt;0
 then
  aBRIEF:= STDJournalExtFlt_BRIEF_F(aSTDJournalExtFltid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_DELETE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STDJournalExtFlt where STDJournalExtFltID=aSTDJournalExtFltID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  STDJournalExtFlt_ISLOCKED( acursession,aSTDJournalExtFltid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STDJournalExtFlt');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select STDJournalExtField.STDJournalExtFieldid ID from STDJournalExtField where  STDJournalExtField.ParentStructRowID = aSTDJournalExtFltid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  STDJournalExtField_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aSTDJournalExtFltid as varchar),   'STDJournalExtFlt',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='STDJournalExtFlt' and OwnerRowID=aSTDJournalExtFltid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  STDJournalExtFlt 
  where  STDJournalExtFltID = aSTDJournalExtFltID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Фильтры журнала*/
 create or replace function  STDJournalExtFlt_SAVE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtFltid uuid,
ainstanceid uuid 
,aViewSource
 VARCHAR/* Источник журнала *//* Источник журнала */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STDJournalExtFlt where STDJournalExtFltID=aSTDJournalExtFltID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  STDJournalExtFlt_ISLOCKED( acursession,aSTDJournalExtFltid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtFlt');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aSTDJournalExtFltid as varchar),  'STDJournalExtFlt',
 'EDITROW',  aInstanceID);
 update  STDJournalExtFlt set ChangeStamp=localtimestamp
,
  ViewSource=aViewSource
  where  STDJournalExtFltID = aSTDJournalExtFltID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtFlt');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aSTDJournalExtFltid as varchar),  'STDJournalExtFlt',
 'CREATEROW',  aInstanceID);
 insert into   STDJournalExtFlt
 (  STDJournalExtFltID 
,InstanceID
,ViewSource

 ) values ( aSTDJournalExtFltID 
,aInstanceID
,aViewSource

 ); 
 PERFORM STDJournalExtFlt_SINIT( aCURSESSION,aSTDJournalExtFltid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  STDJournalExtFlt_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtFlt_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from STDJournalExtFlt where  STDJournalExtFltid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STDJournalExtFlt where STDJournalExtFltid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtFlt_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= STDJournalExtFlt_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update STDJournalExtFlt set LockUserID =auserID ,LockSessionID =null where STDJournalExtFltid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STDJournalExtFlt set LockUserID =null,LockSessionID =aCURSESSION  where STDJournalExtFltid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select STDJournalExtField.STDJournalExtFieldid ID from STDJournalExtField where  STDJournalExtField.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from STDJournalExtField where STDJournalExtFieldid=row_STDJournalExtField.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= STDJournalExtField_HCL (acursession,row_STDJournalExtField.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtFlt_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STDJournalExtFlt set LockUserID =null  where STDJournalExtFltid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STDJournalExtFlt set LockSessionID =null  where STDJournalExtFltid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=STDJournalExtFlt_parent_T( aCURSESSION,aROWID);
 aParentID:= STDJournalExtFlt_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update STDJournalExtFlt set securitystyleid =aStyleID where STDJournalExtFltid = aRowID;
else 
 update STDJournalExtFlt set securitystyleid =aSecurityStyleID where STDJournalExtFltid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtFlt_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from STDJournalExtFlt where STDJournalExtFltid=aRowid;
open aCurs for select STDJournalExtField.STDJournalExtFieldid ID from STDJournalExtField where  STDJournalExtField.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  STDJournalExtField_SINIT( acursession,aid,assid);
 PERFORM  STDJournalExtField_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  STDJournalExtField_BRIEF  (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSTDJournalExtFieldid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from STDJournalExtField where STDJournalExtFieldID=aSTDJournalExtFieldID;
if existsCnt &gt;0
 then
  aBRIEF:= STDJournalExtField_BRIEF_F(aSTDJournalExtFieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_DELETE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STDJournalExtField where STDJournalExtFieldID=aSTDJournalExtFieldID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  STDJournalExtField_ISLOCKED( acursession,aSTDJournalExtFieldid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STDJournalExtField');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aSTDJournalExtFieldid as varchar),   'STDJournalExtField',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='STDJournalExtField' and OwnerRowID=aSTDJournalExtFieldid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  STDJournalExtField 
  where  STDJournalExtFieldID = aSTDJournalExtFieldID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Параметры фильтра*/
 create or replace function  STDJournalExtField_SAVE /**/ (
 aCURSESSION uuid,
 aSTDJournalExtFieldid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aViewField
 VARCHAR/* Колонка журнала *//* Колонка журнала */
,aFieldSource
 VARCHAR/* Поле *//* Поле */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aConstantValue
 VARCHAR/* Значение *//* Значение */
,aConditionType
 INTEGER/* Условие *//* Условие */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STDJournalExtField where STDJournalExtFieldID=aSTDJournalExtFieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  STDJournalExtField_ISLOCKED( acursession,aSTDJournalExtFieldid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtField');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aSTDJournalExtFieldid as varchar),  'STDJournalExtField',
 'EDITROW',  aInstanceID);
 update  STDJournalExtField set ChangeStamp=localtimestamp
,
  ViewField=aViewField
,
  FieldSource=aFieldSource
,
  TargetPlatform=aTargetPlatform
,
  ConstantValue=aConstantValue
,
  ConditionType=aConditionType
  where  STDJournalExtFieldID = aSTDJournalExtFieldID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= STDJournalExtFlt_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STDJournalExtField');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aSTDJournalExtFieldid as varchar),  'STDJournalExtField',
 'CREATEROW',  aInstanceID);
 insert into   STDJournalExtField
 (  STDJournalExtFieldID 
,ParentStructRowID
,ViewField

,FieldSource

,TargetPlatform

,ConstantValue

,ConditionType

 ) values ( aSTDJournalExtFieldID 
,aParentStructRowID
,aViewField

,aFieldSource

,aTargetPlatform

,aConstantValue

,aConditionType

 ); 
 PERFORM STDJournalExtField_SINIT( aCURSESSION,aSTDJournalExtFieldid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  STDJournalExtField_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'STDJournalExtFlt';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  STDJournalExtField_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from STDJournalExtField where  STDJournalExtFieldid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STDJournalExtField where STDJournalExtFieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtField_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= STDJournalExtField_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update STDJournalExtField set LockUserID =auserID ,LockSessionID =null where STDJournalExtFieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STDJournalExtField set LockUserID =null,LockSessionID =aCURSESSION  where STDJournalExtFieldid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= STDJournalExtField_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STDJournalExtField set LockUserID =null  where STDJournalExtFieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STDJournalExtField set LockSessionID =null  where STDJournalExtFieldid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=STDJournalExtField_parent_T( aCURSESSION,aROWID);
 aParentID:= STDJournalExtField_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update STDJournalExtField set securitystyleid =aStyleID where STDJournalExtFieldid = aRowID;
else 
 update STDJournalExtField set securitystyleid =aSecurityStyleID where STDJournalExtFieldid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  STDJournalExtField_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from STDJournalExtField where STDJournalExtFieldid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZMetaModel" BlockCode=" create or replace function  MTZMetaModel_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZMetaModel'
then
Open aCurs  for select FIELDTYPE.FIELDTYPEid ID from FIELDTYPE where  FIELDTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM FIELDTYPE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select SHAREDMETHOD.SHAREDMETHODid ID from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SHAREDMETHOD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select OBJECTTYPE.OBJECTTYPEid ID from OBJECTTYPE where  OBJECTTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM OBJECTTYPE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select MTZAPP.MTZAPPid ID from MTZAPP where  MTZAPP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZAPP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select GENPACKAGE.GENPACKAGEid ID from GENPACKAGE where  GENPACKAGE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM GENPACKAGE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select LocalizeInfo.LocalizeInfoid ID from LocalizeInfo where  LocalizeInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM LocalizeInfo_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZMetaModel_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZMetaModel'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select FIELDTYPE.FIELDTYPEid ID from FIELDTYPE where  FIELDTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from FIELDTYPE where FIELDTYPEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= FIELDTYPE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select SHAREDMETHOD.SHAREDMETHODid ID from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SHAREDMETHOD where SHAREDMETHODid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= SHAREDMETHOD_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select OBJECTTYPE.OBJECTTYPEid ID from OBJECTTYPE where  OBJECTTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from OBJECTTYPE where OBJECTTYPEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= OBJECTTYPE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select MTZAPP.MTZAPPid ID from MTZAPP where  MTZAPP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZAPP where MTZAPPid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZAPP_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select GENPACKAGE.GENPACKAGEid ID from GENPACKAGE where  GENPACKAGE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from GENPACKAGE where GENPACKAGEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= GENPACKAGE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select LocalizeInfo.LocalizeInfoid ID from LocalizeInfo where  LocalizeInfo.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from LocalizeInfo where LocalizeInfoid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= LocalizeInfo_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZMetaModel_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZMetaModel'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select FIELDTYPE.FIELDTYPEid id from FIELDTYPE where  FIELDTYPE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM FIELDTYPE_SINIT( acursession,aid,assid);
 PERFORM FIELDTYPE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select SHAREDMETHOD.SHAREDMETHODid id from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SHAREDMETHOD_SINIT( acursession,aid,assid);
 PERFORM SHAREDMETHOD_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select OBJECTTYPE.OBJECTTYPEid id from OBJECTTYPE where  OBJECTTYPE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM OBJECTTYPE_SINIT( acursession,aid,assid);
 PERFORM OBJECTTYPE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select MTZAPP.MTZAPPid id from MTZAPP where  MTZAPP.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZAPP_SINIT( acursession,aid,assid);
 PERFORM MTZAPP_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select GENPACKAGE.GENPACKAGEid id from GENPACKAGE where  GENPACKAGE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM GENPACKAGE_SINIT( acursession,aid,assid);
 PERFORM GENPACKAGE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select LocalizeInfo.LocalizeInfoid id from LocalizeInfo where  LocalizeInfo.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM LocalizeInfo_SINIT( acursession,aid,assid);
 PERFORM LocalizeInfo_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  FIELDTYPE_BRIEF  (
 aCURSESSION uuid,
 aFIELDTYPEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDTYPEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDTYPE_BRIEF_F(aFIELDTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_DELETE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aFIELDTYPEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDTYPE_ISLOCKED( acursession,aFIELDTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aFIELDTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDTYPEMAP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aFIELDTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ENUMITEM_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDTYPEid as varchar),   'FIELDTYPE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDTYPE' and OwnerRowID=aFIELDTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDTYPE 
  where  FIELDTYPEID = aFIELDTYPEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Тип поля*/
 create or replace function  FIELDTYPE_SAVE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aFIELDTYPEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTypeStyle
 INTEGER/* Трактовка *//* Трактовка */
,athe_Comment
 TEXT/* Описание *//* Описание */
,aAllowSize
 INTEGER/* Нужен размер *//* Нужен размер */
,aMinimum
 VARCHAR/* Минимум *//* Минимум */
,aMaximum
 VARCHAR/* Максимум *//* Максимум */
,aAllowLikeSearch
 INTEGER/* Поиск текста *//* Поиск текста */
,aGridSortType
 INTEGER/* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDTYPE_ISLOCKED( acursession,aFIELDTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDTYPEid as varchar),  'FIELDTYPE',
 'EDITROW',  aInstanceID);
 update  FIELDTYPE set ChangeStamp=localtimestamp
,
  Name=aName
,
  TypeStyle=aTypeStyle
,
  the_Comment=athe_Comment
,
  AllowSize=aAllowSize
,
  Minimum=aMinimum
,
  Maximum=aMaximum
,
  AllowLikeSearch=aAllowLikeSearch
,
  GridSortType=aGridSortType
  where  FIELDTYPEID = aFIELDTYPEID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELDTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELDTYPE');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDTYPEid as varchar),  'FIELDTYPE',
 'CREATEROW',  aInstanceID);
 insert into   FIELDTYPE
 (  FIELDTYPEID 
,InstanceID
,Name

,TypeStyle

,the_Comment

,AllowSize

,Minimum

,Maximum

,AllowLikeSearch

,GridSortType

 ) values ( aFIELDTYPEID 
,aInstanceID
,aName

,aTypeStyle

,athe_Comment

,aAllowSize

,aMinimum

,aMaximum

,aAllowLikeSearch

,aGridSortType

 ); 
 PERFORM FIELDTYPE_SINIT( aCURSESSION,aFIELDTYPEid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELDTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELDTYPE');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDTYPE_PARENT_T /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPE_PARENT_ID /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from FIELDTYPE where  FIELDTYPEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_ISLOCKED /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDTYPE where FIELDTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_LOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDTYPE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDTYPE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDTYPE set LockUserID =auserID ,LockSessionID =null where FIELDTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDTYPE set LockUserID =null,LockSessionID =aCURSESSION  where FIELDTYPEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_HCL /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDTYPEMAP where FIELDTYPEMAPid=row_FIELDTYPEMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDTYPEMAP_HCL (acursession,row_FIELDTYPEMAP.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ENUMITEM where ENUMITEMid=row_ENUMITEM.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ENUMITEM_HCL (acursession,row_ENUMITEM.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_UNLOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDTYPE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDTYPE set LockUserID =null  where FIELDTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDTYPE set LockSessionID =null  where FIELDTYPEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_SINIT /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDTYPE_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDTYPE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDTYPE set securitystyleid =aStyleID where FIELDTYPEid = aRowID;
else 
 update FIELDTYPE set securitystyleid =aSecurityStyleID where FIELDTYPEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPE_propagate /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDTYPE where FIELDTYPEid=aRowid;
open aCurs for select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDTYPEMAP_SINIT( acursession,aid,assid);
 PERFORM  FIELDTYPEMAP_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ENUMITEM_SINIT( acursession,aid,assid);
 PERFORM  ENUMITEM_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDTYPEMAP_BRIEF  (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDTYPEMAPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDTYPEMAP_BRIEF_F(aFIELDTYPEMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_DELETE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDTYPEMAP_ISLOCKED( acursession,aFIELDTYPEMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDTYPEMAPid as varchar),   'FIELDTYPEMAP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDTYPEMAP' and OwnerRowID=aFIELDTYPEMAPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDTYPEMAP 
  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отображение*/
 create or replace function  FIELDTYPEMAP_SAVE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aFIELDTYPEMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aStoageType
 VARCHAR/* Тип хранения *//* Тип хранения */
,aFixedSize
 integer/* Размер *//* Размер */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDTYPEMAP_ISLOCKED( acursession,aFIELDTYPEMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDTYPEMAPid as varchar),  'FIELDTYPEMAP',
 'EDITROW',  aInstanceID);
 update  FIELDTYPEMAP set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  StoageType=aStoageType
,
  FixedSize=aFixedSize
  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELDTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDTYPEMAPid as varchar),  'FIELDTYPEMAP',
 'CREATEROW',  aInstanceID);
 insert into   FIELDTYPEMAP
 (  FIELDTYPEMAPID 
,ParentStructRowID
,Target

,StoageType

,FixedSize

 ) values ( aFIELDTYPEMAPID 
,aParentStructRowID
,aTarget

,aStoageType

,aFixedSize

 ); 
 PERFORM FIELDTYPEMAP_SINIT( aCURSESSION,aFIELDTYPEMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDTYPEMAP_PARENT_T /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELDTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDTYPEMAP_PARENT_ID /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDTYPEMAP where  FIELDTYPEMAPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_ISLOCKED /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDTYPEMAP where FIELDTYPEMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_LOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDTYPEMAP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDTYPEMAP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDTYPEMAP set LockUserID =auserID ,LockSessionID =null where FIELDTYPEMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDTYPEMAP set LockUserID =null,LockSessionID =aCURSESSION  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_HCL /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_UNLOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDTYPEMAP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDTYPEMAP set LockUserID =null  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDTYPEMAP set LockSessionID =null  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_SINIT /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDTYPEMAP_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDTYPEMAP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDTYPEMAP set securitystyleid =aStyleID where FIELDTYPEMAPid = aRowID;
else 
 update FIELDTYPEMAP set securitystyleid =aSecurityStyleID where FIELDTYPEMAPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDTYPEMAP_propagate /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDTYPEMAP where FIELDTYPEMAPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ENUMITEM_BRIEF  (
 aCURSESSION uuid,
 aENUMITEMid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aENUMITEMid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0
 then
  aBRIEF:= ENUMITEM_BRIEF_F(aENUMITEMid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_DELETE /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aENUMITEMid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ENUMITEM_ISLOCKED( acursession,aENUMITEMid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ENUMITEM');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aENUMITEMid as varchar),   'ENUMITEM',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ENUMITEM' and OwnerRowID=aENUMITEMid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ENUMITEM 
  where  ENUMITEMID = aENUMITEMID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Зачения*/
 create or replace function  ENUMITEM_SAVE /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aENUMITEMid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aNameValue
 integer/* Значение *//* Значение */
,aNameInCode
 VARCHAR/* Название в коде *//* Название в коде */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ENUMITEM_ISLOCKED( acursession,aENUMITEMid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ENUMITEM');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aENUMITEMid as varchar),  'ENUMITEM',
 'EDITROW',  aInstanceID);
 update  ENUMITEM set ChangeStamp=localtimestamp
,
  Name=aName
,
  NameValue=aNameValue
,
  NameInCode=aNameInCode
  where  ENUMITEMID = aENUMITEMID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and NameValue=aNameValue;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;
select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELDTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ENUMITEM');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aENUMITEMid as varchar),  'ENUMITEM',
 'CREATEROW',  aInstanceID);
 insert into   ENUMITEM
 (  ENUMITEMID 
,ParentStructRowID
,Name

,NameValue

,NameInCode

 ) values ( aENUMITEMID 
,aParentStructRowID
,aName

,aNameValue

,aNameInCode

 ); 
 PERFORM ENUMITEM_SINIT( aCURSESSION,aENUMITEMid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and NameValue=aNameValue;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;
select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ENUMITEM_PARENT_T /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELDTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ENUMITEM_PARENT_ID /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ENUMITEM where  ENUMITEMid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_ISLOCKED /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ENUMITEM where ENUMITEMid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_LOCK /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ENUMITEM_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ENUMITEM_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ENUMITEM set LockUserID =auserID ,LockSessionID =null where ENUMITEMid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ENUMITEM set LockUserID =null,LockSessionID =aCURSESSION  where ENUMITEMid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_HCL /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_UNLOCK /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ENUMITEM_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ENUMITEM set LockUserID =null  where ENUMITEMid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ENUMITEM set LockSessionID =null  where ENUMITEMid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_SINIT /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ENUMITEM_parent_T( aCURSESSION,aROWID);
 aParentID:= ENUMITEM_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ENUMITEM set securitystyleid =aStyleID where ENUMITEMid = aRowID;
else 
 update ENUMITEM set securitystyleid =aSecurityStyleID where ENUMITEMid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ENUMITEM_propagate /*Для описания Enum типов*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ENUMITEM where ENUMITEMid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  SHAREDMETHOD_BRIEF  (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSHAREDMETHODid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0
 then
  aBRIEF:= SHAREDMETHOD_BRIEF_F(aSHAREDMETHODid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_DELETE /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  SHAREDMETHOD_ISLOCKED( acursession,aSHAREDMETHODid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SHAREDMETHOD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aSHAREDMETHODid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  SCRIPT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aSHAREDMETHODid as varchar),   'SHAREDMETHOD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='SHAREDMETHOD' and OwnerRowID=aSHAREDMETHODid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  SHAREDMETHOD 
  where  SHAREDMETHODID = aSHAREDMETHODID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Методы и процедуры*/
 create or replace function  SHAREDMETHOD_SAVE /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aSHAREDMETHODid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Comment
 TEXT/* Описание метода *//* Описание метода */
,aReturnType
 uuid/* Возвращаемый тип *//* Возвращаемый тип */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  SHAREDMETHOD_ISLOCKED( acursession,aSHAREDMETHODid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SHAREDMETHOD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aSHAREDMETHODid as varchar),  'SHAREDMETHOD',
 'EDITROW',  aInstanceID);
 update  SHAREDMETHOD set ChangeStamp=localtimestamp
,
  Name=aName
,
  the_Comment=athe_Comment
,
  ReturnType=aReturnType
  where  SHAREDMETHODID = aSHAREDMETHODID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from SHAREDMETHOD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=SHAREDMETHOD');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SHAREDMETHOD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aSHAREDMETHODid as varchar),  'SHAREDMETHOD',
 'CREATEROW',  aInstanceID);
 insert into   SHAREDMETHOD
 (  SHAREDMETHODID 
,InstanceID
,Name

,the_Comment

,ReturnType

 ) values ( aSHAREDMETHODID 
,aInstanceID
,aName

,athe_Comment

,aReturnType

 ); 
 PERFORM SHAREDMETHOD_SINIT( aCURSESSION,aSHAREDMETHODid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from SHAREDMETHOD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=SHAREDMETHOD');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  SHAREDMETHOD_PARENT_T /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  SHAREDMETHOD_PARENT_ID /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from SHAREDMETHOD where  SHAREDMETHODid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_ISLOCKED /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SHAREDMETHOD where SHAREDMETHODid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_LOCK /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= SHAREDMETHOD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= SHAREDMETHOD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update SHAREDMETHOD set LockUserID =auserID ,LockSessionID =null where SHAREDMETHODid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SHAREDMETHOD set LockUserID =null,LockSessionID =aCURSESSION  where SHAREDMETHODid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_HCL /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from SCRIPT where SCRIPTid=row_SCRIPT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= SCRIPT_HCL (acursession,row_SCRIPT.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_UNLOCK /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= SHAREDMETHOD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SHAREDMETHOD set LockUserID =null  where SHAREDMETHODid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SHAREDMETHOD set LockSessionID =null  where SHAREDMETHODid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_SINIT /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=SHAREDMETHOD_parent_T( aCURSESSION,aROWID);
 aParentID:= SHAREDMETHOD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update SHAREDMETHOD set securitystyleid =aStyleID where SHAREDMETHODid = aRowID;
else 
 update SHAREDMETHOD set securitystyleid =aSecurityStyleID where SHAREDMETHODid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  SHAREDMETHOD_propagate /*Методы и процедуры*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from SHAREDMETHOD where SHAREDMETHODid=aRowid;
open aCurs for select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  SCRIPT_SINIT( acursession,aid,assid);
 PERFORM  SCRIPT_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  SCRIPT_BRIEF  (
 aCURSESSION uuid,
 aSCRIPTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSCRIPTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0
 then
  aBRIEF:= SCRIPT_BRIEF_F(aSCRIPTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_DELETE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aSCRIPTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  SCRIPT_ISLOCKED( acursession,aSCRIPTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SCRIPT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aSCRIPTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARAMETERS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aSCRIPTid as varchar),   'SCRIPT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='SCRIPT' and OwnerRowID=aSCRIPTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  SCRIPT 
  where  SCRIPTID = aSCRIPTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Реализация*/
 create or replace function  SCRIPT_SAVE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aSCRIPTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  SCRIPT_ISLOCKED( acursession,aSCRIPTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SCRIPT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aSCRIPTid as varchar),  'SCRIPT',
 'EDITROW',  aInstanceID);
 update  SCRIPT set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  SCRIPTID = aSCRIPTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= SHAREDMETHOD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SCRIPT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aSCRIPTid as varchar),  'SCRIPT',
 'CREATEROW',  aInstanceID);
 insert into   SCRIPT
 (  SCRIPTID 
,ParentStructRowID
,Target

,Code

 ) values ( aSCRIPTID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM SCRIPT_SINIT( aCURSESSION,aSCRIPTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  SCRIPT_PARENT_T /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'SHAREDMETHOD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  SCRIPT_PARENT_ID /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from SCRIPT where  SCRIPTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_ISLOCKED /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SCRIPT where SCRIPTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_LOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= SCRIPT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= SCRIPT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update SCRIPT set LockUserID =auserID ,LockSessionID =null where SCRIPTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SCRIPT set LockUserID =null,LockSessionID =aCURSESSION  where SCRIPTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_HCL /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARAMETERS where PARAMETERSid=row_PARAMETERS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PARAMETERS_HCL (acursession,row_PARAMETERS.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  SCRIPT_UNLOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= SCRIPT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SCRIPT set LockUserID =null  where SCRIPTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SCRIPT set LockSessionID =null  where SCRIPTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_SINIT /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=SCRIPT_parent_T( aCURSESSION,aROWID);
 aParentID:= SCRIPT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update SCRIPT set securitystyleid =aStyleID where SCRIPTid = aRowID;
else 
 update SCRIPT set securitystyleid =aSecurityStyleID where SCRIPTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  SCRIPT_propagate /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from SCRIPT where SCRIPTid=aRowid;
open aCurs for select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARAMETERS_SINIT( acursession,aid,assid);
 PERFORM  PARAMETERS_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  PARAMETERS_BRIEF  (
 aCURSESSION uuid,
 aPARAMETERSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARAMETERSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0
 then
  aBRIEF:= PARAMETERS_BRIEF_F(aPARAMETERSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_DELETE /*Параметры метода*/ (
 aCURSESSION uuid,
 aPARAMETERSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PARAMETERS_ISLOCKED( acursession,aPARAMETERSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARAMETERS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARAMETERSid as varchar),   'PARAMETERS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PARAMETERS' and OwnerRowID=aPARAMETERSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PARAMETERS 
  where  PARAMETERSID = aPARAMETERSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Параметры*/
 create or replace function  PARAMETERS_SAVE /*Параметры метода*/ (
 aCURSESSION uuid,
 aPARAMETERSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Имя *//* Имя */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTypeOfParm
 uuid/* Тип данных *//* Тип данных */
,aDataSize
 integer/* Размер *//* Размер */
,aAllowNull
 INTEGER/* Можно не задавать *//* Можно не задавать */
,aOutParam
 INTEGER/* Возвращает значение *//* Возвращает значение */
,aReferenceType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Ссылка на тип *//* Ссылка на тип */
,aRefToPart
 uuid/* Ссылка на раздел *//* Ссылка на раздел */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PARAMETERS_ISLOCKED( acursession,aPARAMETERSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARAMETERS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARAMETERSid as varchar),  'PARAMETERS',
 'EDITROW',  aInstanceID);
 update  PARAMETERS set ChangeStamp=localtimestamp
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  TypeOfParm=aTypeOfParm
,
  DataSize=aDataSize
,
  AllowNull=aAllowNull
,
  OutParam=aOutParam
,
  ReferenceType=aReferenceType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
  where  PARAMETERSID = aPARAMETERSID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;
select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= SCRIPT_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARAMETERS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARAMETERSid as varchar),  'PARAMETERS',
 'CREATEROW',  aInstanceID);
 insert into   PARAMETERS
 (  PARAMETERSID 
,ParentStructRowID
,sequence

,Name

,Caption

,TypeOfParm

,DataSize

,AllowNull

,OutParam

,ReferenceType

,RefToType

,RefToPart

 ) values ( aPARAMETERSID 
,aParentStructRowID
,asequence

,aName

,aCaption

,aTypeOfParm

,aDataSize

,aAllowNull

,aOutParam

,aReferenceType

,aRefToType

,aRefToPart

 ); 
 PERFORM PARAMETERS_SINIT( aCURSESSION,aPARAMETERSid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;
select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PARAMETERS_PARENT_T /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'SCRIPT';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PARAMETERS_PARENT_ID /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PARAMETERS where  PARAMETERSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_ISLOCKED /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARAMETERS where PARAMETERSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_LOCK /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PARAMETERS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PARAMETERS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PARAMETERS set LockUserID =auserID ,LockSessionID =null where PARAMETERSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARAMETERS set LockUserID =null,LockSessionID =aCURSESSION  where PARAMETERSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_HCL /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_UNLOCK /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PARAMETERS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARAMETERS set LockUserID =null  where PARAMETERSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARAMETERS set LockSessionID =null  where PARAMETERSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_SINIT /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PARAMETERS_parent_T( aCURSESSION,aROWID);
 aParentID:= PARAMETERS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PARAMETERS set securitystyleid =aStyleID where PARAMETERSid = aRowID;
else 
 update PARAMETERS set securitystyleid =aSecurityStyleID where PARAMETERSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PARAMETERS_propagate /*Параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PARAMETERS where PARAMETERSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  OBJECTTYPE_BRIEF  (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aOBJECTTYPEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0
 then
  aBRIEF:= OBJECTTYPE_BRIEF_F(aOBJECTTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_DELETE /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  OBJECTTYPE_ISLOCKED( acursession,aOBJECTTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJECTTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select PART.PARTid ID from PART where  PART.ParentStructRowID = aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PART_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCEVALIDATOR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  OBJSTATUS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  OBJECTMODE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  TYPEMENU_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aOBJECTTYPEid as varchar),   'OBJECTTYPE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='OBJECTTYPE' and OwnerRowID=aOBJECTTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  OBJECTTYPE 
  where  OBJECTTYPEID = aOBJECTTYPEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Тип объекта*/
 create or replace function  OBJECTTYPE_SAVE /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aOBJECTTYPEid uuid,
ainstanceid uuid 
,aPackage
 uuid/* Приложение *//* Приложение */
,athe_Comment
 VARCHAR/* Название *//* Название */
,aName
 VARCHAR/* Код *//* Код */
,aIsSingleInstance
 INTEGER/* Допускается только один объект *//* Допускается только один объект */
,aChooseView
 uuid/* Представление для выбора *//* Представление для выбора */
,aOnRun
 uuid/* При запуске *//* При запуске */
,aOnCreate
 uuid/* При создании *//* При создании */
,aOnDelete
 uuid/* При удалении *//* При удалении */
,aAllowRefToObject
 INTEGER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aAllowSearch
 INTEGER/* Отображать при поиске *//* Отображать при поиске */
,aReplicaType
 INTEGER/* Тип репликации *//* Тип репликации */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  OBJECTTYPE_ISLOCKED( acursession,aOBJECTTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTTYPE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aOBJECTTYPEid as varchar),  'OBJECTTYPE',
 'EDITROW',  aInstanceID);
 update  OBJECTTYPE set ChangeStamp=localtimestamp
,
  Package=aPackage
,
  the_Comment=athe_Comment
,
  Name=aName
,
  IsSingleInstance=aIsSingleInstance
,
  ChooseView=aChooseView
,
  OnRun=aOnRun
,
  OnCreate=aOnCreate
,
  OnDelete=aOnDelete
,
  AllowRefToObject=aAllowRefToObject
,
  AllowSearch=aAllowSearch
,
  ReplicaType=aReplicaType
,
  TheComment=aTheComment
  where  OBJECTTYPEID = aOBJECTTYPEID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from OBJECTTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=OBJECTTYPE');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTTYPE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aOBJECTTYPEid as varchar),  'OBJECTTYPE',
 'CREATEROW',  aInstanceID);
 insert into   OBJECTTYPE
 (  OBJECTTYPEID 
,InstanceID
,Package

,the_Comment

,Name

,IsSingleInstance

,ChooseView

,OnRun

,OnCreate

,OnDelete

,AllowRefToObject

,AllowSearch

,ReplicaType

,TheComment

 ) values ( aOBJECTTYPEID 
,aInstanceID
,aPackage

,athe_Comment

,aName

,aIsSingleInstance

,aChooseView

,aOnRun

,aOnCreate

,aOnDelete

,aAllowRefToObject

,aAllowSearch

,aReplicaType

,aTheComment

 ); 
 PERFORM OBJECTTYPE_SINIT( aCURSESSION,aOBJECTTYPEid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from OBJECTTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=OBJECTTYPE');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  OBJECTTYPE_PARENT_T /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTTYPE_PARENT_ID /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from OBJECTTYPE where  OBJECTTYPEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_ISLOCKED /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJECTTYPE where OBJECTTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_LOCK /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= OBJECTTYPE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= OBJECTTYPE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update OBJECTTYPE set LockUserID =auserID ,LockSessionID =null where OBJECTTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJECTTYPE set LockUserID =null,LockSessionID =aCURSESSION  where OBJECTTYPEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_HCL /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select PART.PARTid ID from PART where  PART.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PART where PARTid=row_PART.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PART_HCL (acursession,row_PART.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=row_INSTANCEVALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INSTANCEVALIDATOR_HCL (acursession,row_INSTANCEVALIDATOR.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from OBJSTATUS where OBJSTATUSid=row_OBJSTATUS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= OBJSTATUS_HCL (acursession,row_OBJSTATUS.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from OBJECTMODE where OBJECTMODEid=row_OBJECTMODE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= OBJECTMODE_HCL (acursession,row_OBJECTMODE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from TYPEMENU where TYPEMENUid=row_TYPEMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= TYPEMENU_HCL (acursession,row_TYPEMENU.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_UNLOCK /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= OBJECTTYPE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJECTTYPE set LockUserID =null  where OBJECTTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJECTTYPE set LockSessionID =null  where OBJECTTYPEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_SINIT /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=OBJECTTYPE_parent_T( aCURSESSION,aROWID);
 aParentID:= OBJECTTYPE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update OBJECTTYPE set securitystyleid =aStyleID where OBJECTTYPEid = aRowID;
else 
 update OBJECTTYPE set securitystyleid =aSecurityStyleID where OBJECTTYPEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  OBJECTTYPE_propagate /*Тип объекта (карточки)*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from OBJECTTYPE where OBJECTTYPEid=aRowid;
open aCurs for select PART.PARTid ID from PART where  PART.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PART_SINIT( acursession,aid,assid);
 PERFORM  PART_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCEVALIDATOR_SINIT( acursession,aid,assid);
 PERFORM  INSTANCEVALIDATOR_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  OBJSTATUS_SINIT( acursession,aid,assid);
 PERFORM  OBJSTATUS_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  OBJECTMODE_SINIT( acursession,aid,assid);
 PERFORM  OBJECTMODE_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  TYPEMENU_SINIT( acursession,aid,assid);
 PERFORM  TYPEMENU_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  PART_BRIEF  (
 aCURSESSION uuid,
 aPARTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0
 then
  aBRIEF:= PART_BRIEF_F(aPARTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PART_DELETE /*Раздел объекта*/ (
 aCURSESSION uuid,
 aPARTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PART_ISLOCKED( acursession,aPARTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PART');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTMENU_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTVIEW_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ExtenderInterface_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  VALIDATOR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  UNIQUECONSTRAINT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARTid as varchar),   'PART',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PART' and OwnerRowID=aPARTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PART 
  where  PARTID = aPARTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Раздел*/
 create or replace function  PART_SAVE /*Раздел объекта*/ (
 aCURSESSION uuid,
 aPARTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
, aParentRowid uuid 
,aSequence
 integer/* № п/п *//* № п/п */
,aPartType
 INTEGER/* Тип структры  *//* Тип структры  */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aName
 VARCHAR/* Название *//* Название */
,athe_Comment
 TEXT/* Описание *//* Описание */
,aNoLog
 INTEGER/* Не записывать в журнал *//* Не записывать в журнал */
,aManualRegister
 INTEGER/* Исключить из индексирования *//* Исключить из индексирования */
,aOnCreate
 uuid/* При создании *//* При создании */
,aOnSave
 uuid/* При сохранении *//* При сохранении */
,aOnRun
 uuid/* При открытии *//* При открытии */
,aOnDelete
 uuid/* При удалении *//* При удалении */
,aAddBehaivor
 INTEGER/* Поведение при добавлении *//* Поведение при добавлении */
,aExtenderObject
 uuid/* Объект расширения *//* Объект расширения */
,ashablonBrief
 VARCHAR/* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,aruleBrief
 VARCHAR/* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aIsJormalChange
 INTEGER/* Вести журнал изменений *//* Вести журнал изменений */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PART_ISLOCKED( acursession,aPARTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PART');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARTid as varchar),  'PART',
 'EDITROW',  aInstanceID);
 update  PART set ChangeStamp=localtimestamp
,ParentRowid= aParentRowid
,
  Sequence=aSequence
,
  PartType=aPartType
,
  Caption=aCaption
,
  Name=aName
,
  the_Comment=athe_Comment
,
  NoLog=aNoLog
,
  ManualRegister=aManualRegister
,
  OnCreate=aOnCreate
,
  OnSave=aOnSave
,
  OnRun=aOnRun
,
  OnDelete=aOnDelete
,
  AddBehaivor=aAddBehaivor
,
  ExtenderObject=aExtenderObject
,
  shablonBrief=ashablonBrief
,
  ruleBrief=aruleBrief
,
  IsJormalChange=aIsJormalChange
  where  PARTID = aPARTID; 
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and Sequence=aSequence;
 else 
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and Sequence=aSequence;
 end if;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;
select Count(*) into aUniqueRowCount from PART where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PART');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARTid as varchar),  'PART',
 'CREATEROW',  aInstanceID);
 insert into   PART
 (  PARTID 
,ParentRowid
,ParentStructRowID
,Sequence

,PartType

,Caption

,Name

,the_Comment

,NoLog

,ManualRegister

,OnCreate

,OnSave

,OnRun

,OnDelete

,AddBehaivor

,ExtenderObject

,shablonBrief

,ruleBrief

,IsJormalChange

 ) values ( aPARTID 
,aParentRowid
,aParentStructRowID
,aSequence

,aPartType

,aCaption

,aName

,athe_Comment

,aNoLog

,aManualRegister

,aOnCreate

,aOnSave

,aOnRun

,aOnDelete

,aAddBehaivor

,aExtenderObject

,ashablonBrief

,aruleBrief

,aIsJormalChange

 ); 
 PERFORM PART_SINIT( aCURSESSION,aPARTid,atmpid);
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and Sequence=aSequence;
 else 
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and Sequence=aSequence;
 end if;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;
select Count(*) into aUniqueRowCount from PART where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PART_PARENT_T /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PART_PARENT_ID /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PART where  PARTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PART_ISLOCKED /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PART where PARTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PART_LOCK /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PART_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PART_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PART set LockUserID =auserID ,LockSessionID =null where PARTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PART set LockUserID =null,LockSessionID =aCURSESSION  where PARTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PART_HCL /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTMENU where PARTMENUid=row_PARTMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PARTMENU_HCL (acursession,row_PARTMENU.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELD where FIELDid=row_FIELD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELD_HCL (acursession,row_FIELD.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTVIEW where PARTVIEWid=row_PARTVIEW.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PARTVIEW_HCL (acursession,row_PARTVIEW.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ExtenderInterface where ExtenderInterfaceid=row_ExtenderInterface.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ExtenderInterface_HCL (acursession,row_ExtenderInterface.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from VALIDATOR where VALIDATORid=row_VALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= VALIDATOR_HCL (acursession,row_VALIDATOR.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=row_UNIQUECONSTRAINT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= UNIQUECONSTRAINT_HCL (acursession,row_UNIQUECONSTRAINT.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PART_UNLOCK /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PART_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PART set LockUserID =null  where PARTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PART set LockSessionID =null  where PARTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PART_SINIT /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PART_parent_T( aCURSESSION,aROWID);
 aParentID:= PART_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PART set securitystyleid =aStyleID where PARTid = aRowID;
else 
 update PART set securitystyleid =aSecurityStyleID where PARTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PART_propagate /*Раздел объекта*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PART where PARTid=aRowid;
open aCurs for select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTMENU_SINIT( acursession,aid,assid);
 PERFORM  PARTMENU_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELD_SINIT( acursession,aid,assid);
 PERFORM  FIELD_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTVIEW_SINIT( acursession,aid,assid);
 PERFORM  PARTVIEW_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ExtenderInterface_SINIT( acursession,aid,assid);
 PERFORM  ExtenderInterface_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  VALIDATOR_SINIT( acursession,aid,assid);
 PERFORM  VALIDATOR_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  UNIQUECONSTRAINT_SINIT( acursession,aid,assid);
 PERFORM  UNIQUECONSTRAINT_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  PARTMENU_BRIEF  (
 aCURSESSION uuid,
 aPARTMENUid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARTMENUid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0
 then
  aBRIEF:= PARTMENU_BRIEF_F(aPARTMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_DELETE /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aPARTMENUid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PARTMENU_ISLOCKED( acursession,aPARTMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aPARTMENUid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTPARAMMAP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARTMENUid as varchar),   'PARTMENU',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PARTMENU' and OwnerRowID=aPARTMENUid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PARTMENU 
  where  PARTMENUID = aPARTMENUID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Методы раздела*/
 create or replace function  PARTMENU_SAVE /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aPARTMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,athe_Action
 uuid/* Метод *//* Метод */
,aIsMenuItem
 INTEGER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 INTEGER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PARTMENU_ISLOCKED( acursession,aPARTMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTMENU');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARTMENUid as varchar),  'PARTMENU',
 'EDITROW',  aInstanceID);
 update  PARTMENU set ChangeStamp=localtimestamp
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  the_Action=athe_Action
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  PARTMENUID = aPARTMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTMENU');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARTMENUid as varchar),  'PARTMENU',
 'CREATEROW',  aInstanceID);
 insert into   PARTMENU
 (  PARTMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,the_Action

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aPARTMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,athe_Action

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 PERFORM PARTMENU_SINIT( aCURSESSION,aPARTMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PARTMENU_PARENT_T /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PARTMENU_PARENT_ID /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PARTMENU where  PARTMENUid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_ISLOCKED /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTMENU where PARTMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_LOCK /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PARTMENU_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PARTMENU_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PARTMENU set LockUserID =auserID ,LockSessionID =null where PARTMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTMENU set LockUserID =null,LockSessionID =aCURSESSION  where PARTMENUid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_HCL /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTPARAMMAP where PARTPARAMMAPid=row_PARTPARAMMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PARTPARAMMAP_HCL (acursession,row_PARTPARAMMAP.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PARTMENU_UNLOCK /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PARTMENU_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTMENU set LockUserID =null  where PARTMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTMENU set LockSessionID =null  where PARTMENUid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_SINIT /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PARTMENU_parent_T( aCURSESSION,aROWID);
 aParentID:= PARTMENU_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PARTMENU set securitystyleid =aStyleID where PARTMENUid = aRowID;
else 
 update PARTMENU set securitystyleid =aSecurityStyleID where PARTMENUid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PARTMENU_propagate /*Методы уровня раздела*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PARTMENU where PARTMENUid=aRowid;
open aCurs for select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTPARAMMAP_SINIT( acursession,aid,assid);
 PERFORM  PARTPARAMMAP_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  PARTPARAMMAP_BRIEF  (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARTPARAMMAPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0
 then
  aBRIEF:= PARTPARAMMAP_BRIEF_F(aPARTPARAMMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_DELETE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PARTPARAMMAP_ISLOCKED( acursession,aPARTPARAMMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTPARAMMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARTPARAMMAPid as varchar),   'PARTPARAMMAP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PARTPARAMMAP' and OwnerRowID=aPARTPARAMMAPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PARTPARAMMAP 
  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отображение параметров*/
 create or replace function  PARTPARAMMAP_SAVE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aPARTPARAMMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aNoEdit
 INTEGER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PARTPARAMMAP_ISLOCKED( acursession,aPARTPARAMMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTPARAMMAP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARTPARAMMAPid as varchar),  'PARTPARAMMAP',
 'EDITROW',  aInstanceID);
 update  PARTPARAMMAP set ChangeStamp=localtimestamp
,
  FieldName=aFieldName
,
  ParamName=aParamName
,
  NoEdit=aNoEdit
  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PARTMENU_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTPARAMMAP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARTPARAMMAPid as varchar),  'PARTPARAMMAP',
 'CREATEROW',  aInstanceID);
 insert into   PARTPARAMMAP
 (  PARTPARAMMAPID 
,ParentStructRowID
,FieldName

,ParamName

,NoEdit

 ) values ( aPARTPARAMMAPID 
,aParentStructRowID
,aFieldName

,aParamName

,aNoEdit

 ); 
 PERFORM PARTPARAMMAP_SINIT( aCURSESSION,aPARTPARAMMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PARTPARAMMAP_PARENT_T /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PARTMENU';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PARTPARAMMAP_PARENT_ID /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PARTPARAMMAP where  PARTPARAMMAPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_ISLOCKED /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTPARAMMAP where PARTPARAMMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_LOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PARTPARAMMAP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PARTPARAMMAP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PARTPARAMMAP set LockUserID =auserID ,LockSessionID =null where PARTPARAMMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTPARAMMAP set LockUserID =null,LockSessionID =aCURSESSION  where PARTPARAMMAPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_HCL /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_UNLOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PARTPARAMMAP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTPARAMMAP set LockUserID =null  where PARTPARAMMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTPARAMMAP set LockSessionID =null  where PARTPARAMMAPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_SINIT /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PARTPARAMMAP_parent_T( aCURSESSION,aROWID);
 aParentID:= PARTPARAMMAP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PARTPARAMMAP set securitystyleid =aStyleID where PARTPARAMMAPid = aRowID;
else 
 update PARTPARAMMAP set securitystyleid =aSecurityStyleID where PARTPARAMMAPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PARTPARAMMAP_propagate /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PARTPARAMMAP where PARTPARAMMAPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELD_BRIEF  (
 aCURSESSION uuid,
 aFIELDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELD_BRIEF_F(aFIELDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELD_DELETE /*Поле*/ (
 aCURSESSION uuid,
 aFIELDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELD_ISLOCKED( acursession,aFIELDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDVALIDATOR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDMENU_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FldExtenders_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDEXPRESSION_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  DINAMICFILTERSCRIPT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDSRCDEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDid as varchar),   'FIELD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELD' and OwnerRowID=aFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELD 
  where  FIELDID = aFIELDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Поле*/
 create or replace function  FIELD_SAVE /*Поле*/ (
 aCURSESSION uuid,
 aFIELDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aSequence
 integer/* № п/п *//* № п/п */
,aCaption
 VARCHAR/* Надпись *//* Надпись */
,aName
 VARCHAR/* Имя поля *//* Имя поля */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aIsBrief
 INTEGER/* Краткая информация *//* Краткая информация */
,aAllowNull
 INTEGER/* Может быть пустым *//* Может быть пустым */
,aDataSize
 integer/* Размер поля *//* Размер поля */
,aReferenceType
 INTEGER/* Тип ссылки *//* Тип ссылки */
,aRefToType
 uuid/* Ссылка на тип *//* Ссылка на тип */
,aRefToPart
 uuid/* Ссылка на раздел *//* Ссылка на раздел */
,aInternalReference
 INTEGER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,aCreateRefOnly
 INTEGER/* Только создание объекта *//* Только создание объекта */
,aIsAutoNumber
 INTEGER/* Автонумерация *//* Автонумерация */
,aTheNumerator
 uuid/* Нумератор *//* Нумератор */
,aZoneTemplate
 VARCHAR/* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,aNumberDateField
 uuid/* Поле для расчета даты *//* Поле для расчета даты */
,aTheComment
 TEXT/* Описание *//* Описание */
,ashablonBrief
 VARCHAR/* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,atheNameClass
 VARCHAR/* Имя класса для мастера строк *//* Имя класса для мастера строк */
,aTheMask
 VARCHAR/* Маска *//* Маска */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELD_ISLOCKED( acursession,aFIELDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDid as varchar),  'FIELD',
 'EDITROW',  aInstanceID);
 update  FIELD set ChangeStamp=localtimestamp
,
  Sequence=aSequence
,
  Caption=aCaption
,
  Name=aName
,
  FieldType=aFieldType
,
  IsBrief=aIsBrief
,
  AllowNull=aAllowNull
,
  DataSize=aDataSize
,
  ReferenceType=aReferenceType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
,
  InternalReference=aInternalReference
,
  CreateRefOnly=aCreateRefOnly
,
  IsAutoNumber=aIsAutoNumber
,
  TheNumerator=aTheNumerator
,
  ZoneTemplate=aZoneTemplate
,
  NumberDateField=aNumberDateField
,
  TheComment=aTheComment
,
  shablonBrief=ashablonBrief
,
  theNameClass=atheNameClass
,
  TheMask=aTheMask
  where  FIELDID = aFIELDID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;
select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Sequence=aSequence;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDid as varchar),  'FIELD',
 'CREATEROW',  aInstanceID);
 insert into   FIELD
 (  FIELDID 
,ParentStructRowID
,Sequence

,Caption

,Name

,FieldType

,IsBrief

,AllowNull

,DataSize

,ReferenceType

,RefToType

,RefToPart

,InternalReference

,CreateRefOnly

,IsAutoNumber

,TheNumerator

,ZoneTemplate

,NumberDateField

,TheComment

,shablonBrief

,theNameClass

,TheMask

 ) values ( aFIELDID 
,aParentStructRowID
,aSequence

,aCaption

,aName

,aFieldType

,aIsBrief

,aAllowNull

,aDataSize

,aReferenceType

,aRefToType

,aRefToPart

,aInternalReference

,aCreateRefOnly

,aIsAutoNumber

,aTheNumerator

,aZoneTemplate

,aNumberDateField

,aTheComment

,ashablonBrief

,atheNameClass

,aTheMask

 ); 
 PERFORM FIELD_SINIT( aCURSESSION,aFIELDid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;
select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Sequence=aSequence;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELD_PARENT_T /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELD_PARENT_ID /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELD where  FIELDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELD_ISLOCKED /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELD where FIELDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELD_LOCK /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELD set LockUserID =auserID ,LockSessionID =null where FIELDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELD set LockUserID =null,LockSessionID =aCURSESSION  where FIELDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELD_HCL /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDVALIDATOR where FIELDVALIDATORid=row_FIELDVALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDVALIDATOR_HCL (acursession,row_FIELDVALIDATOR.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDMENU where FIELDMENUid=row_FIELDMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDMENU_HCL (acursession,row_FIELDMENU.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FldExtenders where FldExtendersid=row_FldExtenders.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FldExtenders_HCL (acursession,row_FldExtenders.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDEXPRESSION where FIELDEXPRESSIONid=row_FIELDEXPRESSION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDEXPRESSION_HCL (acursession,row_FIELDEXPRESSION.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=row_DINAMICFILTERSCRIPT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= DINAMICFILTERSCRIPT_HCL (acursession,row_DINAMICFILTERSCRIPT.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDSRCDEF where FIELDSRCDEFid=row_FIELDSRCDEF.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDSRCDEF_HCL (acursession,row_FIELDSRCDEF.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELD_UNLOCK /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELD set LockUserID =null  where FIELDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELD set LockSessionID =null  where FIELDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELD_SINIT /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELD_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELD set securitystyleid =aStyleID where FIELDid = aRowID;
else 
 update FIELD set securitystyleid =aSecurityStyleID where FIELDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELD_propagate /*Поле*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELD where FIELDid=aRowid;
open aCurs for select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDVALIDATOR_SINIT( acursession,aid,assid);
 PERFORM  FIELDVALIDATOR_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDMENU_SINIT( acursession,aid,assid);
 PERFORM  FIELDMENU_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FldExtenders_SINIT( acursession,aid,assid);
 PERFORM  FldExtenders_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDEXPRESSION_SINIT( acursession,aid,assid);
 PERFORM  FIELDEXPRESSION_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  DINAMICFILTERSCRIPT_SINIT( acursession,aid,assid);
 PERFORM  DINAMICFILTERSCRIPT_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDSRCDEF_SINIT( acursession,aid,assid);
 PERFORM  FIELDSRCDEF_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDVALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDVALIDATORid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDVALIDATOR_BRIEF_F(aFIELDVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_DELETE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDVALIDATOR_ISLOCKED( acursession,aFIELDVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDVALIDATORid as varchar),   'FIELDVALIDATOR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDVALIDATOR' and OwnerRowID=aFIELDVALIDATORid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDVALIDATOR 
  where  FIELDVALIDATORID = aFIELDVALIDATORID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Логика поля на форме*/
 create or replace function  FIELDVALIDATOR_SAVE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aFIELDVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDVALIDATOR_ISLOCKED( acursession,aFIELDVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDVALIDATORid as varchar),  'FIELDVALIDATOR',
 'EDITROW',  aInstanceID);
 update  FIELDVALIDATOR set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  FIELDVALIDATORID = aFIELDVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDVALIDATORid as varchar),  'FIELDVALIDATOR',
 'CREATEROW',  aInstanceID);
 insert into   FIELDVALIDATOR
 (  FIELDVALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aFIELDVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM FIELDVALIDATOR_SINIT( aCURSESSION,aFIELDVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDVALIDATOR_PARENT_T /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDVALIDATOR_PARENT_ID /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDVALIDATOR where  FIELDVALIDATORid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_ISLOCKED /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDVALIDATOR where FIELDVALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_LOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDVALIDATOR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDVALIDATOR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDVALIDATOR set LockUserID =auserID ,LockSessionID =null where FIELDVALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDVALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where FIELDVALIDATORid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_HCL /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_UNLOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDVALIDATOR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDVALIDATOR set LockUserID =null  where FIELDVALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDVALIDATOR set LockSessionID =null  where FIELDVALIDATORid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_SINIT /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDVALIDATOR_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDVALIDATOR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDVALIDATOR set securitystyleid =aStyleID where FIELDVALIDATORid = aRowID;
else 
 update FIELDVALIDATOR set securitystyleid =aSecurityStyleID where FIELDVALIDATORid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDVALIDATOR_propagate /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDVALIDATOR where FIELDVALIDATORid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDMENU_BRIEF  (
 aCURSESSION uuid,
 aFIELDMENUid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDMENUid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDMENU_BRIEF_F(aFIELDMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_DELETE /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aFIELDMENUid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDMENU_ISLOCKED( acursession,aFIELDMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aFIELDMENUid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDPARAMMAP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDMENUid as varchar),   'FIELDMENU',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDMENU' and OwnerRowID=aFIELDMENUid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDMENU 
  where  FIELDMENUID = aFIELDMENUID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Методы поля*/
 create or replace function  FIELDMENU_SAVE /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aFIELDMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,aActionID
 uuid/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aIsMenuItem
 INTEGER/* В меню *//* В меню */
,aIsToolBarButton
 INTEGER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDMENU_ISLOCKED( acursession,aFIELDMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDMENU');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDMENUid as varchar),  'FIELDMENU',
 'EDITROW',  aInstanceID);
 update  FIELDMENU set ChangeStamp=localtimestamp
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  ActionID=aActionID
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  FIELDMENUID = aFIELDMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDMENU');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDMENUid as varchar),  'FIELDMENU',
 'CREATEROW',  aInstanceID);
 insert into   FIELDMENU
 (  FIELDMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,ActionID

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aFIELDMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,aActionID

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 PERFORM FIELDMENU_SINIT( aCURSESSION,aFIELDMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDMENU_PARENT_T /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDMENU_PARENT_ID /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDMENU where  FIELDMENUid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_ISLOCKED /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDMENU where FIELDMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_LOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDMENU_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDMENU_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDMENU set LockUserID =auserID ,LockSessionID =null where FIELDMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDMENU set LockUserID =null,LockSessionID =aCURSESSION  where FIELDMENUid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_HCL /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDPARAMMAP where FIELDPARAMMAPid=row_FIELDPARAMMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDPARAMMAP_HCL (acursession,row_FIELDPARAMMAP.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_UNLOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDMENU_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDMENU set LockUserID =null  where FIELDMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDMENU set LockSessionID =null  where FIELDMENUid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_SINIT /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDMENU_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDMENU_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDMENU set securitystyleid =aStyleID where FIELDMENUid = aRowID;
else 
 update FIELDMENU set securitystyleid =aSecurityStyleID where FIELDMENUid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDMENU_propagate /*Методы, ассоциированные с полем*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDMENU where FIELDMENUid=aRowid;
open aCurs for select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDPARAMMAP_SINIT( acursession,aid,assid);
 PERFORM  FIELDPARAMMAP_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDPARAMMAP_BRIEF  (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDPARAMMAPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDPARAMMAP_BRIEF_F(aFIELDPARAMMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_DELETE /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDPARAMMAP_ISLOCKED( acursession,aFIELDPARAMMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDPARAMMAPid as varchar),   'FIELDPARAMMAP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDPARAMMAP' and OwnerRowID=aFIELDPARAMMAPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDPARAMMAP 
  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отображение параметров*/
 create or replace function  FIELDPARAMMAP_SAVE /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aFIELDPARAMMAPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aFieldName
 VARCHAR/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR/* Параметр *//* Параметр */
,aNoEdit
 INTEGER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDPARAMMAP_ISLOCKED( acursession,aFIELDPARAMMAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDPARAMMAPid as varchar),  'FIELDPARAMMAP',
 'EDITROW',  aInstanceID);
 update  FIELDPARAMMAP set ChangeStamp=localtimestamp
,
  FieldName=aFieldName
,
  ParamName=aParamName
,
  NoEdit=aNoEdit
  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELDMENU_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDPARAMMAPid as varchar),  'FIELDPARAMMAP',
 'CREATEROW',  aInstanceID);
 insert into   FIELDPARAMMAP
 (  FIELDPARAMMAPID 
,ParentStructRowID
,FieldName

,ParamName

,NoEdit

 ) values ( aFIELDPARAMMAPID 
,aParentStructRowID
,aFieldName

,aParamName

,aNoEdit

 ); 
 PERFORM FIELDPARAMMAP_SINIT( aCURSESSION,aFIELDPARAMMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDPARAMMAP_PARENT_T /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELDMENU';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDPARAMMAP_PARENT_ID /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDPARAMMAP where  FIELDPARAMMAPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_ISLOCKED /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDPARAMMAP where FIELDPARAMMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_LOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDPARAMMAP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDPARAMMAP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDPARAMMAP set LockUserID =auserID ,LockSessionID =null where FIELDPARAMMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDPARAMMAP set LockUserID =null,LockSessionID =aCURSESSION  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_HCL /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_UNLOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDPARAMMAP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDPARAMMAP set LockUserID =null  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDPARAMMAP set LockSessionID =null  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_SINIT /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDPARAMMAP_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDPARAMMAP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDPARAMMAP set securitystyleid =aStyleID where FIELDPARAMMAPid = aRowID;
else 
 update FIELDPARAMMAP set securitystyleid =aSecurityStyleID where FIELDPARAMMAPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDPARAMMAP_propagate /*Отображение значений на параметры метода*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDPARAMMAP where FIELDPARAMMAPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FldExtenders_BRIEF  (
 aCURSESSION uuid,
 aFldExtendersid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFldExtendersid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0
 then
  aBRIEF:= FldExtenders_BRIEF_F(aFldExtendersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_DELETE /**/ (
 aCURSESSION uuid,
 aFldExtendersid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FldExtenders_ISLOCKED( acursession,aFldExtendersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FldExtenders');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFldExtendersid as varchar),   'FldExtenders',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FldExtenders' and OwnerRowID=aFldExtendersid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FldExtenders 
  where  FldExtendersID = aFldExtendersID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Интерфейсы расширения*/
 create or replace function  FldExtenders_SAVE /**/ (
 aCURSESSION uuid,
 aFldExtendersid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR/* Объект *//* Объект */
,aTheConfig
 VARCHAR/* Конфиг *//* Конфиг */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FldExtenders_ISLOCKED( acursession,aFldExtendersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FldExtenders');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFldExtendersid as varchar),  'FldExtenders',
 'EDITROW',  aInstanceID);
 update  FldExtenders set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  TargetPlatform=aTargetPlatform
,
  TheObject=aTheObject
,
  TheConfig=aTheConfig
  where  FldExtendersID = aFldExtendersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FldExtenders');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFldExtendersid as varchar),  'FldExtenders',
 'CREATEROW',  aInstanceID);
 insert into   FldExtenders
 (  FldExtendersID 
,ParentStructRowID
,TheName

,TargetPlatform

,TheObject

,TheConfig

 ) values ( aFldExtendersID 
,aParentStructRowID
,aTheName

,aTargetPlatform

,aTheObject

,aTheConfig

 ); 
 PERFORM FldExtenders_SINIT( aCURSESSION,aFldExtendersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FldExtenders_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FldExtenders_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FldExtenders where  FldExtendersid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FldExtenders where FldExtendersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FldExtenders_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FldExtenders_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FldExtenders set LockUserID =auserID ,LockSessionID =null where FldExtendersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FldExtenders set LockUserID =null,LockSessionID =aCURSESSION  where FldExtendersid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FldExtenders_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FldExtenders_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FldExtenders set LockUserID =null  where FldExtendersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FldExtenders set LockSessionID =null  where FldExtendersid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FldExtenders_parent_T( aCURSESSION,aROWID);
 aParentID:= FldExtenders_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FldExtenders set securitystyleid =aStyleID where FldExtendersid = aRowID;
else 
 update FldExtenders set securitystyleid =aSecurityStyleID where FldExtendersid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FldExtenders_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FldExtenders where FldExtendersid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDEXPRESSION_BRIEF  (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDEXPRESSIONid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDEXPRESSION_BRIEF_F(aFIELDEXPRESSIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_DELETE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDEXPRESSION_ISLOCKED( acursession,aFIELDEXPRESSIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDEXPRESSIONid as varchar),   'FIELDEXPRESSION',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDEXPRESSION' and OwnerRowID=aFIELDEXPRESSIONid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDEXPRESSION 
  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Значение по умолчанию*/
 create or replace function  FIELDEXPRESSION_SAVE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aFIELDEXPRESSIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDEXPRESSION_ISLOCKED( acursession,aFIELDEXPRESSIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDEXPRESSIONid as varchar),  'FIELDEXPRESSION',
 'EDITROW',  aInstanceID);
 update  FIELDEXPRESSION set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDEXPRESSIONid as varchar),  'FIELDEXPRESSION',
 'CREATEROW',  aInstanceID);
 insert into   FIELDEXPRESSION
 (  FIELDEXPRESSIONID 
,ParentStructRowID
,Target

,Code

 ) values ( aFIELDEXPRESSIONID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM FIELDEXPRESSION_SINIT( aCURSESSION,aFIELDEXPRESSIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDEXPRESSION_PARENT_T /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDEXPRESSION_PARENT_ID /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDEXPRESSION where  FIELDEXPRESSIONid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_ISLOCKED /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDEXPRESSION where FIELDEXPRESSIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_LOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDEXPRESSION_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDEXPRESSION_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDEXPRESSION set LockUserID =auserID ,LockSessionID =null where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDEXPRESSION set LockUserID =null,LockSessionID =aCURSESSION  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_HCL /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_UNLOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDEXPRESSION_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDEXPRESSION set LockUserID =null  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDEXPRESSION set LockSessionID =null  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_SINIT /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDEXPRESSION_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDEXPRESSION_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDEXPRESSION set securitystyleid =aStyleID where FIELDEXPRESSIONid = aRowID;
else 
 update FIELDEXPRESSION set securitystyleid =aSecurityStyleID where FIELDEXPRESSIONid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDEXPRESSION_propagate /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDEXPRESSION where FIELDEXPRESSIONid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  DINAMICFILTERSCRIPT_BRIEF  (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aDINAMICFILTERSCRIPTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0
 then
  aBRIEF:= DINAMICFILTERSCRIPT_BRIEF_F(aDINAMICFILTERSCRIPTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_DELETE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  DINAMICFILTERSCRIPT_ISLOCKED( acursession,aDINAMICFILTERSCRIPTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aDINAMICFILTERSCRIPTid as varchar),   'DINAMICFILTERSCRIPT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='DINAMICFILTERSCRIPT' and OwnerRowID=aDINAMICFILTERSCRIPTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  DINAMICFILTERSCRIPT 
  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Динамический фильтр*/
 create or replace function  DINAMICFILTERSCRIPT_SAVE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aDINAMICFILTERSCRIPTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  DINAMICFILTERSCRIPT_ISLOCKED( acursession,aDINAMICFILTERSCRIPTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aDINAMICFILTERSCRIPTid as varchar),  'DINAMICFILTERSCRIPT',
 'EDITROW',  aInstanceID);
 update  DINAMICFILTERSCRIPT set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aDINAMICFILTERSCRIPTid as varchar),  'DINAMICFILTERSCRIPT',
 'CREATEROW',  aInstanceID);
 insert into   DINAMICFILTERSCRIPT
 (  DINAMICFILTERSCRIPTID 
,ParentStructRowID
,Target

,Code

 ) values ( aDINAMICFILTERSCRIPTID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM DINAMICFILTERSCRIPT_SINIT( aCURSESSION,aDINAMICFILTERSCRIPTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  DINAMICFILTERSCRIPT_PARENT_T /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  DINAMICFILTERSCRIPT_PARENT_ID /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_ISLOCKED /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_LOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= DINAMICFILTERSCRIPT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= DINAMICFILTERSCRIPT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =auserID ,LockSessionID =null where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =null,LockSessionID =aCURSESSION  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_HCL /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_UNLOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= DINAMICFILTERSCRIPT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =null  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update DINAMICFILTERSCRIPT set LockSessionID =null  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_SINIT /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=DINAMICFILTERSCRIPT_parent_T( aCURSESSION,aROWID);
 aParentID:= DINAMICFILTERSCRIPT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update DINAMICFILTERSCRIPT set securitystyleid =aStyleID where DINAMICFILTERSCRIPTid = aRowID;
else 
 update DINAMICFILTERSCRIPT set securitystyleid =aSecurityStyleID where DINAMICFILTERSCRIPTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  DINAMICFILTERSCRIPT_propagate /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDSRCDEF_BRIEF  (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDSRCDEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDSRCDEF_BRIEF_F(aFIELDSRCDEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_DELETE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDSRCDEF_ISLOCKED( acursession,aFIELDSRCDEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDSRCDEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDSRCDEFid as varchar),   'FIELDSRCDEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDSRCDEF' and OwnerRowID=aFIELDSRCDEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDSRCDEF 
  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание источника данных*/
 create or replace function  FIELDSRCDEF_SAVE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aFIELDSRCDEFid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aProvider
 VARCHAR/* Провайдер *//* Провайдер */
,aConnectionString
 VARCHAR/* Строка соединения с источником *//* Строка соединения с источником */
,aDataSource
 VARCHAR/* Источник данных *//* Источник данных */
,aIDField
 VARCHAR/* ID *//* ID */
,aBriefString
 VARCHAR/* Источник краткой информации *//* Источник краткой информации */
,aFilterString
 VARCHAR/* Фильтр источника данных *//* Фильтр источника данных */
,aSortField
 VARCHAR/* Сортировка источника данных *//* Сортировка источника данных */
,aDescriptionString
 TEXT/* Примечания *//* Примечания */
,aDontShowDialog
 integer/* Не показывать форму выбора *//* Не показывать форму выбора */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDSRCDEF_ISLOCKED( acursession,aFIELDSRCDEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDSRCDEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDSRCDEFid as varchar),  'FIELDSRCDEF',
 'EDITROW',  aInstanceID);
 update  FIELDSRCDEF set ChangeStamp=localtimestamp
,
  Provider=aProvider
,
  ConnectionString=aConnectionString
,
  DataSource=aDataSource
,
  IDField=aIDField
,
  BriefString=aBriefString
,
  FilterString=aFilterString
,
  SortField=aSortField
,
  DescriptionString=aDescriptionString
,
  DontShowDialog=aDontShowDialog
  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= FIELD_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDSRCDEF');
    return;
  end if;
select Count(*) into existsCnt from FIELDSRCDEF where 
ParentStructRowID=aParentStructRowID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;FIELDSRCDEF&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDSRCDEFid as varchar),  'FIELDSRCDEF',
 'CREATEROW',  aInstanceID);
 insert into   FIELDSRCDEF
 (  FIELDSRCDEFID 
,ParentStructRowID
,Provider

,ConnectionString

,DataSource

,IDField

,BriefString

,FilterString

,SortField

,DescriptionString

,DontShowDialog

 ) values ( aFIELDSRCDEFID 
,aParentStructRowID
,aProvider

,aConnectionString

,aDataSource

,aIDField

,aBriefString

,aFilterString

,aSortField

,aDescriptionString

,aDontShowDialog

 ); 
 PERFORM FIELDSRCDEF_SINIT( aCURSESSION,aFIELDSRCDEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDSRCDEF_PARENT_T /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'FIELD';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDSRCDEF_PARENT_ID /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDSRCDEF where  FIELDSRCDEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_ISLOCKED /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDSRCDEF where FIELDSRCDEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_LOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDSRCDEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDSRCDEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDSRCDEF set LockUserID =auserID ,LockSessionID =null where FIELDSRCDEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDSRCDEF set LockUserID =null,LockSessionID =aCURSESSION  where FIELDSRCDEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_HCL /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_UNLOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDSRCDEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDSRCDEF set LockUserID =null  where FIELDSRCDEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDSRCDEF set LockSessionID =null  where FIELDSRCDEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_SINIT /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDSRCDEF_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDSRCDEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDSRCDEF set securitystyleid =aStyleID where FIELDSRCDEFid = aRowID;
else 
 update FIELDSRCDEF set securitystyleid =aSecurityStyleID where FIELDSRCDEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDSRCDEF_propagate /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDSRCDEF where FIELDSRCDEFid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  PARTVIEW_BRIEF  (
 aCURSESSION uuid,
 aPARTVIEWid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARTVIEWid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0
 then
  aBRIEF:= PARTVIEW_BRIEF_F(aPARTVIEWid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_DELETE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aPARTVIEWid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PARTVIEW_ISLOCKED( acursession,aPARTVIEWid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTVIEW');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aPARTVIEWid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ViewColumn_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aPARTVIEWid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTVIEW_LNK_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARTVIEWid as varchar),   'PARTVIEW',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PARTVIEW' and OwnerRowID=aPARTVIEWid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PARTVIEW 
  where  PARTVIEWID = aPARTVIEWID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Представление*/
 create or replace function  PARTVIEW_SAVE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aPARTVIEWid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aForChoose
 INTEGER/* Для поиска *//* Для поиска */
,aFilterField0
 VARCHAR/* Поле - фильтр 0 *//* Поле - фильтр 0 */
,aFilterField1
 VARCHAR/* Поле - фильтр 1 *//* Поле - фильтр 1 */
,aFilterField2
 VARCHAR/* Поле - фильтр 2 *//* Поле - фильтр 2 */
,aFilterField3
 VARCHAR/* Поле - фильтр 3 *//* Поле - фильтр 3 */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PARTVIEW_ISLOCKED( acursession,aPARTVIEWid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARTVIEWid as varchar),  'PARTVIEW',
 'EDITROW',  aInstanceID);
 update  PARTVIEW set ChangeStamp=localtimestamp
,
  Name=aName
,
  the_Alias=athe_Alias
,
  ForChoose=aForChoose
,
  FilterField0=aFilterField0
,
  FilterField1=aFilterField1
,
  FilterField2=aFilterField2
,
  FilterField3=aFilterField3
  where  PARTVIEWID = aPARTVIEWID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARTVIEWid as varchar),  'PARTVIEW',
 'CREATEROW',  aInstanceID);
 insert into   PARTVIEW
 (  PARTVIEWID 
,ParentStructRowID
,Name

,the_Alias

,ForChoose

,FilterField0

,FilterField1

,FilterField2

,FilterField3

 ) values ( aPARTVIEWID 
,aParentStructRowID
,aName

,athe_Alias

,aForChoose

,aFilterField0

,aFilterField1

,aFilterField2

,aFilterField3

 ); 
 PERFORM PARTVIEW_SINIT( aCURSESSION,aPARTVIEWid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PARTVIEW_PARENT_T /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_PARENT_ID /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PARTVIEW where  PARTVIEWid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_ISLOCKED /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTVIEW where PARTVIEWid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PARTVIEW_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PARTVIEW_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PARTVIEW set LockUserID =auserID ,LockSessionID =null where PARTVIEWid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTVIEW set LockUserID =null,LockSessionID =aCURSESSION  where PARTVIEWid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_HCL /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ViewColumn where ViewColumnid=row_ViewColumn.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ViewColumn_HCL (acursession,row_ViewColumn.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTVIEW_LNK where PARTVIEW_LNKid=row_PARTVIEW_LNK.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= PARTVIEW_LNK_HCL (acursession,row_PARTVIEW_LNK.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_UNLOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PARTVIEW_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTVIEW set LockUserID =null  where PARTVIEWid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTVIEW set LockSessionID =null  where PARTVIEWid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_SINIT /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PARTVIEW_parent_T( aCURSESSION,aROWID);
 aParentID:= PARTVIEW_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PARTVIEW set securitystyleid =aStyleID where PARTVIEWid = aRowID;
else 
 update PARTVIEW set securitystyleid =aSecurityStyleID where PARTVIEWid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_propagate /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PARTVIEW where PARTVIEWid=aRowid;
open aCurs for select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ViewColumn_SINIT( acursession,aid,assid);
 PERFORM  ViewColumn_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  PARTVIEW_LNK_SINIT( acursession,aid,assid);
 PERFORM  PARTVIEW_LNK_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  ViewColumn_BRIEF  (
 aCURSESSION uuid,
 aViewColumnid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aViewColumnid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0
 then
  aBRIEF:= ViewColumn_BRIEF_F(aViewColumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_DELETE /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aViewColumnid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ViewColumn_ISLOCKED( acursession,aViewColumnid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ViewColumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aViewColumnid as varchar),   'ViewColumn',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ViewColumn' and OwnerRowID=aViewColumnid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ViewColumn 
  where  ViewColumnID = aViewColumnID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Колонка*/
 create or replace function  ViewColumn_SAVE /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aViewColumnid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,asequence
 integer/* №  *//* №  */
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псвдоним *//* Псвдоним */
,aFromPart
 uuid/* Раздел *//* Раздел */
,aField
 uuid/* Поле *//* Поле */
,aAggregation
 INTEGER/* Агрегация *//* Агрегация */
,aExpression
 TEXT/* Формула *//* Формула */
,aForCombo
 INTEGER/* Для комбо *//* Для комбо */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ViewColumn_ISLOCKED( acursession,aViewColumnid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ViewColumn');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aViewColumnid as varchar),  'ViewColumn',
 'EDITROW',  aInstanceID);
 update  ViewColumn set ChangeStamp=localtimestamp
,
  sequence=asequence
,
  Name=aName
,
  the_Alias=athe_Alias
,
  FromPart=aFromPart
,
  Field=aField
,
  Aggregation=aAggregation
,
  Expression=aExpression
,
  ForCombo=aForCombo
  where  ViewColumnID = aViewColumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PARTVIEW_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ViewColumn');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aViewColumnid as varchar),  'ViewColumn',
 'CREATEROW',  aInstanceID);
 insert into   ViewColumn
 (  ViewColumnID 
,ParentStructRowID
,sequence

,Name

,the_Alias

,FromPart

,Field

,Aggregation

,Expression

,ForCombo

 ) values ( aViewColumnID 
,aParentStructRowID
,asequence

,aName

,athe_Alias

,aFromPart

,aField

,aAggregation

,aExpression

,aForCombo

 ); 
 PERFORM ViewColumn_SINIT( aCURSESSION,aViewColumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ViewColumn_PARENT_T /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PARTVIEW';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ViewColumn_PARENT_ID /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ViewColumn where  ViewColumnid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_ISLOCKED /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ViewColumn where ViewColumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_LOCK /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ViewColumn_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ViewColumn_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ViewColumn set LockUserID =auserID ,LockSessionID =null where ViewColumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ViewColumn set LockUserID =null,LockSessionID =aCURSESSION  where ViewColumnid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_HCL /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ViewColumn_UNLOCK /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ViewColumn_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ViewColumn set LockUserID =null  where ViewColumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ViewColumn set LockSessionID =null  where ViewColumnid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_SINIT /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ViewColumn_parent_T( aCURSESSION,aROWID);
 aParentID:= ViewColumn_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ViewColumn set securitystyleid =aStyleID where ViewColumnid = aRowID;
else 
 update ViewColumn set securitystyleid =aSecurityStyleID where ViewColumnid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ViewColumn_propagate /*Колонка пердставления*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ViewColumn where ViewColumnid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  PARTVIEW_LNK_BRIEF  (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aPARTVIEW_LNKid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0
 then
  aBRIEF:= PARTVIEW_LNK_BRIEF_F(aPARTVIEW_LNKid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_DELETE /**/ (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  PARTVIEW_LNK_ISLOCKED( acursession,aPARTVIEW_LNKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aPARTVIEW_LNKid as varchar),   'PARTVIEW_LNK',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='PARTVIEW_LNK' and OwnerRowID=aPARTVIEW_LNKid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  PARTVIEW_LNK 
  where  PARTVIEW_LNKID = aPARTVIEW_LNKID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Связанные представления*/
 create or replace function  PARTVIEW_LNK_SAVE /**/ (
 aCURSESSION uuid,
 aPARTVIEW_LNKid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheView
 uuid/* Представление *//* Представление */
,aTheJoinSource
 uuid/* Связь: Поле для join источник *//* Связь: Поле для join источник */
,aRefType
 integer/* Связывать как *//* Связывать как */
,aTheJoinDestination
 uuid/* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,aHandJoin
 VARCHAR/* Ручной join *//* Ручной join */
,aSEQ
 integer/* Порядок *//* Порядок */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  PARTVIEW_LNK_ISLOCKED( acursession,aPARTVIEW_LNKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aPARTVIEW_LNKid as varchar),  'PARTVIEW_LNK',
 'EDITROW',  aInstanceID);
 update  PARTVIEW_LNK set ChangeStamp=localtimestamp
,
  TheView=aTheView
,
  TheJoinSource=aTheJoinSource
,
  RefType=aRefType
,
  TheJoinDestination=aTheJoinDestination
,
  HandJoin=aHandJoin
,
  SEQ=aSEQ
  where  PARTVIEW_LNKID = aPARTVIEW_LNKID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PARTVIEW_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aPARTVIEW_LNKid as varchar),  'PARTVIEW_LNK',
 'CREATEROW',  aInstanceID);
 insert into   PARTVIEW_LNK
 (  PARTVIEW_LNKID 
,ParentStructRowID
,TheView

,TheJoinSource

,RefType

,TheJoinDestination

,HandJoin

,SEQ

 ) values ( aPARTVIEW_LNKID 
,aParentStructRowID
,aTheView

,aTheJoinSource

,aRefType

,aTheJoinDestination

,aHandJoin

,aSEQ

 ); 
 PERFORM PARTVIEW_LNK_SINIT( aCURSESSION,aPARTVIEW_LNKid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  PARTVIEW_LNK_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PARTVIEW';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  PARTVIEW_LNK_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from PARTVIEW_LNK where  PARTVIEW_LNKid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTVIEW_LNK where PARTVIEW_LNKid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= PARTVIEW_LNK_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= PARTVIEW_LNK_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update PARTVIEW_LNK set LockUserID =auserID ,LockSessionID =null where PARTVIEW_LNKid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTVIEW_LNK set LockUserID =null,LockSessionID =aCURSESSION  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= PARTVIEW_LNK_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTVIEW_LNK set LockUserID =null  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTVIEW_LNK set LockSessionID =null  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=PARTVIEW_LNK_parent_T( aCURSESSION,aROWID);
 aParentID:= PARTVIEW_LNK_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update PARTVIEW_LNK set securitystyleid =aStyleID where PARTVIEW_LNKid = aRowID;
else 
 update PARTVIEW_LNK set securitystyleid =aSecurityStyleID where PARTVIEW_LNKid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  PARTVIEW_LNK_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from PARTVIEW_LNK where PARTVIEW_LNKid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ExtenderInterface_BRIEF  (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aExtenderInterfaceid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0
 then
  aBRIEF:= ExtenderInterface_BRIEF_F(aExtenderInterfaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_DELETE /**/ (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ExtenderInterface_ISLOCKED( acursession,aExtenderInterfaceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ExtenderInterface');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aExtenderInterfaceid as varchar),   'ExtenderInterface',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ExtenderInterface' and OwnerRowID=aExtenderInterfaceid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ExtenderInterface 
  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Интерфейсы расширения*/
 create or replace function  ExtenderInterface_SAVE /**/ (
 aCURSESSION uuid,
 aExtenderInterfaceid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTargetPlatform
 uuid/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR/* Объект *//* Объект */
,aTheConfig
 VARCHAR/* Конфиг *//* Конфиг */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ExtenderInterface_ISLOCKED( acursession,aExtenderInterfaceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ExtenderInterface');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aExtenderInterfaceid as varchar),  'ExtenderInterface',
 'EDITROW',  aInstanceID);
 update  ExtenderInterface set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  TargetPlatform=aTargetPlatform
,
  TheObject=aTheObject
,
  TheConfig=aTheConfig
  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ExtenderInterface');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aExtenderInterfaceid as varchar),  'ExtenderInterface',
 'CREATEROW',  aInstanceID);
 insert into   ExtenderInterface
 (  ExtenderInterfaceID 
,ParentStructRowID
,TheName

,TargetPlatform

,TheObject

,TheConfig

 ) values ( aExtenderInterfaceID 
,aParentStructRowID
,aTheName

,aTargetPlatform

,aTheObject

,aTheConfig

 ); 
 PERFORM ExtenderInterface_SINIT( aCURSESSION,aExtenderInterfaceid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ExtenderInterface_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ExtenderInterface_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ExtenderInterface where  ExtenderInterfaceid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ExtenderInterface where ExtenderInterfaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ExtenderInterface_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ExtenderInterface_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ExtenderInterface set LockUserID =auserID ,LockSessionID =null where ExtenderInterfaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ExtenderInterface set LockUserID =null,LockSessionID =aCURSESSION  where ExtenderInterfaceid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ExtenderInterface_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ExtenderInterface set LockUserID =null  where ExtenderInterfaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ExtenderInterface set LockSessionID =null  where ExtenderInterfaceid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ExtenderInterface_parent_T( aCURSESSION,aROWID);
 aParentID:= ExtenderInterface_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ExtenderInterface set securitystyleid =aStyleID where ExtenderInterfaceid = aRowID;
else 
 update ExtenderInterface set securitystyleid =aSecurityStyleID where ExtenderInterfaceid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ExtenderInterface_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ExtenderInterface where ExtenderInterfaceid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  VALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aVALIDATORid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aVALIDATORid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0
 then
  aBRIEF:= VALIDATOR_BRIEF_F(aVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_DELETE /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  VALIDATOR_ISLOCKED( acursession,aVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=VALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aVALIDATORid as varchar),   'VALIDATOR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='VALIDATOR' and OwnerRowID=aVALIDATORid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  VALIDATOR 
  where  VALIDATORID = aVALIDATORID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Логика на форме*/
 create or replace function  VALIDATOR_SAVE /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Целевая платформа *//* Целевая платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  VALIDATOR_ISLOCKED( acursession,aVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=VALIDATOR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aVALIDATORid as varchar),  'VALIDATOR',
 'EDITROW',  aInstanceID);
 update  VALIDATOR set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  VALIDATORID = aVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=VALIDATOR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aVALIDATORid as varchar),  'VALIDATOR',
 'CREATEROW',  aInstanceID);
 insert into   VALIDATOR
 (  VALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM VALIDATOR_SINIT( aCURSESSION,aVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  VALIDATOR_PARENT_T /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  VALIDATOR_PARENT_ID /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from VALIDATOR where  VALIDATORid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_ISLOCKED /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from VALIDATOR where VALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_LOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= VALIDATOR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= VALIDATOR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update VALIDATOR set LockUserID =auserID ,LockSessionID =null where VALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update VALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where VALIDATORid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_HCL /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_UNLOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= VALIDATOR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update VALIDATOR set LockUserID =null  where VALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update VALIDATOR set LockSessionID =null  where VALIDATORid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_SINIT /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=VALIDATOR_parent_T( aCURSESSION,aROWID);
 aParentID:= VALIDATOR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update VALIDATOR set securitystyleid =aStyleID where VALIDATORid = aRowID;
else 
 update VALIDATOR set securitystyleid =aSecurityStyleID where VALIDATORid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  VALIDATOR_propagate /*Действия в впроцессе редактирования*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from VALIDATOR where VALIDATORid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  UNIQUECONSTRAINT_BRIEF  (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aUNIQUECONSTRAINTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0
 then
  aBRIEF:= UNIQUECONSTRAINT_BRIEF_F(aUNIQUECONSTRAINTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_DELETE /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  UNIQUECONSTRAINT_ISLOCKED( acursession,aUNIQUECONSTRAINTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aUNIQUECONSTRAINTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  CONSTRAINTFIELD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aUNIQUECONSTRAINTid as varchar),   'UNIQUECONSTRAINT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='UNIQUECONSTRAINT' and OwnerRowID=aUNIQUECONSTRAINTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  UNIQUECONSTRAINT 
  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Ограничение уникальности*/
 create or replace function  UNIQUECONSTRAINT_SAVE /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aUNIQUECONSTRAINTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aPerParent
 INTEGER/* По родителю *//* По родителю */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  UNIQUECONSTRAINT_ISLOCKED( acursession,aUNIQUECONSTRAINTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aUNIQUECONSTRAINTid as varchar),  'UNIQUECONSTRAINT',
 'EDITROW',  aInstanceID);
 update  UNIQUECONSTRAINT set ChangeStamp=localtimestamp
,
  Name=aName
,
  PerParent=aPerParent
,
  TheComment=aTheComment
  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= PART_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aUNIQUECONSTRAINTid as varchar),  'UNIQUECONSTRAINT',
 'CREATEROW',  aInstanceID);
 insert into   UNIQUECONSTRAINT
 (  UNIQUECONSTRAINTID 
,ParentStructRowID
,Name

,PerParent

,TheComment

 ) values ( aUNIQUECONSTRAINTID 
,aParentStructRowID
,aName

,aPerParent

,aTheComment

 ); 
 PERFORM UNIQUECONSTRAINT_SINIT( aCURSESSION,aUNIQUECONSTRAINTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  UNIQUECONSTRAINT_PARENT_T /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'PART';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  UNIQUECONSTRAINT_PARENT_ID /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from UNIQUECONSTRAINT where  UNIQUECONSTRAINTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_ISLOCKED /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_LOCK /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= UNIQUECONSTRAINT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= UNIQUECONSTRAINT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update UNIQUECONSTRAINT set LockUserID =auserID ,LockSessionID =null where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update UNIQUECONSTRAINT set LockUserID =null,LockSessionID =aCURSESSION  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_HCL /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from CONSTRAINTFIELD where CONSTRAINTFIELDid=row_CONSTRAINTFIELD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= CONSTRAINTFIELD_HCL (acursession,row_CONSTRAINTFIELD.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_UNLOCK /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= UNIQUECONSTRAINT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update UNIQUECONSTRAINT set LockUserID =null  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update UNIQUECONSTRAINT set LockSessionID =null  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_SINIT /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=UNIQUECONSTRAINT_parent_T( aCURSESSION,aROWID);
 aParentID:= UNIQUECONSTRAINT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update UNIQUECONSTRAINT set securitystyleid =aStyleID where UNIQUECONSTRAINTid = aRowID;
else 
 update UNIQUECONSTRAINT set securitystyleid =aSecurityStyleID where UNIQUECONSTRAINTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  UNIQUECONSTRAINT_propagate /*Ограничение уникальности*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aRowid;
open aCurs for select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  CONSTRAINTFIELD_SINIT( acursession,aid,assid);
 PERFORM  CONSTRAINTFIELD_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  CONSTRAINTFIELD_BRIEF  (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aCONSTRAINTFIELDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0
 then
  aBRIEF:= CONSTRAINTFIELD_BRIEF_F(aCONSTRAINTFIELDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_DELETE /*Поля ограничения*/ (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  CONSTRAINTFIELD_ISLOCKED( acursession,aCONSTRAINTFIELDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aCONSTRAINTFIELDid as varchar),   'CONSTRAINTFIELD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='CONSTRAINTFIELD' and OwnerRowID=aCONSTRAINTFIELDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  CONSTRAINTFIELD 
  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Поля ограничения*/
 create or replace function  CONSTRAINTFIELD_SAVE /*Поля ограничения*/ (
 aCURSESSION uuid,
 aCONSTRAINTFIELDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheField
 uuid/* Поле *//* Поле */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  CONSTRAINTFIELD_ISLOCKED( acursession,aCONSTRAINTFIELDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aCONSTRAINTFIELDid as varchar),  'CONSTRAINTFIELD',
 'EDITROW',  aInstanceID);
 update  CONSTRAINTFIELD set ChangeStamp=localtimestamp
,
  TheField=aTheField
  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= UNIQUECONSTRAINT_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aCONSTRAINTFIELDid as varchar),  'CONSTRAINTFIELD',
 'CREATEROW',  aInstanceID);
 insert into   CONSTRAINTFIELD
 (  CONSTRAINTFIELDID 
,ParentStructRowID
,TheField

 ) values ( aCONSTRAINTFIELDID 
,aParentStructRowID
,aTheField

 ); 
 PERFORM CONSTRAINTFIELD_SINIT( aCURSESSION,aCONSTRAINTFIELDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  CONSTRAINTFIELD_PARENT_T /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'UNIQUECONSTRAINT';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  CONSTRAINTFIELD_PARENT_ID /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from CONSTRAINTFIELD where  CONSTRAINTFIELDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_ISLOCKED /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_LOCK /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= CONSTRAINTFIELD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= CONSTRAINTFIELD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update CONSTRAINTFIELD set LockUserID =auserID ,LockSessionID =null where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update CONSTRAINTFIELD set LockUserID =null,LockSessionID =aCURSESSION  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_HCL /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_UNLOCK /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= CONSTRAINTFIELD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update CONSTRAINTFIELD set LockUserID =null  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update CONSTRAINTFIELD set LockSessionID =null  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_SINIT /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=CONSTRAINTFIELD_parent_T( aCURSESSION,aROWID);
 aParentID:= CONSTRAINTFIELD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update CONSTRAINTFIELD set securitystyleid =aStyleID where CONSTRAINTFIELDid = aRowID;
else 
 update CONSTRAINTFIELD set securitystyleid =aSecurityStyleID where CONSTRAINTFIELDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  CONSTRAINTFIELD_propagate /*Поля ограничения*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INSTANCEVALIDATOR_BRIEF  (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINSTANCEVALIDATORid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0
 then
  aBRIEF:= INSTANCEVALIDATOR_BRIEF_F(aINSTANCEVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_DELETE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INSTANCEVALIDATOR_ISLOCKED( acursession,aINSTANCEVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINSTANCEVALIDATORid as varchar),   'INSTANCEVALIDATOR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INSTANCEVALIDATOR' and OwnerRowID=aINSTANCEVALIDATORid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INSTANCEVALIDATOR 
  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Проверка правильности*/
 create or replace function  INSTANCEVALIDATOR_SAVE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aINSTANCEVALIDATORid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTarget
 uuid/* Платформа *//* Платформа */
,aCode
 TEXT/* Скрипт *//* Скрипт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INSTANCEVALIDATOR_ISLOCKED( acursession,aINSTANCEVALIDATORid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINSTANCEVALIDATORid as varchar),  'INSTANCEVALIDATOR',
 'EDITROW',  aInstanceID);
 update  INSTANCEVALIDATOR set ChangeStamp=localtimestamp
,
  Target=aTarget
,
  Code=aCode
  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINSTANCEVALIDATORid as varchar),  'INSTANCEVALIDATOR',
 'CREATEROW',  aInstanceID);
 insert into   INSTANCEVALIDATOR
 (  INSTANCEVALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aINSTANCEVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 PERFORM INSTANCEVALIDATOR_SINIT( aCURSESSION,aINSTANCEVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INSTANCEVALIDATOR_PARENT_T /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INSTANCEVALIDATOR_PARENT_ID /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INSTANCEVALIDATOR where  INSTANCEVALIDATORid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_ISLOCKED /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_LOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INSTANCEVALIDATOR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INSTANCEVALIDATOR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INSTANCEVALIDATOR set LockUserID =auserID ,LockSessionID =null where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INSTANCEVALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_HCL /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_UNLOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INSTANCEVALIDATOR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INSTANCEVALIDATOR set LockUserID =null  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INSTANCEVALIDATOR set LockSessionID =null  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_SINIT /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INSTANCEVALIDATOR_parent_T( aCURSESSION,aROWID);
 aParentID:= INSTANCEVALIDATOR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INSTANCEVALIDATOR set securitystyleid =aStyleID where INSTANCEVALIDATORid = aRowID;
else 
 update INSTANCEVALIDATOR set securitystyleid =aSecurityStyleID where INSTANCEVALIDATORid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INSTANCEVALIDATOR_propagate /*Проверка правильности для объекта в целом*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  OBJSTATUS_BRIEF  (
 aCURSESSION uuid,
 aOBJSTATUSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aOBJSTATUSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0
 then
  aBRIEF:= OBJSTATUS_BRIEF_F(aOBJSTATUSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_DELETE /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aOBJSTATUSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  OBJSTATUS_ISLOCKED( acursession,aOBJSTATUSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJSTATUS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aOBJSTATUSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  NEXTSTATE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aOBJSTATUSid as varchar),   'OBJSTATUS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='OBJSTATUS' and OwnerRowID=aOBJSTATUSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  OBJSTATUS 
  where  OBJSTATUSID = aOBJSTATUSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Состояния*/
 create or replace function  OBJSTATUS_SAVE /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aOBJSTATUSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aname
 VARCHAR/* Название *//* Название */
,aisStartup
 INTEGER/* Начальное *//* Начальное */
,aIsArchive
 INTEGER/* Архивное *//* Архивное */
,athe_comment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  OBJSTATUS_ISLOCKED( acursession,aOBJSTATUSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJSTATUS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aOBJSTATUSid as varchar),  'OBJSTATUS',
 'EDITROW',  aInstanceID);
 update  OBJSTATUS set ChangeStamp=localtimestamp
,
  name=aname
,
  isStartup=aisStartup
,
  IsArchive=aIsArchive
,
  the_comment=athe_comment
  where  OBJSTATUSID = aOBJSTATUSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJSTATUS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aOBJSTATUSid as varchar),  'OBJSTATUS',
 'CREATEROW',  aInstanceID);
 insert into   OBJSTATUS
 (  OBJSTATUSID 
,ParentStructRowID
,name

,isStartup

,IsArchive

,the_comment

 ) values ( aOBJSTATUSID 
,aParentStructRowID
,aname

,aisStartup

,aIsArchive

,athe_comment

 ); 
 PERFORM OBJSTATUS_SINIT( aCURSESSION,aOBJSTATUSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  OBJSTATUS_PARENT_T /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  OBJSTATUS_PARENT_ID /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from OBJSTATUS where  OBJSTATUSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_ISLOCKED /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJSTATUS where OBJSTATUSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_LOCK /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= OBJSTATUS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= OBJSTATUS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update OBJSTATUS set LockUserID =auserID ,LockSessionID =null where OBJSTATUSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJSTATUS set LockUserID =null,LockSessionID =aCURSESSION  where OBJSTATUSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_HCL /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from NEXTSTATE where NEXTSTATEid=row_NEXTSTATE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= NEXTSTATE_HCL (acursession,row_NEXTSTATE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_UNLOCK /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= OBJSTATUS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJSTATUS set LockUserID =null  where OBJSTATUSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJSTATUS set LockSessionID =null  where OBJSTATUSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_SINIT /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=OBJSTATUS_parent_T( aCURSESSION,aROWID);
 aParentID:= OBJSTATUS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update OBJSTATUS set securitystyleid =aStyleID where OBJSTATUSid = aRowID;
else 
 update OBJSTATUS set securitystyleid =aSecurityStyleID where OBJSTATUSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  OBJSTATUS_propagate /*Возможные логические состояния документа*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from OBJSTATUS where OBJSTATUSid=aRowid;
open aCurs for select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  NEXTSTATE_SINIT( acursession,aid,assid);
 PERFORM  NEXTSTATE_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  NEXTSTATE_BRIEF  (
 aCURSESSION uuid,
 aNEXTSTATEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aNEXTSTATEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0
 then
  aBRIEF:= NEXTSTATE_BRIEF_F(aNEXTSTATEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_DELETE /*Матрица переходов */ (
 aCURSESSION uuid,
 aNEXTSTATEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  NEXTSTATE_ISLOCKED( acursession,aNEXTSTATEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=NEXTSTATE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aNEXTSTATEid as varchar),   'NEXTSTATE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='NEXTSTATE' and OwnerRowID=aNEXTSTATEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  NEXTSTATE 
  where  NEXTSTATEID = aNEXTSTATEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Разрешенные переходы*/
 create or replace function  NEXTSTATE_SAVE /*Матрица переходов */ (
 aCURSESSION uuid,
 aNEXTSTATEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheState
 uuid/* Разрешенное состояние *//* Разрешенное состояние */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  NEXTSTATE_ISLOCKED( acursession,aNEXTSTATEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=NEXTSTATE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aNEXTSTATEid as varchar),  'NEXTSTATE',
 'EDITROW',  aInstanceID);
 update  NEXTSTATE set ChangeStamp=localtimestamp
,
  TheState=aTheState
  where  NEXTSTATEID = aNEXTSTATEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJSTATUS_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=NEXTSTATE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aNEXTSTATEid as varchar),  'NEXTSTATE',
 'CREATEROW',  aInstanceID);
 insert into   NEXTSTATE
 (  NEXTSTATEID 
,ParentStructRowID
,TheState

 ) values ( aNEXTSTATEID 
,aParentStructRowID
,aTheState

 ); 
 PERFORM NEXTSTATE_SINIT( aCURSESSION,aNEXTSTATEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  NEXTSTATE_PARENT_T /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJSTATUS';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  NEXTSTATE_PARENT_ID /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from NEXTSTATE where  NEXTSTATEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_ISLOCKED /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from NEXTSTATE where NEXTSTATEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_LOCK /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= NEXTSTATE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= NEXTSTATE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update NEXTSTATE set LockUserID =auserID ,LockSessionID =null where NEXTSTATEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update NEXTSTATE set LockUserID =null,LockSessionID =aCURSESSION  where NEXTSTATEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_HCL /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_UNLOCK /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= NEXTSTATE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update NEXTSTATE set LockUserID =null  where NEXTSTATEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update NEXTSTATE set LockSessionID =null  where NEXTSTATEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_SINIT /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=NEXTSTATE_parent_T( aCURSESSION,aROWID);
 aParentID:= NEXTSTATE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update NEXTSTATE set securitystyleid =aStyleID where NEXTSTATEid = aRowID;
else 
 update NEXTSTATE set securitystyleid =aSecurityStyleID where NEXTSTATEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  NEXTSTATE_propagate /*Матрица переходов */ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from NEXTSTATE where NEXTSTATEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  OBJECTMODE_BRIEF  (
 aCURSESSION uuid,
 aOBJECTMODEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aOBJECTMODEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0
 then
  aBRIEF:= OBJECTMODE_BRIEF_F(aOBJECTMODEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_DELETE /*Режим работы*/ (
 aCURSESSION uuid,
 aOBJECTMODEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  OBJECTMODE_ISLOCKED( acursession,aOBJECTMODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJECTMODE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aOBJECTMODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  STRUCTRESTRICTION_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aOBJECTMODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDRESTRICTION_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aOBJECTMODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  METHODRESTRICTION_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aOBJECTMODEid as varchar),   'OBJECTMODE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='OBJECTMODE' and OwnerRowID=aOBJECTMODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  OBJECTMODE 
  where  OBJECTMODEID = aOBJECTMODEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Режим работы*/
 create or replace function  OBJECTMODE_SAVE /*Режим работы*/ (
 aCURSESSION uuid,
 aOBJECTMODEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название режима *//* Название режима */
,aDefaultMode
 INTEGER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  OBJECTMODE_ISLOCKED( acursession,aOBJECTMODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTMODE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aOBJECTMODEid as varchar),  'OBJECTMODE',
 'EDITROW',  aInstanceID);
 update  OBJECTMODE set ChangeStamp=localtimestamp
,
  Name=aName
,
  DefaultMode=aDefaultMode
,
  TheComment=aTheComment
  where  OBJECTMODEID = aOBJECTMODEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTMODE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aOBJECTMODEid as varchar),  'OBJECTMODE',
 'CREATEROW',  aInstanceID);
 insert into   OBJECTMODE
 (  OBJECTMODEID 
,ParentStructRowID
,Name

,DefaultMode

,TheComment

 ) values ( aOBJECTMODEID 
,aParentStructRowID
,aName

,aDefaultMode

,aTheComment

 ); 
 PERFORM OBJECTMODE_SINIT( aCURSESSION,aOBJECTMODEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  OBJECTMODE_PARENT_T /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  OBJECTMODE_PARENT_ID /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from OBJECTMODE where  OBJECTMODEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_ISLOCKED /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJECTMODE where OBJECTMODEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_LOCK /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= OBJECTMODE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= OBJECTMODE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update OBJECTMODE set LockUserID =auserID ,LockSessionID =null where OBJECTMODEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJECTMODE set LockUserID =null,LockSessionID =aCURSESSION  where OBJECTMODEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_HCL /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=row_STRUCTRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= STRUCTRESTRICTION_HCL (acursession,row_STRUCTRESTRICTION.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDRESTRICTION where FIELDRESTRICTIONid=row_FIELDRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= FIELDRESTRICTION_HCL (acursession,row_FIELDRESTRICTION.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from METHODRESTRICTION where METHODRESTRICTIONid=row_METHODRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= METHODRESTRICTION_HCL (acursession,row_METHODRESTRICTION.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_UNLOCK /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= OBJECTMODE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJECTMODE set LockUserID =null  where OBJECTMODEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJECTMODE set LockSessionID =null  where OBJECTMODEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_SINIT /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=OBJECTMODE_parent_T( aCURSESSION,aROWID);
 aParentID:= OBJECTMODE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update OBJECTMODE set securitystyleid =aStyleID where OBJECTMODEid = aRowID;
else 
 update OBJECTMODE set securitystyleid =aSecurityStyleID where OBJECTMODEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  OBJECTMODE_propagate /*Режим работы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from OBJECTMODE where OBJECTMODEid=aRowid;
open aCurs for select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  STRUCTRESTRICTION_SINIT( acursession,aid,assid);
 PERFORM  STRUCTRESTRICTION_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  FIELDRESTRICTION_SINIT( acursession,aid,assid);
 PERFORM  FIELDRESTRICTION_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  METHODRESTRICTION_SINIT( acursession,aid,assid);
 PERFORM  METHODRESTRICTION_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  STRUCTRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSTRUCTRESTRICTIONid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0
 then
  aBRIEF:= STRUCTRESTRICTION_BRIEF_F(aSTRUCTRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_DELETE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  STRUCTRESTRICTION_ISLOCKED( acursession,aSTRUCTRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aSTRUCTRESTRICTIONid as varchar),   'STRUCTRESTRICTION',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='STRUCTRESTRICTION' and OwnerRowID=aSTRUCTRESTRICTIONid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  STRUCTRESTRICTION 
  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Органичения разделов*/
 create or replace function  STRUCTRESTRICTION_SAVE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aSTRUCTRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aStruct
 uuid/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aAllowRead
 INTEGER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowAdd
 INTEGER/* Разрешено добавлять *//* Разрешено добавлять */
,aAllowEdit
 INTEGER/* Разрешено изменять *//* Разрешено изменять */
,aAllowDelete
 INTEGER/* Разрешено удалять *//* Разрешено удалять */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  STRUCTRESTRICTION_ISLOCKED( acursession,aSTRUCTRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aSTRUCTRESTRICTIONid as varchar),  'STRUCTRESTRICTION',
 'EDITROW',  aInstanceID);
 update  STRUCTRESTRICTION set ChangeStamp=localtimestamp
,
  Struct=aStruct
,
  AllowRead=aAllowRead
,
  AllowAdd=aAllowAdd
,
  AllowEdit=aAllowEdit
,
  AllowDelete=aAllowDelete
  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTMODE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aSTRUCTRESTRICTIONid as varchar),  'STRUCTRESTRICTION',
 'CREATEROW',  aInstanceID);
 insert into   STRUCTRESTRICTION
 (  STRUCTRESTRICTIONID 
,ParentStructRowID
,Struct

,AllowRead

,AllowAdd

,AllowEdit

,AllowDelete

 ) values ( aSTRUCTRESTRICTIONID 
,aParentStructRowID
,aStruct

,aAllowRead

,aAllowAdd

,aAllowEdit

,aAllowDelete

 ); 
 PERFORM STRUCTRESTRICTION_SINIT( aCURSESSION,aSTRUCTRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  STRUCTRESTRICTION_PARENT_T /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTMODE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  STRUCTRESTRICTION_PARENT_ID /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from STRUCTRESTRICTION where  STRUCTRESTRICTIONid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_ISLOCKED /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_LOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= STRUCTRESTRICTION_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= STRUCTRESTRICTION_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update STRUCTRESTRICTION set LockUserID =auserID ,LockSessionID =null where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STRUCTRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_HCL /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_UNLOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= STRUCTRESTRICTION_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STRUCTRESTRICTION set LockUserID =null  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STRUCTRESTRICTION set LockSessionID =null  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_SINIT /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=STRUCTRESTRICTION_parent_T( aCURSESSION,aROWID);
 aParentID:= STRUCTRESTRICTION_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update STRUCTRESTRICTION set securitystyleid =aStyleID where STRUCTRESTRICTIONid = aRowID;
else 
 update STRUCTRESTRICTION set securitystyleid =aSecurityStyleID where STRUCTRESTRICTIONid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  STRUCTRESTRICTION_propagate /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  FIELDRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFIELDRESTRICTIONid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0
 then
  aBRIEF:= FIELDRESTRICTION_BRIEF_F(aFIELDRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_DELETE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  FIELDRESTRICTION_ISLOCKED( acursession,aFIELDRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFIELDRESTRICTIONid as varchar),   'FIELDRESTRICTION',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='FIELDRESTRICTION' and OwnerRowID=aFIELDRESTRICTIONid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  FIELDRESTRICTION 
  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Ограничения полей*/
 create or replace function  FIELDRESTRICTION_SAVE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aFIELDRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aThePart
 uuid/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,aTheField
 uuid/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aAllowRead
 INTEGER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowModify
 INTEGER/* Разрешена модификация *//* Разрешена модификация */
,aMandatoryField
 integer/* Обязательное поле *//* Обязательное поле */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  FIELDRESTRICTION_ISLOCKED( acursession,aFIELDRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFIELDRESTRICTIONid as varchar),  'FIELDRESTRICTION',
 'EDITROW',  aInstanceID);
 update  FIELDRESTRICTION set ChangeStamp=localtimestamp
,
  ThePart=aThePart
,
  TheField=aTheField
,
  AllowRead=aAllowRead
,
  AllowModify=aAllowModify
,
  MandatoryField=aMandatoryField
  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTMODE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFIELDRESTRICTIONid as varchar),  'FIELDRESTRICTION',
 'CREATEROW',  aInstanceID);
 insert into   FIELDRESTRICTION
 (  FIELDRESTRICTIONID 
,ParentStructRowID
,ThePart

,TheField

,AllowRead

,AllowModify

,MandatoryField

 ) values ( aFIELDRESTRICTIONID 
,aParentStructRowID
,aThePart

,aTheField

,aAllowRead

,aAllowModify

,aMandatoryField

 ); 
 PERFORM FIELDRESTRICTION_SINIT( aCURSESSION,aFIELDRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  FIELDRESTRICTION_PARENT_T /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTMODE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  FIELDRESTRICTION_PARENT_ID /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from FIELDRESTRICTION where  FIELDRESTRICTIONid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_ISLOCKED /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDRESTRICTION where FIELDRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_LOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= FIELDRESTRICTION_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= FIELDRESTRICTION_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update FIELDRESTRICTION set LockUserID =auserID ,LockSessionID =null where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_HCL /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_UNLOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= FIELDRESTRICTION_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDRESTRICTION set LockUserID =null  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDRESTRICTION set LockSessionID =null  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_SINIT /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=FIELDRESTRICTION_parent_T( aCURSESSION,aROWID);
 aParentID:= FIELDRESTRICTION_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update FIELDRESTRICTION set securitystyleid =aStyleID where FIELDRESTRICTIONid = aRowID;
else 
 update FIELDRESTRICTION set securitystyleid =aSecurityStyleID where FIELDRESTRICTIONid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  FIELDRESTRICTION_propagate /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from FIELDRESTRICTION where FIELDRESTRICTIONid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  METHODRESTRICTION_BRIEF  (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMETHODRESTRICTIONid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0
 then
  aBRIEF:= METHODRESTRICTION_BRIEF_F(aMETHODRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_DELETE /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  METHODRESTRICTION_ISLOCKED( acursession,aMETHODRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=METHODRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMETHODRESTRICTIONid as varchar),   'METHODRESTRICTION',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='METHODRESTRICTION' and OwnerRowID=aMETHODRESTRICTIONid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  METHODRESTRICTION 
  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Ограничения методов*/
 create or replace function  METHODRESTRICTION_SAVE /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aMETHODRESTRICTIONid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aPart
 uuid/* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,aMethod
 uuid/* Метод *//* Метод */
,aIsRestricted
 INTEGER/* Запрещено использовать *//* Запрещено использовать */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  METHODRESTRICTION_ISLOCKED( acursession,aMETHODRESTRICTIONid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=METHODRESTRICTION');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMETHODRESTRICTIONid as varchar),  'METHODRESTRICTION',
 'EDITROW',  aInstanceID);
 update  METHODRESTRICTION set ChangeStamp=localtimestamp
,
  Part=aPart
,
  Method=aMethod
,
  IsRestricted=aIsRestricted
  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTMODE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=METHODRESTRICTION');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMETHODRESTRICTIONid as varchar),  'METHODRESTRICTION',
 'CREATEROW',  aInstanceID);
 insert into   METHODRESTRICTION
 (  METHODRESTRICTIONID 
,ParentStructRowID
,Part

,Method

,IsRestricted

 ) values ( aMETHODRESTRICTIONID 
,aParentStructRowID
,aPart

,aMethod

,aIsRestricted

 ); 
 PERFORM METHODRESTRICTION_SINIT( aCURSESSION,aMETHODRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  METHODRESTRICTION_PARENT_T /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTMODE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  METHODRESTRICTION_PARENT_ID /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from METHODRESTRICTION where  METHODRESTRICTIONid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_ISLOCKED /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from METHODRESTRICTION where METHODRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_LOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= METHODRESTRICTION_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= METHODRESTRICTION_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update METHODRESTRICTION set LockUserID =auserID ,LockSessionID =null where METHODRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update METHODRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_HCL /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_UNLOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= METHODRESTRICTION_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update METHODRESTRICTION set LockUserID =null  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update METHODRESTRICTION set LockSessionID =null  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_SINIT /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=METHODRESTRICTION_parent_T( aCURSESSION,aROWID);
 aParentID:= METHODRESTRICTION_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update METHODRESTRICTION set securitystyleid =aStyleID where METHODRESTRICTIONid = aRowID;
else 
 update METHODRESTRICTION set securitystyleid =aSecurityStyleID where METHODRESTRICTIONid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  METHODRESTRICTION_propagate /*Ограничение на использование методов раздела*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from METHODRESTRICTION where METHODRESTRICTIONid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  TYPEMENU_BRIEF  (
 aCURSESSION uuid,
 aTYPEMENUid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aTYPEMENUid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0
 then
  aBRIEF:= TYPEMENU_BRIEF_F(aTYPEMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_DELETE /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aTYPEMENUid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  TYPEMENU_ISLOCKED( acursession,aTYPEMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=TYPEMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aTYPEMENUid as varchar),   'TYPEMENU',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='TYPEMENU' and OwnerRowID=aTYPEMENUid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  TYPEMENU 
  where  TYPEMENUID = aTYPEMENUID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Методы типа*/
 create or replace function  TYPEMENU_SAVE /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aTYPEMENUid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR/* Подсказка *//* Подсказка */
,athe_Action
 uuid/* Метод *//* Метод */
,aIsMenuItem
 INTEGER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 INTEGER/* Включать в тулбар *//* Включать в тулбар */
,aHotKey
 VARCHAR/* Горячая клавиша *//* Горячая клавиша */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  TYPEMENU_ISLOCKED( acursession,aTYPEMENUid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=TYPEMENU');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aTYPEMENUid as varchar),  'TYPEMENU',
 'EDITROW',  aInstanceID);
 update  TYPEMENU set ChangeStamp=localtimestamp
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  the_Action=athe_Action
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  TYPEMENUID = aTYPEMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= OBJECTTYPE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=TYPEMENU');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aTYPEMENUid as varchar),  'TYPEMENU',
 'CREATEROW',  aInstanceID);
 insert into   TYPEMENU
 (  TYPEMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,the_Action

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aTYPEMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,athe_Action

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 PERFORM TYPEMENU_SINIT( aCURSESSION,aTYPEMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  TYPEMENU_PARENT_T /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'OBJECTTYPE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  TYPEMENU_PARENT_ID /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from TYPEMENU where  TYPEMENUid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_ISLOCKED /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from TYPEMENU where TYPEMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_LOCK /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= TYPEMENU_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= TYPEMENU_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update TYPEMENU set LockUserID =auserID ,LockSessionID =null where TYPEMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update TYPEMENU set LockUserID =null,LockSessionID =aCURSESSION  where TYPEMENUid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_HCL /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_UNLOCK /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= TYPEMENU_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update TYPEMENU set LockUserID =null  where TYPEMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update TYPEMENU set LockSessionID =null  where TYPEMENUid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_SINIT /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=TYPEMENU_parent_T( aCURSESSION,aROWID);
 aParentID:= TYPEMENU_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update TYPEMENU set securitystyleid =aStyleID where TYPEMENUid = aRowID;
else 
 update TYPEMENU set securitystyleid =aSecurityStyleID where TYPEMENUid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  TYPEMENU_propagate /*Методы уровня типа*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from TYPEMENU where TYPEMENUid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZAPP_BRIEF  (
 aCURSESSION uuid,
 aMTZAPPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZAPPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZAPP_BRIEF_F(aMTZAPPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_DELETE /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aMTZAPPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZAPP_ISLOCKED( acursession,aMTZAPPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZAPP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aMTZAPPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ParentPackage_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZAPPid as varchar),   'MTZAPP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZAPP' and OwnerRowID=aMTZAPPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZAPP 
  where  MTZAPPID = aMTZAPPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Приложение*/
 create or replace function  MTZAPP_SAVE /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aMTZAPPid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aDBName
 VARCHAR/* База данных *//* База данных */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZAPP_ISLOCKED( acursession,aMTZAPPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZAPP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZAPPid as varchar),  'MTZAPP',
 'EDITROW',  aInstanceID);
 update  MTZAPP set ChangeStamp=localtimestamp
,
  Name=aName
,
  DBName=aDBName
,
  TheComment=aTheComment
  where  MTZAPPID = aMTZAPPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZAPP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZAPPid as varchar),  'MTZAPP',
 'CREATEROW',  aInstanceID);
 insert into   MTZAPP
 (  MTZAPPID 
,InstanceID
,Name

,DBName

,TheComment

 ) values ( aMTZAPPID 
,aInstanceID
,aName

,aDBName

,aTheComment

 ); 
 PERFORM MTZAPP_SINIT( aCURSESSION,aMTZAPPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZAPP_PARENT_T /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZAPP_PARENT_ID /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZAPP where  MTZAPPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_ISLOCKED /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZAPP where MTZAPPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_LOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZAPP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZAPP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZAPP set LockUserID =auserID ,LockSessionID =null where MTZAPPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZAPP set LockUserID =null,LockSessionID =aCURSESSION  where MTZAPPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_HCL /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ParentPackage where ParentPackageid=row_ParentPackage.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ParentPackage_HCL (acursession,row_ParentPackage.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZAPP_UNLOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZAPP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZAPP set LockUserID =null  where MTZAPPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZAPP set LockSessionID =null  where MTZAPPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_SINIT /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZAPP_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZAPP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZAPP set securitystyleid =aStyleID where MTZAPPid = aRowID;
else 
 update MTZAPP set securitystyleid =aSecurityStyleID where MTZAPPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZAPP_propagate /*Группа взаимосвязных документов*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZAPP where MTZAPPid=aRowid;
open aCurs for select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ParentPackage_SINIT( acursession,aid,assid);
 PERFORM  ParentPackage_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  ParentPackage_BRIEF  (
 aCURSESSION uuid,
 aParentPackageid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aParentPackageid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0
 then
  aBRIEF:= ParentPackage_BRIEF_F(aParentPackageid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_DELETE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aParentPackageid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ParentPackage_ISLOCKED( acursession,aParentPackageid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ParentPackage');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aParentPackageid as varchar),   'ParentPackage',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ParentPackage' and OwnerRowID=aParentPackageid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ParentPackage 
  where  ParentPackageID = aParentPackageID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Обязательные приложения*/
 create or replace function  ParentPackage_SAVE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aParentPackageid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aPackage
 uuid/* Приложение *//* Приложение */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ParentPackage_ISLOCKED( acursession,aParentPackageid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ParentPackage');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aParentPackageid as varchar),  'ParentPackage',
 'EDITROW',  aInstanceID);
 update  ParentPackage set ChangeStamp=localtimestamp
,
  Package=aPackage
  where  ParentPackageID = aParentPackageID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= MTZAPP_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ParentPackage');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aParentPackageid as varchar),  'ParentPackage',
 'CREATEROW',  aInstanceID);
 insert into   ParentPackage
 (  ParentPackageID 
,ParentStructRowID
,Package

 ) values ( aParentPackageID 
,aParentStructRowID
,aPackage

 ); 
 PERFORM ParentPackage_SINIT( aCURSESSION,aParentPackageid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ParentPackage_PARENT_T /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'MTZAPP';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ParentPackage_PARENT_ID /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ParentPackage where  ParentPackageid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_ISLOCKED /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ParentPackage where ParentPackageid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_LOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ParentPackage_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ParentPackage_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ParentPackage set LockUserID =auserID ,LockSessionID =null where ParentPackageid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ParentPackage set LockUserID =null,LockSessionID =aCURSESSION  where ParentPackageid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_HCL /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ParentPackage_UNLOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ParentPackage_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ParentPackage set LockUserID =null  where ParentPackageid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ParentPackage set LockSessionID =null  where ParentPackageid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_SINIT /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ParentPackage_parent_T( aCURSESSION,aROWID);
 aParentID:= ParentPackage_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ParentPackage set securitystyleid =aStyleID where ParentPackageid = aRowID;
else 
 update ParentPackage set securitystyleid =aSecurityStyleID where ParentPackageid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ParentPackage_propagate /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ParentPackage where ParentPackageid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  GENPACKAGE_BRIEF  (
 aCURSESSION uuid,
 aGENPACKAGEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGENPACKAGEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0
 then
  aBRIEF:= GENPACKAGE_BRIEF_F(aGENPACKAGEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_DELETE /*Пакет генерации*/ (
 aCURSESSION uuid,
 aGENPACKAGEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GENPACKAGE_ISLOCKED( acursession,aGENPACKAGEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENPACKAGE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aGENPACKAGEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENERATOR_TARGET_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGENPACKAGEid as varchar),   'GENPACKAGE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GENPACKAGE' and OwnerRowID=aGENPACKAGEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GENPACKAGE 
  where  GENPACKAGEID = aGENPACKAGEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Пакет генерации*/
 create or replace function  GENPACKAGE_SAVE /*Пакет генерации*/ (
 aCURSESSION uuid,
 aGENPACKAGEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GENPACKAGE_ISLOCKED( acursession,aGENPACKAGEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENPACKAGE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGENPACKAGEid as varchar),  'GENPACKAGE',
 'EDITROW',  aInstanceID);
 update  GENPACKAGE set ChangeStamp=localtimestamp
,
  Name=aName
  where  GENPACKAGEID = aGENPACKAGEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENPACKAGE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGENPACKAGEid as varchar),  'GENPACKAGE',
 'CREATEROW',  aInstanceID);
 insert into   GENPACKAGE
 (  GENPACKAGEID 
,InstanceID
,Name

 ) values ( aGENPACKAGEID 
,aInstanceID
,aName

 ); 
 PERFORM GENPACKAGE_SINIT( aCURSESSION,aGENPACKAGEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GENPACKAGE_PARENT_T /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GENPACKAGE_PARENT_ID /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from GENPACKAGE where  GENPACKAGEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_ISLOCKED /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENPACKAGE where GENPACKAGEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_LOCK /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GENPACKAGE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GENPACKAGE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GENPACKAGE set LockUserID =auserID ,LockSessionID =null where GENPACKAGEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENPACKAGE set LockUserID =null,LockSessionID =aCURSESSION  where GENPACKAGEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_HCL /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENERATOR_TARGET where GENERATOR_TARGETid=row_GENERATOR_TARGET.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= GENERATOR_TARGET_HCL (acursession,row_GENERATOR_TARGET.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_UNLOCK /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GENPACKAGE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENPACKAGE set LockUserID =null  where GENPACKAGEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENPACKAGE set LockSessionID =null  where GENPACKAGEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_SINIT /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GENPACKAGE_parent_T( aCURSESSION,aROWID);
 aParentID:= GENPACKAGE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GENPACKAGE set securitystyleid =aStyleID where GENPACKAGEid = aRowID;
else 
 update GENPACKAGE set securitystyleid =aSecurityStyleID where GENPACKAGEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GENPACKAGE_propagate /*Пакет генерации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GENPACKAGE where GENPACKAGEid=aRowid;
open aCurs for select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENERATOR_TARGET_SINIT( acursession,aid,assid);
 PERFORM  GENERATOR_TARGET_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  GENERATOR_TARGET_BRIEF  (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGENERATOR_TARGETid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0
 then
  aBRIEF:= GENERATOR_TARGET_BRIEF_F(aGENERATOR_TARGETid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_DELETE /*Генераторы*/ (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GENERATOR_TARGET_ISLOCKED( acursession,aGENERATOR_TARGETid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aGENERATOR_TARGETid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENMANUALCODE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aGENERATOR_TARGETid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENCONTROLS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aGENERATOR_TARGETid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENREFERENCE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGENERATOR_TARGETid as varchar),   'GENERATOR_TARGET',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GENERATOR_TARGET' and OwnerRowID=aGENERATOR_TARGETid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GENERATOR_TARGET 
  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Генераторы*/
 create or replace function  GENERATOR_TARGET_SAVE /*Генераторы*/ (
 aCURSESSION uuid,
 aGENERATOR_TARGETid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTargetType
 integer/* Тип платформы *//* Тип платформы */
,aQueueName
 VARCHAR/* Очередь *//* Очередь */
,aGeneratorProgID
 VARCHAR/* COM класс *//* COM класс */
,aGeneratorStyle
 INTEGER/* Вариант *//* Вариант */
,aTheDevelopmentEnv
 INTEGER/* Среда разработки *//* Среда разработки */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GENERATOR_TARGET_ISLOCKED( acursession,aGENERATOR_TARGETid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGENERATOR_TARGETid as varchar),  'GENERATOR_TARGET',
 'EDITROW',  aInstanceID);
 update  GENERATOR_TARGET set ChangeStamp=localtimestamp
,
  Name=aName
,
  TargetType=aTargetType
,
  QueueName=aQueueName
,
  GeneratorProgID=aGeneratorProgID
,
  GeneratorStyle=aGeneratorStyle
,
  TheDevelopmentEnv=aTheDevelopmentEnv
  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= GENPACKAGE_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGENERATOR_TARGETid as varchar),  'GENERATOR_TARGET',
 'CREATEROW',  aInstanceID);
 insert into   GENERATOR_TARGET
 (  GENERATOR_TARGETID 
,ParentStructRowID
,Name

,TargetType

,QueueName

,GeneratorProgID

,GeneratorStyle

,TheDevelopmentEnv

 ) values ( aGENERATOR_TARGETID 
,aParentStructRowID
,aName

,aTargetType

,aQueueName

,aGeneratorProgID

,aGeneratorStyle

,aTheDevelopmentEnv

 ); 
 PERFORM GENERATOR_TARGET_SINIT( aCURSESSION,aGENERATOR_TARGETid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GENERATOR_TARGET_PARENT_T /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'GENPACKAGE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GENERATOR_TARGET_PARENT_ID /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from GENERATOR_TARGET where  GENERATOR_TARGETid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_ISLOCKED /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENERATOR_TARGET where GENERATOR_TARGETid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_LOCK /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GENERATOR_TARGET_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GENERATOR_TARGET_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GENERATOR_TARGET set LockUserID =auserID ,LockSessionID =null where GENERATOR_TARGETid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENERATOR_TARGET set LockUserID =null,LockSessionID =aCURSESSION  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_HCL /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENMANUALCODE where GENMANUALCODEid=row_GENMANUALCODE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= GENMANUALCODE_HCL (acursession,row_GENMANUALCODE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENCONTROLS where GENCONTROLSid=row_GENCONTROLS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= GENCONTROLS_HCL (acursession,row_GENCONTROLS.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENREFERENCE where GENREFERENCEid=row_GENREFERENCE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= GENREFERENCE_HCL (acursession,row_GENREFERENCE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_UNLOCK /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GENERATOR_TARGET_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENERATOR_TARGET set LockUserID =null  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENERATOR_TARGET set LockSessionID =null  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_SINIT /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GENERATOR_TARGET_parent_T( aCURSESSION,aROWID);
 aParentID:= GENERATOR_TARGET_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GENERATOR_TARGET set securitystyleid =aStyleID where GENERATOR_TARGETid = aRowID;
else 
 update GENERATOR_TARGET set securitystyleid =aSecurityStyleID where GENERATOR_TARGETid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GENERATOR_TARGET_propagate /*Генераторы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GENERATOR_TARGET where GENERATOR_TARGETid=aRowid;
open aCurs for select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENMANUALCODE_SINIT( acursession,aid,assid);
 PERFORM  GENMANUALCODE_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENCONTROLS_SINIT( acursession,aid,assid);
 PERFORM  GENCONTROLS_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GENREFERENCE_SINIT( acursession,aid,assid);
 PERFORM  GENREFERENCE_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  GENMANUALCODE_BRIEF  (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGENMANUALCODEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0
 then
  aBRIEF:= GENMANUALCODE_BRIEF_F(aGENMANUALCODEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_DELETE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GENMANUALCODE_ISLOCKED( acursession,aGENMANUALCODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENMANUALCODE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGENMANUALCODEid as varchar),   'GENMANUALCODE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GENMANUALCODE' and OwnerRowID=aGENMANUALCODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GENMANUALCODE 
  where  GENMANUALCODEID = aGENMANUALCODEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Ручной код*/
 create or replace function  GENMANUALCODE_SAVE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aGENMANUALCODEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,athe_Alias
 VARCHAR/* Псевдоним *//* Псевдоним */
,aCode
 TEXT/* Код *//* Код */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GENMANUALCODE_ISLOCKED( acursession,aGENMANUALCODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENMANUALCODE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGENMANUALCODEid as varchar),  'GENMANUALCODE',
 'EDITROW',  aInstanceID);
 update  GENMANUALCODE set ChangeStamp=localtimestamp
,
  Name=aName
,
  the_Alias=athe_Alias
,
  Code=aCode
  where  GENMANUALCODEID = aGENMANUALCODEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= GENERATOR_TARGET_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENMANUALCODE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGENMANUALCODEid as varchar),  'GENMANUALCODE',
 'CREATEROW',  aInstanceID);
 insert into   GENMANUALCODE
 (  GENMANUALCODEID 
,ParentStructRowID
,Name

,the_Alias

,Code

 ) values ( aGENMANUALCODEID 
,aParentStructRowID
,aName

,athe_Alias

,aCode

 ); 
 PERFORM GENMANUALCODE_SINIT( aCURSESSION,aGENMANUALCODEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GENMANUALCODE_PARENT_T /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'GENERATOR_TARGET';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GENMANUALCODE_PARENT_ID /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from GENMANUALCODE where  GENMANUALCODEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_ISLOCKED /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENMANUALCODE where GENMANUALCODEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_LOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GENMANUALCODE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GENMANUALCODE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GENMANUALCODE set LockUserID =auserID ,LockSessionID =null where GENMANUALCODEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENMANUALCODE set LockUserID =null,LockSessionID =aCURSESSION  where GENMANUALCODEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_HCL /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_UNLOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GENMANUALCODE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENMANUALCODE set LockUserID =null  where GENMANUALCODEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENMANUALCODE set LockSessionID =null  where GENMANUALCODEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_SINIT /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GENMANUALCODE_parent_T( aCURSESSION,aROWID);
 aParentID:= GENMANUALCODE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GENMANUALCODE set securitystyleid =aStyleID where GENMANUALCODEid = aRowID;
else 
 update GENMANUALCODE set securitystyleid =aSecurityStyleID where GENMANUALCODEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GENMANUALCODE_propagate /*Код, который не укладывается в описание модели*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GENMANUALCODE where GENMANUALCODEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  GENCONTROLS_BRIEF  (
 aCURSESSION uuid,
 aGENCONTROLSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGENCONTROLSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0
 then
  aBRIEF:= GENCONTROLS_BRIEF_F(aGENCONTROLSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_DELETE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aGENCONTROLSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GENCONTROLS_ISLOCKED( acursession,aGENCONTROLSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENCONTROLS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGENCONTROLSid as varchar),   'GENCONTROLS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GENCONTROLS' and OwnerRowID=aGENCONTROLSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GENCONTROLS 
  where  GENCONTROLSID = aGENCONTROLSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Контрольные элементы*/
 create or replace function  GENCONTROLS_SAVE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aGENCONTROLSid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aControlProgID
 VARCHAR/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,aControlClassID
 VARCHAR/* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aVersionMajor
 integer/* Версия *//* Версия */
,aVersionMinor
 integer/* Подверсия *//* Подверсия */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GENCONTROLS_ISLOCKED( acursession,aGENCONTROLSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENCONTROLS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGENCONTROLSid as varchar),  'GENCONTROLS',
 'EDITROW',  aInstanceID);
 update  GENCONTROLS set ChangeStamp=localtimestamp
,
  ControlProgID=aControlProgID
,
  ControlClassID=aControlClassID
,
  VersionMajor=aVersionMajor
,
  VersionMinor=aVersionMinor
  where  GENCONTROLSID = aGENCONTROLSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= GENERATOR_TARGET_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENCONTROLS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGENCONTROLSid as varchar),  'GENCONTROLS',
 'CREATEROW',  aInstanceID);
 insert into   GENCONTROLS
 (  GENCONTROLSID 
,ParentStructRowID
,ControlProgID

,ControlClassID

,VersionMajor

,VersionMinor

 ) values ( aGENCONTROLSID 
,aParentStructRowID
,aControlProgID

,aControlClassID

,aVersionMajor

,aVersionMinor

 ); 
 PERFORM GENCONTROLS_SINIT( aCURSESSION,aGENCONTROLSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GENCONTROLS_PARENT_T /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'GENERATOR_TARGET';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GENCONTROLS_PARENT_ID /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from GENCONTROLS where  GENCONTROLSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_ISLOCKED /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENCONTROLS where GENCONTROLSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_LOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GENCONTROLS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GENCONTROLS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GENCONTROLS set LockUserID =auserID ,LockSessionID =null where GENCONTROLSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENCONTROLS set LockUserID =null,LockSessionID =aCURSESSION  where GENCONTROLSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_HCL /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_UNLOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GENCONTROLS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENCONTROLS set LockUserID =null  where GENCONTROLSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENCONTROLS set LockSessionID =null  where GENCONTROLSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_SINIT /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GENCONTROLS_parent_T( aCURSESSION,aROWID);
 aParentID:= GENCONTROLS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GENCONTROLS set securitystyleid =aStyleID where GENCONTROLSid = aRowID;
else 
 update GENCONTROLS set securitystyleid =aSecurityStyleID where GENCONTROLSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GENCONTROLS_propagate /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GENCONTROLS where GENCONTROLSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  GENREFERENCE_BRIEF  (
 aCURSESSION uuid,
 aGENREFERENCEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGENREFERENCEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0
 then
  aBRIEF:= GENREFERENCE_BRIEF_F(aGENREFERENCEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_DELETE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aGENREFERENCEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GENREFERENCE_ISLOCKED( acursession,aGENREFERENCEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENREFERENCE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGENREFERENCEid as varchar),   'GENREFERENCE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GENREFERENCE' and OwnerRowID=aGENREFERENCEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GENREFERENCE 
  where  GENREFERENCEID = aGENREFERENCEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Библиотеки*/
 create or replace function  GENREFERENCE_SAVE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aGENREFERENCEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aRefClassID
 VARCHAR/* Класс ссылки *//* Класс ссылки */
,aVersionMajor
 integer/* Номер версии *//* Номер версии */
,aVersionMinor
 integer/* Подверсия *//* Подверсия */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GENREFERENCE_ISLOCKED( acursession,aGENREFERENCEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENREFERENCE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGENREFERENCEid as varchar),  'GENREFERENCE',
 'EDITROW',  aInstanceID);
 update  GENREFERENCE set ChangeStamp=localtimestamp
,
  Name=aName
,
  RefClassID=aRefClassID
,
  VersionMajor=aVersionMajor
,
  VersionMinor=aVersionMinor
  where  GENREFERENCEID = aGENREFERENCEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= GENERATOR_TARGET_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENREFERENCE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGENREFERENCEid as varchar),  'GENREFERENCE',
 'CREATEROW',  aInstanceID);
 insert into   GENREFERENCE
 (  GENREFERENCEID 
,ParentStructRowID
,Name

,RefClassID

,VersionMajor

,VersionMinor

 ) values ( aGENREFERENCEID 
,aParentStructRowID
,aName

,aRefClassID

,aVersionMajor

,aVersionMinor

 ); 
 PERFORM GENREFERENCE_SINIT( aCURSESSION,aGENREFERENCEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GENREFERENCE_PARENT_T /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'GENERATOR_TARGET';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GENREFERENCE_PARENT_ID /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from GENREFERENCE where  GENREFERENCEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_ISLOCKED /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENREFERENCE where GENREFERENCEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_LOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GENREFERENCE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GENREFERENCE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GENREFERENCE set LockUserID =auserID ,LockSessionID =null where GENREFERENCEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENREFERENCE set LockUserID =null,LockSessionID =aCURSESSION  where GENREFERENCEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_HCL /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_UNLOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GENREFERENCE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENREFERENCE set LockUserID =null  where GENREFERENCEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENREFERENCE set LockSessionID =null  where GENREFERENCEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_SINIT /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GENREFERENCE_parent_T( aCURSESSION,aROWID);
 aParentID:= GENREFERENCE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GENREFERENCE set securitystyleid =aStyleID where GENREFERENCEid = aRowID;
else 
 update GENREFERENCE set securitystyleid =aSecurityStyleID where GENREFERENCEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GENREFERENCE_propagate /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GENREFERENCE where GENREFERENCEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  LocalizeInfo_BRIEF  (
 aCURSESSION uuid,
 aLocalizeInfoid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aLocalizeInfoid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0
 then
  aBRIEF:= LocalizeInfo_BRIEF_F(aLocalizeInfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_DELETE /**/ (
 aCURSESSION uuid,
 aLocalizeInfoid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  LocalizeInfo_ISLOCKED( acursession,aLocalizeInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=LocalizeInfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aLocalizeInfoid as varchar),   'LocalizeInfo',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='LocalizeInfo' and OwnerRowID=aLocalizeInfoid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  LocalizeInfo 
  where  LocalizeInfoID = aLocalizeInfoID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Локализация*/
 create or replace function  LocalizeInfo_SAVE /**/ (
 aCURSESSION uuid,
 aLocalizeInfoid uuid,
ainstanceid uuid 
,aLangFull
 VARCHAR/* Язык - название *//* Язык - название */
,aLangShort
 VARCHAR/* Код языка *//* Код языка */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  LocalizeInfo_ISLOCKED( acursession,aLocalizeInfoid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LocalizeInfo');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aLocalizeInfoid as varchar),  'LocalizeInfo',
 'EDITROW',  aInstanceID);
 update  LocalizeInfo set ChangeStamp=localtimestamp
,
  LangFull=aLangFull
,
  LangShort=aLangShort
  where  LocalizeInfoID = aLocalizeInfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LocalizeInfo');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aLocalizeInfoid as varchar),  'LocalizeInfo',
 'CREATEROW',  aInstanceID);
 insert into   LocalizeInfo
 (  LocalizeInfoID 
,InstanceID
,LangFull

,LangShort

 ) values ( aLocalizeInfoID 
,aInstanceID
,aLangFull

,aLangShort

 ); 
 PERFORM LocalizeInfo_SINIT( aCURSESSION,aLocalizeInfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  LocalizeInfo_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  LocalizeInfo_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from LocalizeInfo where  LocalizeInfoid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from LocalizeInfo where LocalizeInfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= LocalizeInfo_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= LocalizeInfo_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update LocalizeInfo set LockUserID =auserID ,LockSessionID =null where LocalizeInfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update LocalizeInfo set LockUserID =null,LockSessionID =aCURSESSION  where LocalizeInfoid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= LocalizeInfo_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update LocalizeInfo set LockUserID =null  where LocalizeInfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update LocalizeInfo set LockSessionID =null  where LocalizeInfoid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=LocalizeInfo_parent_T( aCURSESSION,aROWID);
 aParentID:= LocalizeInfo_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update LocalizeInfo set securitystyleid =aStyleID where LocalizeInfoid = aRowID;
else 
 update LocalizeInfo set securitystyleid =aSecurityStyleID where LocalizeInfoid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  LocalizeInfo_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from LocalizeInfo where LocalizeInfoid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDNumerator" BlockCode=" create or replace function  STDNumerator_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='STDNumerator'
then
Open aCurs  for select Num_zones.Num_zonesid ID from Num_zones where  Num_zones.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Num_zones_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Num_head.Num_headid ID from Num_head where  Num_head.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Num_head_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDNumerator_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'STDNumerator'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select Num_zones.Num_zonesid ID from Num_zones where  Num_zones.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Num_zones where Num_zonesid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Num_zones_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Num_head.Num_headid ID from Num_head where  Num_head.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Num_head where Num_headid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Num_head_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDNumerator_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'STDNumerator'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select Num_zones.Num_zonesid id from Num_zones where  Num_zones.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Num_zones_SINIT( acursession,aid,assid);
 PERFORM Num_zones_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Num_head.Num_headid id from Num_head where  Num_head.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Num_head_SINIT( acursession,aid,assid);
 PERFORM Num_head_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  Num_zones_BRIEF  (
 aCURSESSION uuid,
 aNum_zonesid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aNum_zonesid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0
 then
  aBRIEF:= Num_zones_BRIEF_F(aNum_zonesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Num_zones_DELETE /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aNum_zonesid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Num_zones_ISLOCKED( acursession,aNum_zonesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_zones');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aNum_zonesid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Num_Values_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aNum_zonesid as varchar),   'Num_zones',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Num_zones' and OwnerRowID=aNum_zonesid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Num_zones 
  where  Num_zonesID = aNum_zonesID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Зоны*/
 create or replace function  Num_zones_SAVE /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aNum_zonesid uuid,
ainstanceid uuid 
,aZoneMask
 VARCHAR/* Маска зоны *//* Маска зоны */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Num_zones_ISLOCKED( acursession,aNum_zonesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_zones');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aNum_zonesid as varchar),  'Num_zones',
 'EDITROW',  aInstanceID);
 update  Num_zones set ChangeStamp=localtimestamp
,
  ZoneMask=aZoneMask
  where  Num_zonesID = aNum_zonesID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Num_zones where InstanceID=aInstanceID 
 and ZoneMask=aZoneMask;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_zones');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_zones');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aNum_zonesid as varchar),  'Num_zones',
 'CREATEROW',  aInstanceID);
 insert into   Num_zones
 (  Num_zonesID 
,InstanceID
,ZoneMask

 ) values ( aNum_zonesID 
,aInstanceID
,aZoneMask

 ); 
 PERFORM Num_zones_SINIT( aCURSESSION,aNum_zonesid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Num_zones where InstanceID=aInstanceID 
 and ZoneMask=aZoneMask;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_zones');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Num_zones_PARENT_T /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Num_zones_PARENT_ID /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Num_zones where  Num_zonesid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_ISLOCKED /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_zones where Num_zonesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_LOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Num_zones_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Num_zones_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Num_zones set LockUserID =auserID ,LockSessionID =null where Num_zonesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_zones set LockUserID =null,LockSessionID =aCURSESSION  where Num_zonesid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_HCL /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from Num_Values where Num_Valuesid=row_Num_Values.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= Num_Values_HCL (acursession,row_Num_Values.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Num_zones_UNLOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Num_zones_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_zones set LockUserID =null  where Num_zonesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_zones set LockSessionID =null  where Num_zonesid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_SINIT /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Num_zones_parent_T( aCURSESSION,aROWID);
 aParentID:= Num_zones_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Num_zones set securitystyleid =aStyleID where Num_zonesid = aRowID;
else 
 update Num_zones set securitystyleid =aSecurityStyleID where Num_zonesid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Num_zones_propagate /*Зоны уникальных нумеров*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Num_zones where Num_zonesid=aRowid;
open aCurs for select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Num_Values_SINIT( acursession,aid,assid);
 PERFORM  Num_Values_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  Num_Values_BRIEF  (
 aCURSESSION uuid,
 aNum_Valuesid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aNum_Valuesid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0
 then
  aBRIEF:= Num_Values_BRIEF_F(aNum_Valuesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Num_Values_DELETE /*уникальные номера*/ (
 aCURSESSION uuid,
 aNum_Valuesid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Num_Values_ISLOCKED( acursession,aNum_Valuesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_Values');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aNum_Valuesid as varchar),   'Num_Values',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Num_Values' and OwnerRowID=aNum_Valuesid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Num_Values 
  where  Num_ValuesID = aNum_ValuesID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Номера*/
 create or replace function  Num_Values_SAVE /*уникальные номера*/ (
 aCURSESSION uuid,
 aNum_Valuesid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,athe_Value
 integer/* Значение *//* Значение */
,aOwnerPartName
 VARCHAR/* Раздел *//* Раздел */
,aOwnerRowID
 uuid/* Идентификатор строки *//* Идентификатор строки */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Num_Values_ISLOCKED( acursession,aNum_Valuesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_Values');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aNum_Valuesid as varchar),  'Num_Values',
 'EDITROW',  aInstanceID);
 update  Num_Values set ChangeStamp=localtimestamp
,
  the_Value=athe_Value
,
  OwnerPartName=aOwnerPartName
,
  OwnerRowID=aOwnerRowID
  where  Num_ValuesID = aNum_ValuesID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Num_Values where ParentStructRowID=aParentStructRowID 
 and the_Value=athe_Value;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_Values');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= Num_zones_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_Values');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aNum_Valuesid as varchar),  'Num_Values',
 'CREATEROW',  aInstanceID);
 insert into   Num_Values
 (  Num_ValuesID 
,ParentStructRowID
,the_Value

,OwnerPartName

,OwnerRowID

 ) values ( aNum_ValuesID 
,aParentStructRowID
,athe_Value

,aOwnerPartName

,aOwnerRowID

 ); 
 PERFORM Num_Values_SINIT( aCURSESSION,aNum_Valuesid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Num_Values where ParentStructRowID=aParentStructRowID 
 and the_Value=athe_Value;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_Values');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Num_Values_PARENT_T /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'Num_zones';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Num_Values_PARENT_ID /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from Num_Values where  Num_Valuesid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_ISLOCKED /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_Values where Num_Valuesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_LOCK /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Num_Values_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Num_Values_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Num_Values set LockUserID =auserID ,LockSessionID =null where Num_Valuesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_Values set LockUserID =null,LockSessionID =aCURSESSION  where Num_Valuesid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_HCL /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Num_Values_UNLOCK /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Num_Values_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_Values set LockUserID =null  where Num_Valuesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_Values set LockSessionID =null  where Num_Valuesid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_SINIT /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Num_Values_parent_T( aCURSESSION,aROWID);
 aParentID:= Num_Values_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Num_Values set securitystyleid =aStyleID where Num_Valuesid = aRowID;
else 
 update Num_Values set securitystyleid =aSecurityStyleID where Num_Valuesid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Num_Values_propagate /*уникальные номера*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Num_Values where Num_Valuesid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Num_head_BRIEF  (
 aCURSESSION uuid,
 aNum_headid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aNum_headid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0
 then
  aBRIEF:= Num_head_BRIEF_F(aNum_headid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Num_head_DELETE /*Описание нумератора*/ (
 aCURSESSION uuid,
 aNum_headid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Num_head_ISLOCKED( acursession,aNum_headid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_head');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aNum_headid as varchar),   'Num_head',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Num_head' and OwnerRowID=aNum_headid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Num_head 
  where  Num_headID = aNum_headID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание*/
 create or replace function  Num_head_SAVE /*Описание нумератора*/ (
 aCURSESSION uuid,
 aNum_headid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aShema
 INTEGER/* Схема нумерации *//* Схема нумерации */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Num_head_ISLOCKED( acursession,aNum_headid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_head');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aNum_headid as varchar),  'Num_head',
 'EDITROW',  aInstanceID);
 update  Num_head set ChangeStamp=localtimestamp
,
  Name=aName
,
  Shema=aShema
  where  Num_headID = aNum_headID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_head');
    return;
  end if;
select Count(*) into existsCnt from Num_head where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Num_head&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aNum_headid as varchar),  'Num_head',
 'CREATEROW',  aInstanceID);
 insert into   Num_head
 (  Num_headID 
,InstanceID
,Name

,Shema

 ) values ( aNum_headID 
,aInstanceID
,aName

,aShema

 ); 
 PERFORM Num_head_SINIT( aCURSESSION,aNum_headid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Num_head_PARENT_T /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Num_head_PARENT_ID /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Num_head where  Num_headid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_head_ISLOCKED /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_head where Num_headid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_head_LOCK /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Num_head_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Num_head_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Num_head set LockUserID =auserID ,LockSessionID =null where Num_headid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_head set LockUserID =null,LockSessionID =aCURSESSION  where Num_headid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Num_head_HCL /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Num_head_UNLOCK /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Num_head_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_head set LockUserID =null  where Num_headid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_head set LockSessionID =null  where Num_headid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Num_head_SINIT /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Num_head_parent_T( aCURSESSION,aROWID);
 aParentID:= Num_head_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Num_head set securitystyleid =aStyleID where Num_headid = aRowID;
else 
 update Num_head set securitystyleid =aSecurityStyleID where Num_headid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Num_head_propagate /*Описание нумератора*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Num_head where Num_headid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--Ext_Photo_J" BlockCode=" create or replace function  Ext_Photo_J_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='Ext_Photo_J'
then
Open aCurs  for select Ext_Photos.Ext_Photosid ID from Ext_Photos where  Ext_Photos.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Ext_Photos_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photo_J_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'Ext_Photo_J'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select Ext_Photos.Ext_Photosid ID from Ext_Photos where  Ext_Photos.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Ext_Photos where Ext_Photosid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Ext_Photos_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  Ext_Photo_J_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'Ext_Photo_J'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select Ext_Photos.Ext_Photosid id from Ext_Photos where  Ext_Photos.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Ext_Photos_SINIT( acursession,aid,assid);
 PERFORM Ext_Photos_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  Ext_Photos_BRIEF  (
 aCURSESSION uuid,
 aExt_Photosid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aExt_Photosid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Ext_Photos where Ext_PhotosID=aExt_PhotosID;
if existsCnt &gt;0
 then
  aBRIEF:= Ext_Photos_BRIEF_F(aExt_Photosid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_DELETE /**/ (
 aCURSESSION uuid,
 aExt_Photosid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Ext_Photos where Ext_PhotosID=aExt_PhotosID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Ext_Photos_ISLOCKED( acursession,aExt_Photosid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Ext_Photos');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select Ext_Photo_Call.Ext_Photo_Callid ID from Ext_Photo_Call where  Ext_Photo_Call.ParentStructRowID = aExt_Photosid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Ext_Photo_Call_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aExt_Photosid as varchar),   'Ext_Photos',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Ext_Photos' and OwnerRowID=aExt_Photosid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Ext_Photos 
  where  Ext_PhotosID = aExt_PhotosID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Настройка*/
 create or replace function  Ext_Photos_SAVE /**/ (
 aCURSESSION uuid,
 aExt_Photosid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheSourceObject
 VARCHAR/* Исходный объект (Тип) *//* Исходный объект (Тип) */
,aTheJournal
 uuid/* Журнал *//* Журнал */
,aTheReplacedPart
 VARCHAR/* Подменяемая часть *//* Подменяемая часть */
,aTheRefFieldName
 VARCHAR/* Поле ссылка на добавление *//* Поле ссылка на добавление */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Ext_Photos where Ext_PhotosID=aExt_PhotosID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Ext_Photos_ISLOCKED( acursession,aExt_Photosid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Ext_Photos');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aExt_Photosid as varchar),  'Ext_Photos',
 'EDITROW',  aInstanceID);
 update  Ext_Photos set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  TheSourceObject=aTheSourceObject
,
  TheJournal=aTheJournal
,
  TheReplacedPart=aTheReplacedPart
,
  TheRefFieldName=aTheRefFieldName
  where  Ext_PhotosID = aExt_PhotosID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Ext_Photos');
    return;
  end if;
select Count(*) into existsCnt from Ext_Photos where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Ext_Photos&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aExt_Photosid as varchar),  'Ext_Photos',
 'CREATEROW',  aInstanceID);
 insert into   Ext_Photos
 (  Ext_PhotosID 
,InstanceID
,TheName

,TheSourceObject

,TheJournal

,TheReplacedPart

,TheRefFieldName

 ) values ( aExt_PhotosID 
,aInstanceID
,aTheName

,aTheSourceObject

,aTheJournal

,aTheReplacedPart

,aTheRefFieldName

 ); 
 PERFORM Ext_Photos_SINIT( aCURSESSION,aExt_Photosid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Ext_Photos_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photos_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Ext_Photos where  Ext_Photosid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Ext_Photos where Ext_Photosid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Ext_Photos_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Ext_Photos_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Ext_Photos set LockUserID =auserID ,LockSessionID =null where Ext_Photosid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Ext_Photos set LockUserID =null,LockSessionID =aCURSESSION  where Ext_Photosid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select Ext_Photo_Call.Ext_Photo_Callid ID from Ext_Photo_Call where  Ext_Photo_Call.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from Ext_Photo_Call where Ext_Photo_Callid=row_Ext_Photo_Call.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= Ext_Photo_Call_HCL (acursession,row_Ext_Photo_Call.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Ext_Photos_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Ext_Photos set LockUserID =null  where Ext_Photosid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Ext_Photos set LockSessionID =null  where Ext_Photosid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Ext_Photos_parent_T( aCURSESSION,aROWID);
 aParentID:= Ext_Photos_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Ext_Photos set securitystyleid =aStyleID where Ext_Photosid = aRowID;
else 
 update Ext_Photos set securitystyleid =aSecurityStyleID where Ext_Photosid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photos_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Ext_Photos where Ext_Photosid=aRowid;
open aCurs for select Ext_Photo_Call.Ext_Photo_Callid ID from Ext_Photo_Call where  Ext_Photo_Call.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Ext_Photo_Call_SINIT( acursession,aid,assid);
 PERFORM  Ext_Photo_Call_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  Ext_Photo_Call_BRIEF  (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aExt_Photo_Callid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Ext_Photo_Call where Ext_Photo_CallID=aExt_Photo_CallID;
if existsCnt &gt;0
 then
  aBRIEF:= Ext_Photo_Call_BRIEF_F(aExt_Photo_Callid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_DELETE /**/ (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Ext_Photo_Call where Ext_Photo_CallID=aExt_Photo_CallID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Ext_Photo_Call_ISLOCKED( acursession,aExt_Photo_Callid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Ext_Photo_Call');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aExt_Photo_Callid as varchar),   'Ext_Photo_Call',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Ext_Photo_Call' and OwnerRowID=aExt_Photo_Callid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Ext_Photo_Call 
  where  Ext_Photo_CallID = aExt_Photo_CallID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Вызов изображения*/
 create or replace function  Ext_Photo_Call_SAVE /**/ (
 aCURSESSION uuid,
 aExt_Photo_Callid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTargetPlatform
 uuid/* TargetPlatform *//* TargetPlatform */
,aTheCallString
 VARCHAR/* Вызов *//* Вызов */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Ext_Photo_Call where Ext_Photo_CallID=aExt_Photo_CallID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Ext_Photo_Call_ISLOCKED( acursession,aExt_Photo_Callid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Ext_Photo_Call');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aExt_Photo_Callid as varchar),  'Ext_Photo_Call',
 'EDITROW',  aInstanceID);
 update  Ext_Photo_Call set ChangeStamp=localtimestamp
,
  TargetPlatform=aTargetPlatform
,
  TheCallString=aTheCallString
  where  Ext_Photo_CallID = aExt_Photo_CallID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= Ext_Photos_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Ext_Photo_Call');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aExt_Photo_Callid as varchar),  'Ext_Photo_Call',
 'CREATEROW',  aInstanceID);
 insert into   Ext_Photo_Call
 (  Ext_Photo_CallID 
,ParentStructRowID
,TargetPlatform

,TheCallString

 ) values ( aExt_Photo_CallID 
,aParentStructRowID
,aTargetPlatform

,aTheCallString

 ); 
 PERFORM Ext_Photo_Call_SINIT( aCURSESSION,aExt_Photo_Callid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Ext_Photo_Call_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'Ext_Photos';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Ext_Photo_Call_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from Ext_Photo_Call where  Ext_Photo_Callid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Ext_Photo_Call where Ext_Photo_Callid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Ext_Photo_Call_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Ext_Photo_Call_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Ext_Photo_Call set LockUserID =auserID ,LockSessionID =null where Ext_Photo_Callid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Ext_Photo_Call set LockUserID =null,LockSessionID =aCURSESSION  where Ext_Photo_Callid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Ext_Photo_Call_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Ext_Photo_Call set LockUserID =null  where Ext_Photo_Callid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Ext_Photo_Call set LockSessionID =null  where Ext_Photo_Callid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Ext_Photo_Call_parent_T( aCURSESSION,aROWID);
 aParentID:= Ext_Photo_Call_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Ext_Photo_Call set securitystyleid =aStyleID where Ext_Photo_Callid = aRowID;
else 
 update Ext_Photo_Call set securitystyleid =aSecurityStyleID where Ext_Photo_Callid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Ext_Photo_Call_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Ext_Photo_Call where Ext_Photo_Callid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INVF" BlockCode=" create or replace function  INVF_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='INVF'
then
Open aCurs  for select INVF_DEF.INVF_DEFid ID from INVF_DEF where  INVF_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVF_DEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INVF_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'INVF'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select INVF_DEF.INVF_DEFid ID from INVF_DEF where  INVF_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVF_DEF where INVF_DEFid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVF_DEF_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INVF_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'INVF'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select INVF_DEF.INVF_DEFid id from INVF_DEF where  INVF_DEF.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVF_DEF_SINIT( acursession,aid,assid);
 PERFORM INVF_DEF_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  INVF_DEF_BRIEF  (
 aCURSESSION uuid,
 aINVF_DEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVF_DEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVF_DEF where INVF_DEFID=aINVF_DEFID;
if existsCnt &gt;0
 then
  aBRIEF:= INVF_DEF_BRIEF_F(aINVF_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_DELETE /*Данные файла*/ (
 aCURSESSION uuid,
 aINVF_DEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVF_DEF where INVF_DEFID=aINVF_DEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVF_DEF_ISLOCKED( acursession,aINVF_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVF_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVF_DEFid as varchar),   'INVF_DEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVF_DEF' and OwnerRowID=aINVF_DEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVF_DEF 
  where  INVF_DEFID = aINVF_DEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Данные файла*/
 create or replace function  INVF_DEF_SAVE /*Данные файла*/ (
 aCURSESSION uuid,
 aINVF_DEFid uuid,
ainstanceid uuid 
,aThePath
 VARCHAR/* Название файла *//* Название файла */
,aTheHash
 VARCHAR/* MD5 Хэш *//* MD5 Хэш */
,aLoadDate
 timestamp/* Дата загрузки *//* Дата загрузки */
,aTheUser
 uuid/* Оператор *//* Оператор */
,aTypeOfFile
 VARCHAR/* Тип файла *//* Тип файла */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVF_DEF where INVF_DEFID=aINVF_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVF_DEF_ISLOCKED( acursession,aINVF_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVF_DEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVF_DEFid as varchar),  'INVF_DEF',
 'EDITROW',  aInstanceID);
 update  INVF_DEF set ChangeStamp=localtimestamp
,
  ThePath=aThePath
,
  TheHash=aTheHash
,
  LoadDate=aLoadDate
,
  TheUser=aTheUser
,
  TypeOfFile=aTypeOfFile
  where  INVF_DEFID = aINVF_DEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVF_DEF');
    return;
  end if;
select Count(*) into existsCnt from INVF_DEF where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVF_DEF&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVF_DEFid as varchar),  'INVF_DEF',
 'CREATEROW',  aInstanceID);
 insert into   INVF_DEF
 (  INVF_DEFID 
,InstanceID
,ThePath

,TheHash

,LoadDate

,TheUser

,TypeOfFile

 ) values ( aINVF_DEFID 
,aInstanceID
,aThePath

,aTheHash

,aLoadDate

,aTheUser

,aTypeOfFile

 ); 
 PERFORM INVF_DEF_SINIT( aCURSESSION,aINVF_DEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVF_DEF_PARENT_T /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVF_DEF_PARENT_ID /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVF_DEF where  INVF_DEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_ISLOCKED /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVF_DEF where INVF_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_LOCK /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVF_DEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVF_DEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVF_DEF set LockUserID =auserID ,LockSessionID =null where INVF_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVF_DEF set LockUserID =null,LockSessionID =aCURSESSION  where INVF_DEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_HCL /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_UNLOCK /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVF_DEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVF_DEF set LockUserID =null  where INVF_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVF_DEF set LockSessionID =null  where INVF_DEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_SINIT /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVF_DEF_parent_T( aCURSESSION,aROWID);
 aParentID:= INVF_DEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVF_DEF set securitystyleid =aStyleID where INVF_DEFid = aRowID;
else 
 update INVF_DEF set securitystyleid =aSecurityStyleID where INVF_DEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVF_DEF_propagate /*Данные файла*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVF_DEF where INVF_DEFid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSecurity" BlockCode=" create or replace function  MTZSecurity_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZSecurity'
then
Open aCurs  for select MTZSEC_RIGHT.MTZSEC_RIGHTid ID from MTZSEC_RIGHT where  MTZSEC_RIGHT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZSEC_RIGHT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSecurity_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZSecurity'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select MTZSEC_RIGHT.MTZSEC_RIGHTid ID from MTZSEC_RIGHT where  MTZSEC_RIGHT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZSEC_RIGHT where MTZSEC_RIGHTid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZSEC_RIGHT_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSecurity_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZSecurity'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select MTZSEC_RIGHT.MTZSEC_RIGHTid id from MTZSEC_RIGHT where  MTZSEC_RIGHT.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZSEC_RIGHT_SINIT( acursession,aid,assid);
 PERFORM MTZSEC_RIGHT_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  MTZSEC_RIGHT_BRIEF  (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZSEC_RIGHTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZSEC_RIGHT where MTZSEC_RIGHTID=aMTZSEC_RIGHTID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZSEC_RIGHT_BRIEF_F(aMTZSEC_RIGHTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_DELETE /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZSEC_RIGHT where MTZSEC_RIGHTID=aMTZSEC_RIGHTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZSEC_RIGHT_ISLOCKED( acursession,aMTZSEC_RIGHTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZSEC_RIGHT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZSEC_RIGHT' and OwnerRowID=aMTZSEC_RIGHTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZSEC_RIGHT 
  where  MTZSEC_RIGHTID = aMTZSEC_RIGHTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание прав*/
 create or replace function  MTZSEC_RIGHT_SAVE /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aMTZSEC_RIGHTid uuid,
ainstanceid uuid 
,aPiority
 integer/* Приоритет *//* Приоритет */
,aTheGroup
 uuid/* Группа *//* Группа */
,aProtectedItem
 VARCHAR/* Защищаемый элемент *//* Защищаемый элемент */
,aAllow
 INTEGER/* Разрешение *//* Разрешение */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZSEC_RIGHT where MTZSEC_RIGHTID=aMTZSEC_RIGHTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZSEC_RIGHT_ISLOCKED( acursession,aMTZSEC_RIGHTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZSEC_RIGHT');
    return;
  end if;
 -- update row  --
 update  MTZSEC_RIGHT set ChangeStamp=localtimestamp
,
  Piority=aPiority
,
  TheGroup=aTheGroup
,
  ProtectedItem=aProtectedItem
,
  Allow=aAllow
  where  MTZSEC_RIGHTID = aMTZSEC_RIGHTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZSEC_RIGHT');
    return;
  end if;
 insert into   MTZSEC_RIGHT
 (  MTZSEC_RIGHTID 
,InstanceID
,Piority

,TheGroup

,ProtectedItem

,Allow

 ) values ( aMTZSEC_RIGHTID 
,aInstanceID
,aPiority

,aTheGroup

,aProtectedItem

,aAllow

 ); 
 PERFORM MTZSEC_RIGHT_SINIT( aCURSESSION,aMTZSEC_RIGHTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZSEC_RIGHT_PARENT_T /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZSEC_RIGHT_PARENT_ID /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZSEC_RIGHT where  MTZSEC_RIGHTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_ISLOCKED /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZSEC_RIGHT where MTZSEC_RIGHTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_LOCK /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZSEC_RIGHT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZSEC_RIGHT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZSEC_RIGHT set LockUserID =auserID ,LockSessionID =null where MTZSEC_RIGHTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZSEC_RIGHT set LockUserID =null,LockSessionID =aCURSESSION  where MTZSEC_RIGHTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_HCL /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_UNLOCK /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZSEC_RIGHT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZSEC_RIGHT set LockUserID =null  where MTZSEC_RIGHTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZSEC_RIGHT set LockSessionID =null  where MTZSEC_RIGHTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_SINIT /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZSEC_RIGHT_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZSEC_RIGHT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZSEC_RIGHT set securitystyleid =aStyleID where MTZSEC_RIGHTid = aRowID;
else 
 update MTZSEC_RIGHT set securitystyleid =aSecurityStyleID where MTZSEC_RIGHTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZSEC_RIGHT_propagate /*описание прав для каждой группы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZSEC_RIGHT where MTZSEC_RIGHTid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_OS" BlockCode=" create or replace function  INV_OS_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='INV_OS'
then
Open aCurs  for select INVOS_RENT.INVOS_RENTid ID from INVOS_RENT where  INVOS_RENT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_RENT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_HIST.INVOS_HISTid ID from INVOS_HIST where  INVOS_HIST.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_HIST_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_OFFRULE.INVOS_OFFRULEid ID from INVOS_OFFRULE where  INVOS_OFFRULE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_OFFRULE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_SROK.INVOS_SROKid ID from INVOS_SROK where  INVOS_SROK.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_SROK_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_TECH.INVOS_TECHid ID from INVOS_TECH where  INVOS_TECH.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_TECH_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_DRAG.INVOS_DRAGid ID from INVOS_DRAG where  INVOS_DRAG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_DRAG_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_DOCS.INVOS_DOCSid ID from INVOS_DOCS where  INVOS_DOCS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_DOCS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_INV.INVOS_INVid ID from INVOS_INV where  INVOS_INV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_INV_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_LIZING.INVOS_LIZINGid ID from INVOS_LIZING where  INVOS_LIZING.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_LIZING_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CNSRV.INVOS_CNSRVid ID from INVOS_CNSRV where  INVOS_CNSRV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CNSRV_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_INFO.INVOS_INFOid ID from INVOS_INFO where  INVOS_INFO.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_INFO_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_MOD.INVOS_MODid ID from INVOS_MOD where  INVOS_MOD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_MOD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CMNT.INVOS_CMNTid ID from INVOS_CMNT where  INVOS_CMNT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CMNT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CODE.INVOS_CODEid ID from INVOS_CODE where  INVOS_CODE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CODE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_REPAIR.INVOS_REPAIRid ID from INVOS_REPAIR where  INVOS_REPAIR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_REPAIR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVOS_PLACE.INVOS_PLACEid ID from INVOS_PLACE where  INVOS_PLACE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_PLACE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_OS_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'INV_OS'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select INVOS_RENT.INVOS_RENTid ID from INVOS_RENT where  INVOS_RENT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_RENT where INVOS_RENTid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_RENT_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_HIST.INVOS_HISTid ID from INVOS_HIST where  INVOS_HIST.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_HIST where INVOS_HISTid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_HIST_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_OFFRULE.INVOS_OFFRULEid ID from INVOS_OFFRULE where  INVOS_OFFRULE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_OFFRULE where INVOS_OFFRULEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_OFFRULE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_SROK.INVOS_SROKid ID from INVOS_SROK where  INVOS_SROK.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_SROK where INVOS_SROKid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_SROK_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_TECH.INVOS_TECHid ID from INVOS_TECH where  INVOS_TECH.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_TECH where INVOS_TECHid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_TECH_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_DRAG.INVOS_DRAGid ID from INVOS_DRAG where  INVOS_DRAG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_DRAG where INVOS_DRAGid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_DRAG_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_DOCS.INVOS_DOCSid ID from INVOS_DOCS where  INVOS_DOCS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_DOCS where INVOS_DOCSid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_DOCS_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_INV.INVOS_INVid ID from INVOS_INV where  INVOS_INV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_INV where INVOS_INVid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_INV_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_LIZING.INVOS_LIZINGid ID from INVOS_LIZING where  INVOS_LIZING.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_LIZING where INVOS_LIZINGid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_LIZING_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CNSRV.INVOS_CNSRVid ID from INVOS_CNSRV where  INVOS_CNSRV.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_CNSRV where INVOS_CNSRVid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_CNSRV_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_INFO.INVOS_INFOid ID from INVOS_INFO where  INVOS_INFO.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_INFO where INVOS_INFOid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_INFO_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_MOD.INVOS_MODid ID from INVOS_MOD where  INVOS_MOD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_MOD where INVOS_MODid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_MOD_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CMNT.INVOS_CMNTid ID from INVOS_CMNT where  INVOS_CMNT.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_CMNT where INVOS_CMNTid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_CMNT_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_CODE.INVOS_CODEid ID from INVOS_CODE where  INVOS_CODE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_CODE where INVOS_CODEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_CODE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_REPAIR.INVOS_REPAIRid ID from INVOS_REPAIR where  INVOS_REPAIR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_REPAIR where INVOS_REPAIRid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_REPAIR_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVOS_PLACE.INVOS_PLACEid ID from INVOS_PLACE where  INVOS_PLACE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVOS_PLACE where INVOS_PLACEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVOS_PLACE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_OS_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'INV_OS'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select INVOS_RENT.INVOS_RENTid id from INVOS_RENT where  INVOS_RENT.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_RENT_SINIT( acursession,aid,assid);
 PERFORM INVOS_RENT_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_HIST.INVOS_HISTid id from INVOS_HIST where  INVOS_HIST.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_HIST_SINIT( acursession,aid,assid);
 PERFORM INVOS_HIST_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_OFFRULE.INVOS_OFFRULEid id from INVOS_OFFRULE where  INVOS_OFFRULE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_OFFRULE_SINIT( acursession,aid,assid);
 PERFORM INVOS_OFFRULE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_SROK.INVOS_SROKid id from INVOS_SROK where  INVOS_SROK.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_SROK_SINIT( acursession,aid,assid);
 PERFORM INVOS_SROK_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_TECH.INVOS_TECHid id from INVOS_TECH where  INVOS_TECH.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_TECH_SINIT( acursession,aid,assid);
 PERFORM INVOS_TECH_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_DRAG.INVOS_DRAGid id from INVOS_DRAG where  INVOS_DRAG.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_DRAG_SINIT( acursession,aid,assid);
 PERFORM INVOS_DRAG_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_DOCS.INVOS_DOCSid id from INVOS_DOCS where  INVOS_DOCS.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_DOCS_SINIT( acursession,aid,assid);
 PERFORM INVOS_DOCS_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_INV.INVOS_INVid id from INVOS_INV where  INVOS_INV.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_INV_SINIT( acursession,aid,assid);
 PERFORM INVOS_INV_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_LIZING.INVOS_LIZINGid id from INVOS_LIZING where  INVOS_LIZING.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_LIZING_SINIT( acursession,aid,assid);
 PERFORM INVOS_LIZING_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_CNSRV.INVOS_CNSRVid id from INVOS_CNSRV where  INVOS_CNSRV.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CNSRV_SINIT( acursession,aid,assid);
 PERFORM INVOS_CNSRV_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_INFO.INVOS_INFOid id from INVOS_INFO where  INVOS_INFO.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_INFO_SINIT( acursession,aid,assid);
 PERFORM INVOS_INFO_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_MOD.INVOS_MODid id from INVOS_MOD where  INVOS_MOD.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_MOD_SINIT( acursession,aid,assid);
 PERFORM INVOS_MOD_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_CMNT.INVOS_CMNTid id from INVOS_CMNT where  INVOS_CMNT.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CMNT_SINIT( acursession,aid,assid);
 PERFORM INVOS_CMNT_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_CODE.INVOS_CODEid id from INVOS_CODE where  INVOS_CODE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_CODE_SINIT( acursession,aid,assid);
 PERFORM INVOS_CODE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_REPAIR.INVOS_REPAIRid id from INVOS_REPAIR where  INVOS_REPAIR.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_REPAIR_SINIT( acursession,aid,assid);
 PERFORM INVOS_REPAIR_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVOS_PLACE.INVOS_PLACEid id from INVOS_PLACE where  INVOS_PLACE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVOS_PLACE_SINIT( acursession,aid,assid);
 PERFORM INVOS_PLACE_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  INVOS_RENT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_RENTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_RENTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_RENT where INVOS_RENTID=aINVOS_RENTID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_RENT_BRIEF_F(aINVOS_RENTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_DELETE /*Данные об аренде*/ (
 aCURSESSION uuid,
 aINVOS_RENTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_RENT where INVOS_RENTID=aINVOS_RENTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_RENT_ISLOCKED( acursession,aINVOS_RENTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_RENT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_RENTid as varchar),   'INVOS_RENT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_RENT' and OwnerRowID=aINVOS_RENTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_RENT 
  where  INVOS_RENTID = aINVOS_RENTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Аренда*/
 create or replace function  INVOS_RENT_SAVE /*Данные об аренде*/ (
 aCURSESSION uuid,
 aINVOS_RENTid uuid,
ainstanceid uuid 
,aStartDate
 date/* Дата начала аренды *//* Дата начала аренды */
,aEndDate
 date/* Дата завершения аренды *//* Дата завершения аренды */
,aarendator
 uuid/* Арендатор *//* Арендатор */
,aADog
 VARCHAR/* Договор аренды *//* Договор аренды */
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_RENT where INVOS_RENTID=aINVOS_RENTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_RENT_ISLOCKED( acursession,aINVOS_RENTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_RENT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_RENTid as varchar),  'INVOS_RENT',
 'EDITROW',  aInstanceID);
 update  INVOS_RENT set ChangeStamp=localtimestamp
,
  StartDate=aStartDate
,
  EndDate=aEndDate
,
  arendator=aarendator
,
  ADog=aADog
,
  DocNumber=aDocNumber
  where  INVOS_RENTID = aINVOS_RENTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_RENT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_RENTid as varchar),  'INVOS_RENT',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_RENT
 (  INVOS_RENTID 
,InstanceID
,StartDate

,EndDate

,arendator

,ADog

,DocNumber

 ) values ( aINVOS_RENTID 
,aInstanceID
,aStartDate

,aEndDate

,aarendator

,aADog

,aDocNumber

 ); 
 PERFORM INVOS_RENT_SINIT( aCURSESSION,aINVOS_RENTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_RENT_PARENT_T /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_RENT_PARENT_ID /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_RENT where  INVOS_RENTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_ISLOCKED /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_RENT where INVOS_RENTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_LOCK /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_RENT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_RENT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_RENT set LockUserID =auserID ,LockSessionID =null where INVOS_RENTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_RENT set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_RENTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_HCL /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_UNLOCK /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_RENT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_RENT set LockUserID =null  where INVOS_RENTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_RENT set LockSessionID =null  where INVOS_RENTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_SINIT /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_RENT_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_RENT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_RENT set securitystyleid =aStyleID where INVOS_RENTid = aRowID;
else 
 update INVOS_RENT set securitystyleid =aSecurityStyleID where INVOS_RENTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_RENT_propagate /*Данные об аренде*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_RENT where INVOS_RENTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_HIST_BRIEF  (
 aCURSESSION uuid,
 aINVOS_HISTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_HISTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_HIST where INVOS_HISTID=aINVOS_HISTID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_HIST_BRIEF_F(aINVOS_HISTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_DELETE /*Изменения положения*/ (
 aCURSESSION uuid,
 aINVOS_HISTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_HIST where INVOS_HISTID=aINVOS_HISTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_HIST_ISLOCKED( acursession,aINVOS_HISTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_HIST');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_HISTid as varchar),   'INVOS_HIST',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_HIST' and OwnerRowID=aINVOS_HISTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_HIST 
  where  INVOS_HISTID = aINVOS_HISTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Движение*/
 create or replace function  INVOS_HIST_SAVE /*Изменения положения*/ (
 aCURSESSION uuid,
 aINVOS_HISTid uuid,
ainstanceid uuid 
,aUntilDate
 timestamp/* Значение до *//* Значение до */
,aChangedBy
 uuid/* Изменена пользователем *//* Изменена пользователем */
,aMatOtv
 uuid/* Матерально отв. *//* Матерально отв. */
,aComplNumber
 VARCHAR/* Номер комплекта *//* Номер комплекта */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprav
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aTheHouse
 uuid/* Здание *//* Здание */
,aFlow
 VARCHAR/* Этаж *//* Этаж */
,aRoom
 VARCHAR/* Кабинет *//* Кабинет */
,aWorkPlaceNum
 VARCHAR/* Номер рабочего места *//* Номер рабочего места */
,aTheOwner
 uuid/* Владелец *//* Владелец */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_HIST where INVOS_HISTID=aINVOS_HISTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_HIST_ISLOCKED( acursession,aINVOS_HISTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_HIST');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_HISTid as varchar),  'INVOS_HIST',
 'EDITROW',  aInstanceID);
 update  INVOS_HIST set ChangeStamp=localtimestamp
,
  UntilDate=aUntilDate
,
  ChangedBy=aChangedBy
,
  MatOtv=aMatOtv
,
  ComplNumber=aComplNumber
,
  DIrection=aDIrection
,
  Uprav=aUprav
,
  Otdel=aOtdel
,
  TheHouse=aTheHouse
,
  Flow=aFlow
,
  Room=aRoom
,
  WorkPlaceNum=aWorkPlaceNum
,
  TheOwner=aTheOwner
  where  INVOS_HISTID = aINVOS_HISTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_HIST');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_HISTid as varchar),  'INVOS_HIST',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_HIST
 (  INVOS_HISTID 
,InstanceID
,UntilDate

,ChangedBy

,MatOtv

,ComplNumber

,DIrection

,Uprav

,Otdel

,TheHouse

,Flow

,Room

,WorkPlaceNum

,TheOwner

 ) values ( aINVOS_HISTID 
,aInstanceID
,aUntilDate

,aChangedBy

,aMatOtv

,aComplNumber

,aDIrection

,aUprav

,aOtdel

,aTheHouse

,aFlow

,aRoom

,aWorkPlaceNum

,aTheOwner

 ); 
 PERFORM INVOS_HIST_SINIT( aCURSESSION,aINVOS_HISTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_HIST_PARENT_T /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HIST_PARENT_ID /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_HIST where  INVOS_HISTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_ISLOCKED /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_HIST where INVOS_HISTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_LOCK /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_HIST_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_HIST_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_HIST set LockUserID =auserID ,LockSessionID =null where INVOS_HISTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_HIST set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_HISTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_HCL /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_UNLOCK /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_HIST_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_HIST set LockUserID =null  where INVOS_HISTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_HIST set LockSessionID =null  where INVOS_HISTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_SINIT /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_HIST_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_HIST_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_HIST set securitystyleid =aStyleID where INVOS_HISTid = aRowID;
else 
 update INVOS_HIST set securitystyleid =aSecurityStyleID where INVOS_HISTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HIST_propagate /*Изменения положения*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_HIST where INVOS_HISTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_OFFRULE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_OFFRULEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_OFFRULE where INVOS_OFFRULEID=aINVOS_OFFRULEID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_OFFRULE_BRIEF_F(aINVOS_OFFRULEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_DELETE /*Причина списания*/ (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_OFFRULE where INVOS_OFFRULEID=aINVOS_OFFRULEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_OFFRULE_ISLOCKED( acursession,aINVOS_OFFRULEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_OFFRULE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_OFFRULEid as varchar),   'INVOS_OFFRULE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_OFFRULE' and OwnerRowID=aINVOS_OFFRULEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_OFFRULE 
  where  INVOS_OFFRULEID = aINVOS_OFFRULEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Причина списания*/
 create or replace function  INVOS_OFFRULE_SAVE /*Причина списания*/ (
 aCURSESSION uuid,
 aINVOS_OFFRULEid uuid,
ainstanceid uuid 
,aINFO
 VARCHAR/* Причина списания *//* Причина списания */
,aDocNumber
 VARCHAR/* № Документа *//* № Документа */
,aDocDate
 date/* Дата документа *//* Дата документа */
,aTheComment
 TEXT/* Примечание *//* Примечание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_OFFRULE where INVOS_OFFRULEID=aINVOS_OFFRULEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_OFFRULE_ISLOCKED( acursession,aINVOS_OFFRULEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_OFFRULE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_OFFRULEid as varchar),  'INVOS_OFFRULE',
 'EDITROW',  aInstanceID);
 update  INVOS_OFFRULE set ChangeStamp=localtimestamp
,
  INFO=aINFO
,
  DocNumber=aDocNumber
,
  DocDate=aDocDate
,
  TheComment=aTheComment
  where  INVOS_OFFRULEID = aINVOS_OFFRULEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_OFFRULE');
    return;
  end if;
select Count(*) into existsCnt from INVOS_OFFRULE where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_OFFRULE&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_OFFRULEid as varchar),  'INVOS_OFFRULE',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_OFFRULE
 (  INVOS_OFFRULEID 
,InstanceID
,INFO

,DocNumber

,DocDate

,TheComment

 ) values ( aINVOS_OFFRULEID 
,aInstanceID
,aINFO

,aDocNumber

,aDocDate

,aTheComment

 ); 
 PERFORM INVOS_OFFRULE_SINIT( aCURSESSION,aINVOS_OFFRULEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_OFFRULE_PARENT_T /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_OFFRULE_PARENT_ID /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_OFFRULE where  INVOS_OFFRULEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_ISLOCKED /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_OFFRULE where INVOS_OFFRULEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_LOCK /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_OFFRULE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_OFFRULE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_OFFRULE set LockUserID =auserID ,LockSessionID =null where INVOS_OFFRULEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_OFFRULE set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_OFFRULEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_HCL /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_UNLOCK /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_OFFRULE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_OFFRULE set LockUserID =null  where INVOS_OFFRULEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_OFFRULE set LockSessionID =null  where INVOS_OFFRULEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_SINIT /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_OFFRULE_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_OFFRULE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_OFFRULE set securitystyleid =aStyleID where INVOS_OFFRULEid = aRowID;
else 
 update INVOS_OFFRULE set securitystyleid =aSecurityStyleID where INVOS_OFFRULEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_OFFRULE_propagate /*Причина списания*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_OFFRULE where INVOS_OFFRULEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_SROK_BRIEF  (
 aCURSESSION uuid,
 aINVOS_SROKid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_SROKid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_SROK where INVOS_SROKID=aINVOS_SROKID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_SROK_BRIEF_F(aINVOS_SROKid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_DELETE /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aINVOS_SROKid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_SROK where INVOS_SROKID=aINVOS_SROKID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_SROK_ISLOCKED( acursession,aINVOS_SROKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_SROK');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_SROKid as varchar),   'INVOS_SROK',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_SROK' and OwnerRowID=aINVOS_SROKid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_SROK 
  where  INVOS_SROKID = aINVOS_SROKID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Пересчет сроков ПИ*/
 create or replace function  INVOS_SROK_SAVE /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aINVOS_SROKid uuid,
ainstanceid uuid 
,aRecalcDate
 date/* Дата следующего пересчета срока *//* Дата следующего пересчета срока */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_SROK where INVOS_SROKID=aINVOS_SROKID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_SROK_ISLOCKED( acursession,aINVOS_SROKid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_SROK');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_SROKid as varchar),  'INVOS_SROK',
 'EDITROW',  aInstanceID);
 update  INVOS_SROK set ChangeStamp=localtimestamp
,
  RecalcDate=aRecalcDate
  where  INVOS_SROKID = aINVOS_SROKID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_SROK');
    return;
  end if;
select Count(*) into existsCnt from INVOS_SROK where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_SROK&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_SROKid as varchar),  'INVOS_SROK',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_SROK
 (  INVOS_SROKID 
,InstanceID
,RecalcDate

 ) values ( aINVOS_SROKID 
,aInstanceID
,aRecalcDate

 ); 
 PERFORM INVOS_SROK_SINIT( aCURSESSION,aINVOS_SROKid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_SROK_PARENT_T /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_SROK_PARENT_ID /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_SROK where  INVOS_SROKid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_ISLOCKED /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_SROK where INVOS_SROKid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_LOCK /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_SROK_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_SROK_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_SROK set LockUserID =auserID ,LockSessionID =null where INVOS_SROKid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_SROK set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_SROKid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_HCL /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_UNLOCK /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_SROK_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_SROK set LockUserID =null  where INVOS_SROKid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_SROK set LockSessionID =null  where INVOS_SROKid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_SINIT /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_SROK_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_SROK_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_SROK set securitystyleid =aStyleID where INVOS_SROKid = aRowID;
else 
 update INVOS_SROK set securitystyleid =aSecurityStyleID where INVOS_SROKid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_SROK_propagate /*Пересчет сроков ПИ*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_SROK where INVOS_SROKid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_TECH_BRIEF  (
 aCURSESSION uuid,
 aINVOS_TECHid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_TECHid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_TECH where INVOS_TECHID=aINVOS_TECHID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_TECH_BRIEF_F(aINVOS_TECHid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_DELETE /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aINVOS_TECHid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_TECH where INVOS_TECHID=aINVOS_TECHID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_TECH_ISLOCKED( acursession,aINVOS_TECHid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_TECH');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select INVOS_WINSOFT.INVOS_WINSOFTid ID from INVOS_WINSOFT where  INVOS_WINSOFT.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_WINSOFT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INVOS_COMP.INVOS_COMPid ID from INVOS_COMP where  INVOS_COMP.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_COMP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INVOS_HARD.INVOS_HARDid ID from INVOS_HARD where  INVOS_HARD.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_HARD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INVOS_CURCFG.INVOS_CURCFGid ID from INVOS_CURCFG where  INVOS_CURCFG.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_CURCFG_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INVOS_CFGCH.INVOS_CFGCHid ID from INVOS_CFGCH where  INVOS_CFGCH.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_CFGCH_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select INVOS_DEVICES.INVOS_DEVICESid ID from INVOS_DEVICES where  INVOS_DEVICES.ParentStructRowID = aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_DEVICES_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_TECHid as varchar),   'INVOS_TECH',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_TECH' and OwnerRowID=aINVOS_TECHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_TECH 
  where  INVOS_TECHID = aINVOS_TECHID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Техническая информация*/
 create or replace function  INVOS_TECH_SAVE /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aINVOS_TECHid uuid,
ainstanceid uuid 
,aMAC_Addr
 VARCHAR/* MAC_Addr *//* MAC_Addr */
,aComputer_Name
 VARCHAR/* Computer_Name *//* Computer_Name */
,aIP_Addr
 VARCHAR/* IP_Addr *//* IP_Addr */
,aCurrent_User_Name
 VARCHAR/* Current_User_Name *//* Current_User_Name */
,aSystem
 VARCHAR/* System *//* System */
,aRecord_Date
 VARCHAR/* Record_Date *//* Record_Date */
,aParam_0
 VARCHAR/* Param_0 *//* Param_0 */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_TECH where INVOS_TECHID=aINVOS_TECHID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_TECH_ISLOCKED( acursession,aINVOS_TECHid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_TECH');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_TECHid as varchar),  'INVOS_TECH',
 'EDITROW',  aInstanceID);
 update  INVOS_TECH set ChangeStamp=localtimestamp
,
  MAC_Addr=aMAC_Addr
,
  Computer_Name=aComputer_Name
,
  IP_Addr=aIP_Addr
,
  Current_User_Name=aCurrent_User_Name
,
  System=aSystem
,
  Record_Date=aRecord_Date
,
  Param_0=aParam_0
  where  INVOS_TECHID = aINVOS_TECHID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_TECH');
    return;
  end if;
select Count(*) into existsCnt from INVOS_TECH where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_TECH&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_TECHid as varchar),  'INVOS_TECH',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_TECH
 (  INVOS_TECHID 
,InstanceID
,MAC_Addr

,Computer_Name

,IP_Addr

,Current_User_Name

,System

,Record_Date

,Param_0

 ) values ( aINVOS_TECHID 
,aInstanceID
,aMAC_Addr

,aComputer_Name

,aIP_Addr

,aCurrent_User_Name

,aSystem

,aRecord_Date

,aParam_0

 ); 
 PERFORM INVOS_TECH_SINIT( aCURSESSION,aINVOS_TECHid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_TECH_PARENT_T /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_TECH_PARENT_ID /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_TECH where  INVOS_TECHid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_ISLOCKED /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_TECH where INVOS_TECHid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_LOCK /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_TECH_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_TECH_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_TECH set LockUserID =auserID ,LockSessionID =null where INVOS_TECHid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_TECH set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_TECHid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_HCL /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select INVOS_WINSOFT.INVOS_WINSOFTid ID from INVOS_WINSOFT where  INVOS_WINSOFT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_WINSOFT where INVOS_WINSOFTid=row_INVOS_WINSOFT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_WINSOFT_HCL (acursession,row_INVOS_WINSOFT.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INVOS_COMP.INVOS_COMPid ID from INVOS_COMP where  INVOS_COMP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_COMP where INVOS_COMPid=row_INVOS_COMP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_COMP_HCL (acursession,row_INVOS_COMP.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INVOS_HARD.INVOS_HARDid ID from INVOS_HARD where  INVOS_HARD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_HARD where INVOS_HARDid=row_INVOS_HARD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_HARD_HCL (acursession,row_INVOS_HARD.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INVOS_CURCFG.INVOS_CURCFGid ID from INVOS_CURCFG where  INVOS_CURCFG.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_CURCFG where INVOS_CURCFGid=row_INVOS_CURCFG.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_CURCFG_HCL (acursession,row_INVOS_CURCFG.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INVOS_CFGCH.INVOS_CFGCHid ID from INVOS_CFGCH where  INVOS_CFGCH.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_CFGCH where INVOS_CFGCHid=row_INVOS_CFGCH.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_CFGCH_HCL (acursession,row_INVOS_CFGCH.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select INVOS_DEVICES.INVOS_DEVICESid ID from INVOS_DEVICES where  INVOS_DEVICES.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INVOS_DEVICES where INVOS_DEVICESid=row_INVOS_DEVICES.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= INVOS_DEVICES_HCL (acursession,row_INVOS_DEVICES.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_UNLOCK /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_TECH_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_TECH set LockUserID =null  where INVOS_TECHid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_TECH set LockSessionID =null  where INVOS_TECHid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_SINIT /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_TECH_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_TECH_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_TECH set securitystyleid =aStyleID where INVOS_TECHid = aRowID;
else 
 update INVOS_TECH set securitystyleid =aSecurityStyleID where INVOS_TECHid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_TECH_propagate /*Техническая информация ( описание вычислительной техники)*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_TECH where INVOS_TECHid=aRowid;
open aCurs for select INVOS_WINSOFT.INVOS_WINSOFTid ID from INVOS_WINSOFT where  INVOS_WINSOFT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_WINSOFT_SINIT( acursession,aid,assid);
 PERFORM  INVOS_WINSOFT_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INVOS_COMP.INVOS_COMPid ID from INVOS_COMP where  INVOS_COMP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_COMP_SINIT( acursession,aid,assid);
 PERFORM  INVOS_COMP_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INVOS_HARD.INVOS_HARDid ID from INVOS_HARD where  INVOS_HARD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_HARD_SINIT( acursession,aid,assid);
 PERFORM  INVOS_HARD_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INVOS_CURCFG.INVOS_CURCFGid ID from INVOS_CURCFG where  INVOS_CURCFG.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_CURCFG_SINIT( acursession,aid,assid);
 PERFORM  INVOS_CURCFG_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INVOS_CFGCH.INVOS_CFGCHid ID from INVOS_CFGCH where  INVOS_CFGCH.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_CFGCH_SINIT( acursession,aid,assid);
 PERFORM  INVOS_CFGCH_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select INVOS_DEVICES.INVOS_DEVICESid ID from INVOS_DEVICES where  INVOS_DEVICES.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INVOS_DEVICES_SINIT( acursession,aid,assid);
 PERFORM  INVOS_DEVICES_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_WINSOFT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_WINSOFTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_WINSOFT where INVOS_WINSOFTID=aINVOS_WINSOFTID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_WINSOFT_BRIEF_F(aINVOS_WINSOFTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_WINSOFT where INVOS_WINSOFTID=aINVOS_WINSOFTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_WINSOFT_ISLOCKED( acursession,aINVOS_WINSOFTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_WINSOFT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_WINSOFTid as varchar),   'INVOS_WINSOFT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_WINSOFT' and OwnerRowID=aINVOS_WINSOFTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_WINSOFT 
  where  INVOS_WINSOFTID = aINVOS_WINSOFTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Windows soft*/
 create or replace function  INVOS_WINSOFT_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_WINSOFTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_WINSOFT where INVOS_WINSOFTID=aINVOS_WINSOFTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_WINSOFT_ISLOCKED( acursession,aINVOS_WINSOFTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_WINSOFT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_WINSOFTid as varchar),  'INVOS_WINSOFT',
 'EDITROW',  aInstanceID);
 update  INVOS_WINSOFT set ChangeStamp=localtimestamp
,
  Name=aName
,
  ParamValue=aParamValue
  where  INVOS_WINSOFTID = aINVOS_WINSOFTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_WINSOFT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_WINSOFTid as varchar),  'INVOS_WINSOFT',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_WINSOFT
 (  INVOS_WINSOFTID 
,ParentStructRowID
,Name

,ParamValue

 ) values ( aINVOS_WINSOFTID 
,aParentStructRowID
,aName

,aParamValue

 ); 
 PERFORM INVOS_WINSOFT_SINIT( aCURSESSION,aINVOS_WINSOFTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_WINSOFT_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_WINSOFT_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_WINSOFT where  INVOS_WINSOFTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_WINSOFT where INVOS_WINSOFTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_WINSOFT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_WINSOFT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_WINSOFT set LockUserID =auserID ,LockSessionID =null where INVOS_WINSOFTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_WINSOFT set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_WINSOFTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_WINSOFT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_WINSOFT set LockUserID =null  where INVOS_WINSOFTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_WINSOFT set LockSessionID =null  where INVOS_WINSOFTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_WINSOFT_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_WINSOFT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_WINSOFT set securitystyleid =aStyleID where INVOS_WINSOFTid = aRowID;
else 
 update INVOS_WINSOFT set securitystyleid =aSecurityStyleID where INVOS_WINSOFTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_WINSOFT_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_WINSOFT where INVOS_WINSOFTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_COMP_BRIEF  (
 aCURSESSION uuid,
 aINVOS_COMPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_COMPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_COMP where INVOS_COMPID=aINVOS_COMPID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_COMP_BRIEF_F(aINVOS_COMPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_COMPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_COMP where INVOS_COMPID=aINVOS_COMPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_COMP_ISLOCKED( acursession,aINVOS_COMPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_COMP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_COMPid as varchar),   'INVOS_COMP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_COMP' and OwnerRowID=aINVOS_COMPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_COMP 
  where  INVOS_COMPID = aINVOS_COMPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Computer*/
 create or replace function  INVOS_COMP_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_COMPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_COMP where INVOS_COMPID=aINVOS_COMPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_COMP_ISLOCKED( acursession,aINVOS_COMPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_COMP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_COMPid as varchar),  'INVOS_COMP',
 'EDITROW',  aInstanceID);
 update  INVOS_COMP set ChangeStamp=localtimestamp
,
  Name=aName
,
  ParamValue=aParamValue
  where  INVOS_COMPID = aINVOS_COMPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_COMP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_COMPid as varchar),  'INVOS_COMP',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_COMP
 (  INVOS_COMPID 
,ParentStructRowID
,Name

,ParamValue

 ) values ( aINVOS_COMPID 
,aParentStructRowID
,aName

,aParamValue

 ); 
 PERFORM INVOS_COMP_SINIT( aCURSESSION,aINVOS_COMPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_COMP_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_COMP_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_COMP where  INVOS_COMPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_COMP where INVOS_COMPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_COMP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_COMP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_COMP set LockUserID =auserID ,LockSessionID =null where INVOS_COMPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_COMP set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_COMPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_COMP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_COMP set LockUserID =null  where INVOS_COMPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_COMP set LockSessionID =null  where INVOS_COMPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_COMP_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_COMP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_COMP set securitystyleid =aStyleID where INVOS_COMPid = aRowID;
else 
 update INVOS_COMP set securitystyleid =aSecurityStyleID where INVOS_COMPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_COMP_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_COMP where INVOS_COMPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_HARD_BRIEF  (
 aCURSESSION uuid,
 aINVOS_HARDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_HARDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_HARD where INVOS_HARDID=aINVOS_HARDID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_HARD_BRIEF_F(aINVOS_HARDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_HARDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_HARD where INVOS_HARDID=aINVOS_HARDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_HARD_ISLOCKED( acursession,aINVOS_HARDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_HARD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_HARDid as varchar),   'INVOS_HARD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_HARD' and OwnerRowID=aINVOS_HARDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_HARD 
  where  INVOS_HARDID = aINVOS_HARDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Hardware*/
 create or replace function  INVOS_HARD_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_HARDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_HARD where INVOS_HARDID=aINVOS_HARDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_HARD_ISLOCKED( acursession,aINVOS_HARDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_HARD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_HARDid as varchar),  'INVOS_HARD',
 'EDITROW',  aInstanceID);
 update  INVOS_HARD set ChangeStamp=localtimestamp
,
  Name=aName
,
  ParamValue=aParamValue
  where  INVOS_HARDID = aINVOS_HARDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_HARD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_HARDid as varchar),  'INVOS_HARD',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_HARD
 (  INVOS_HARDID 
,ParentStructRowID
,Name

,ParamValue

 ) values ( aINVOS_HARDID 
,aParentStructRowID
,aName

,aParamValue

 ); 
 PERFORM INVOS_HARD_SINIT( aCURSESSION,aINVOS_HARDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_HARD_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_HARD_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_HARD where  INVOS_HARDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_HARD where INVOS_HARDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_HARD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_HARD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_HARD set LockUserID =auserID ,LockSessionID =null where INVOS_HARDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_HARD set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_HARDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_HARD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_HARD set LockUserID =null  where INVOS_HARDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_HARD set LockSessionID =null  where INVOS_HARDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_HARD_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_HARD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_HARD set securitystyleid =aStyleID where INVOS_HARDid = aRowID;
else 
 update INVOS_HARD set securitystyleid =aSecurityStyleID where INVOS_HARDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_HARD_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_HARD where INVOS_HARDid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_CURCFG_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_CURCFGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_CURCFG where INVOS_CURCFGID=aINVOS_CURCFGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_CURCFG_BRIEF_F(aINVOS_CURCFGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_CURCFG where INVOS_CURCFGID=aINVOS_CURCFGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_CURCFG_ISLOCKED( acursession,aINVOS_CURCFGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_CURCFG');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_CURCFGid as varchar),   'INVOS_CURCFG',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_CURCFG' and OwnerRowID=aINVOS_CURCFGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_CURCFG 
  where  INVOS_CURCFGID = aINVOS_CURCFGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Current Config*/
 create or replace function  INVOS_CURCFG_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_CURCFGid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_CURCFG where INVOS_CURCFGID=aINVOS_CURCFGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_CURCFG_ISLOCKED( acursession,aINVOS_CURCFGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CURCFG');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_CURCFGid as varchar),  'INVOS_CURCFG',
 'EDITROW',  aInstanceID);
 update  INVOS_CURCFG set ChangeStamp=localtimestamp
,
  Name=aName
,
  ParamValue=aParamValue
  where  INVOS_CURCFGID = aINVOS_CURCFGID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CURCFG');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_CURCFGid as varchar),  'INVOS_CURCFG',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_CURCFG
 (  INVOS_CURCFGID 
,ParentStructRowID
,Name

,ParamValue

 ) values ( aINVOS_CURCFGID 
,aParentStructRowID
,aName

,aParamValue

 ); 
 PERFORM INVOS_CURCFG_SINIT( aCURSESSION,aINVOS_CURCFGid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_CURCFG_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CURCFG_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_CURCFG where  INVOS_CURCFGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_CURCFG where INVOS_CURCFGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CURCFG_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_CURCFG_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_CURCFG set LockUserID =auserID ,LockSessionID =null where INVOS_CURCFGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_CURCFG set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_CURCFGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CURCFG_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_CURCFG set LockUserID =null  where INVOS_CURCFGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_CURCFG set LockSessionID =null  where INVOS_CURCFGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_CURCFG_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_CURCFG_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_CURCFG set securitystyleid =aStyleID where INVOS_CURCFGid = aRowID;
else 
 update INVOS_CURCFG set securitystyleid =aSecurityStyleID where INVOS_CURCFGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CURCFG_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_CURCFG where INVOS_CURCFGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_CFGCH_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_CFGCHid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_CFGCH where INVOS_CFGCHID=aINVOS_CFGCHID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_CFGCH_BRIEF_F(aINVOS_CFGCHid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_CFGCH where INVOS_CFGCHID=aINVOS_CFGCHID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_CFGCH_ISLOCKED( acursession,aINVOS_CFGCHid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_CFGCH');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_CFGCHid as varchar),   'INVOS_CFGCH',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_CFGCH' and OwnerRowID=aINVOS_CFGCHid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_CFGCH 
  where  INVOS_CFGCHID = aINVOS_CFGCHID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Config changes*/
 create or replace function  INVOS_CFGCH_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_CFGCHid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aChDate
 timestamp/* Date *//* Date */
,aChNum
 integer/* Change number *//* Change number */
,aTheValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_CFGCH where INVOS_CFGCHID=aINVOS_CFGCHID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_CFGCH_ISLOCKED( acursession,aINVOS_CFGCHid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CFGCH');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_CFGCHid as varchar),  'INVOS_CFGCH',
 'EDITROW',  aInstanceID);
 update  INVOS_CFGCH set ChangeStamp=localtimestamp
,
  ChDate=aChDate
,
  ChNum=aChNum
,
  TheValue=aTheValue
  where  INVOS_CFGCHID = aINVOS_CFGCHID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CFGCH');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_CFGCHid as varchar),  'INVOS_CFGCH',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_CFGCH
 (  INVOS_CFGCHID 
,ParentStructRowID
,ChDate

,ChNum

,TheValue

 ) values ( aINVOS_CFGCHID 
,aParentStructRowID
,aChDate

,aChNum

,aTheValue

 ); 
 PERFORM INVOS_CFGCH_SINIT( aCURSESSION,aINVOS_CFGCHid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_CFGCH_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CFGCH_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_CFGCH where  INVOS_CFGCHid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_CFGCH where INVOS_CFGCHid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CFGCH_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_CFGCH_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_CFGCH set LockUserID =auserID ,LockSessionID =null where INVOS_CFGCHid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_CFGCH set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_CFGCHid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CFGCH_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_CFGCH set LockUserID =null  where INVOS_CFGCHid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_CFGCH set LockSessionID =null  where INVOS_CFGCHid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_CFGCH_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_CFGCH_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_CFGCH set securitystyleid =aStyleID where INVOS_CFGCHid = aRowID;
else 
 update INVOS_CFGCH set securitystyleid =aSecurityStyleID where INVOS_CFGCHid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CFGCH_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_CFGCH where INVOS_CFGCHid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_DEVICES_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_DEVICESid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_DEVICES where INVOS_DEVICESID=aINVOS_DEVICESID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_DEVICES_BRIEF_F(aINVOS_DEVICESid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_DELETE /*Windows Devices*/ (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_DEVICES where INVOS_DEVICESID=aINVOS_DEVICESID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_DEVICES_ISLOCKED( acursession,aINVOS_DEVICESid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_DEVICES');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_DEVICESid as varchar),   'INVOS_DEVICES',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_DEVICES' and OwnerRowID=aINVOS_DEVICESid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_DEVICES 
  where  INVOS_DEVICESID = aINVOS_DEVICESID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Windows Devices*/
 create or replace function  INVOS_DEVICES_SAVE /*Windows Devices*/ (
 aCURSESSION uuid,
 aINVOS_DEVICESid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Name *//* Name */
,aParamValue
 TEXT/* Value *//* Value */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_DEVICES where INVOS_DEVICESID=aINVOS_DEVICESID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_DEVICES_ISLOCKED( acursession,aINVOS_DEVICESid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DEVICES');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_DEVICESid as varchar),  'INVOS_DEVICES',
 'EDITROW',  aInstanceID);
 update  INVOS_DEVICES set ChangeStamp=localtimestamp
,
  Name=aName
,
  ParamValue=aParamValue
  where  INVOS_DEVICESID = aINVOS_DEVICESID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= INVOS_TECH_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DEVICES');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_DEVICESid as varchar),  'INVOS_DEVICES',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_DEVICES
 (  INVOS_DEVICESID 
,ParentStructRowID
,Name

,ParamValue

 ) values ( aINVOS_DEVICESID 
,aParentStructRowID
,aName

,aParamValue

 ); 
 PERFORM INVOS_DEVICES_SINIT( aCURSESSION,aINVOS_DEVICESid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_DEVICES_PARENT_T /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INVOS_TECH';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DEVICES_PARENT_ID /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from INVOS_DEVICES where  INVOS_DEVICESid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_ISLOCKED /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_DEVICES where INVOS_DEVICESid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_LOCK /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DEVICES_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_DEVICES_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_DEVICES set LockUserID =auserID ,LockSessionID =null where INVOS_DEVICESid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_DEVICES set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_DEVICESid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_HCL /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_UNLOCK /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DEVICES_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_DEVICES set LockUserID =null  where INVOS_DEVICESid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_DEVICES set LockSessionID =null  where INVOS_DEVICESid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_SINIT /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_DEVICES_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_DEVICES_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_DEVICES set securitystyleid =aStyleID where INVOS_DEVICESid = aRowID;
else 
 update INVOS_DEVICES set securitystyleid =aSecurityStyleID where INVOS_DEVICESid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DEVICES_propagate /*Windows Devices*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_DEVICES where INVOS_DEVICESid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_DRAG_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_DRAGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_DRAG where INVOS_DRAGID=aINVOS_DRAGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_DRAG_BRIEF_F(aINVOS_DRAGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_DRAG where INVOS_DRAGID=aINVOS_DRAGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_DRAG_ISLOCKED( acursession,aINVOS_DRAGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_DRAG');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_DRAGid as varchar),   'INVOS_DRAG',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_DRAG' and OwnerRowID=aINVOS_DRAGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_DRAG 
  where  INVOS_DRAGID = aINVOS_DRAGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Содержание драг. металов*/
 create or replace function  INVOS_DRAG_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_DRAGid uuid,
ainstanceid uuid 
,aDragMet
 uuid/* Драг. металл *//* Драг. металл */
,aQ
 float/* Содержание *//* Содержание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_DRAG where INVOS_DRAGID=aINVOS_DRAGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_DRAG_ISLOCKED( acursession,aINVOS_DRAGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DRAG');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_DRAGid as varchar),  'INVOS_DRAG',
 'EDITROW',  aInstanceID);
 update  INVOS_DRAG set ChangeStamp=localtimestamp
,
  DragMet=aDragMet
,
  Q=aQ
  where  INVOS_DRAGID = aINVOS_DRAGID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DRAG');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_DRAGid as varchar),  'INVOS_DRAG',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_DRAG
 (  INVOS_DRAGID 
,InstanceID
,DragMet

,Q

 ) values ( aINVOS_DRAGID 
,aInstanceID
,aDragMet

,aQ

 ); 
 PERFORM INVOS_DRAG_SINIT( aCURSESSION,aINVOS_DRAGid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_DRAG_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DRAG_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_DRAG where  INVOS_DRAGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_DRAG where INVOS_DRAGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DRAG_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_DRAG_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_DRAG set LockUserID =auserID ,LockSessionID =null where INVOS_DRAGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_DRAG set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_DRAGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DRAG_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_DRAG set LockUserID =null  where INVOS_DRAGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_DRAG set LockSessionID =null  where INVOS_DRAGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_DRAG_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_DRAG_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_DRAG set securitystyleid =aStyleID where INVOS_DRAGid = aRowID;
else 
 update INVOS_DRAG set securitystyleid =aSecurityStyleID where INVOS_DRAGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DRAG_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_DRAG where INVOS_DRAGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_DOCS_BRIEF  (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_DOCSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_DOCS where INVOS_DOCSID=aINVOS_DOCSID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_DOCS_BRIEF_F(aINVOS_DOCSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_DELETE /**/ (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_DOCS where INVOS_DOCSID=aINVOS_DOCSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_DOCS_ISLOCKED( acursession,aINVOS_DOCSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_DOCS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_DOCSid as varchar),   'INVOS_DOCS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_DOCS' and OwnerRowID=aINVOS_DOCSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_DOCS 
  where  INVOS_DOCSID = aINVOS_DOCSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Документы*/
 create or replace function  INVOS_DOCS_SAVE /**/ (
 aCURSESSION uuid,
 aINVOS_DOCSid uuid,
ainstanceid uuid 
,aInOrderNum
 VARCHAR/* Номер приходного ордера *//* Номер приходного ордера */
,aNaklNum
 VARCHAR/* Номер накладной *//* Номер накладной */
,aContragent
 uuid/* Контрагент *//* Контрагент */
,aDogNum
 VARCHAR/* Номер договора *//* Номер договора */
,aAccNum
 VARCHAR/* Номер счета *//* Номер счета */
,aAccFNum
 VARCHAR/* Номер счета фактуры *//* Номер счета фактуры */
,aActivateNum
 VARCHAR/* Номер ввода в эксплуатацию *//* Номер ввода в эксплуатацию */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_DOCS where INVOS_DOCSID=aINVOS_DOCSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_DOCS_ISLOCKED( acursession,aINVOS_DOCSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DOCS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_DOCSid as varchar),  'INVOS_DOCS',
 'EDITROW',  aInstanceID);
 update  INVOS_DOCS set ChangeStamp=localtimestamp
,
  InOrderNum=aInOrderNum
,
  NaklNum=aNaklNum
,
  Contragent=aContragent
,
  DogNum=aDogNum
,
  AccNum=aAccNum
,
  AccFNum=aAccFNum
,
  ActivateNum=aActivateNum
  where  INVOS_DOCSID = aINVOS_DOCSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_DOCS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_DOCSid as varchar),  'INVOS_DOCS',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_DOCS
 (  INVOS_DOCSID 
,InstanceID
,InOrderNum

,NaklNum

,Contragent

,DogNum

,AccNum

,AccFNum

,ActivateNum

 ) values ( aINVOS_DOCSID 
,aInstanceID
,aInOrderNum

,aNaklNum

,aContragent

,aDogNum

,aAccNum

,aAccFNum

,aActivateNum

 ); 
 PERFORM INVOS_DOCS_SINIT( aCURSESSION,aINVOS_DOCSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_DOCS_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_DOCS_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_DOCS where  INVOS_DOCSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_DOCS where INVOS_DOCSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DOCS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_DOCS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_DOCS set LockUserID =auserID ,LockSessionID =null where INVOS_DOCSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_DOCS set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_DOCSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_DOCS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_DOCS set LockUserID =null  where INVOS_DOCSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_DOCS set LockSessionID =null  where INVOS_DOCSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_DOCS_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_DOCS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_DOCS set securitystyleid =aStyleID where INVOS_DOCSid = aRowID;
else 
 update INVOS_DOCS set securitystyleid =aSecurityStyleID where INVOS_DOCSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_DOCS_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_DOCS where INVOS_DOCSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_INV_BRIEF  (
 aCURSESSION uuid,
 aINVOS_INVid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_INVid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_INV where INVOS_INVID=aINVOS_INVID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_INV_BRIEF_F(aINVOS_INVid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_DELETE /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aINVOS_INVid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_INV where INVOS_INVID=aINVOS_INVID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_INV_ISLOCKED( acursession,aINVOS_INVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_INV');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_INVid as varchar),   'INVOS_INV',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_INV' and OwnerRowID=aINVOS_INVid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_INV 
  where  INVOS_INVID = aINVOS_INVID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отметки об инвентаризации*/
 create or replace function  INVOS_INV_SAVE /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aINVOS_INVid uuid,
ainstanceid uuid 
,aInventory
 uuid/* Инвентаризация *//* Инвентаризация */
,aInvDate
 timestamp/* Дата инвентаризации *//* Дата инвентаризации */
,aOSStatus
 uuid/* Состояние *//* Состояние */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_INV where INVOS_INVID=aINVOS_INVID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_INV_ISLOCKED( acursession,aINVOS_INVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_INV');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_INVid as varchar),  'INVOS_INV',
 'EDITROW',  aInstanceID);
 update  INVOS_INV set ChangeStamp=localtimestamp
,
  Inventory=aInventory
,
  InvDate=aInvDate
,
  OSStatus=aOSStatus
  where  INVOS_INVID = aINVOS_INVID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_INV');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_INVid as varchar),  'INVOS_INV',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_INV
 (  INVOS_INVID 
,InstanceID
,Inventory

,InvDate

,OSStatus

 ) values ( aINVOS_INVID 
,aInstanceID
,aInventory

,aInvDate

,aOSStatus

 ); 
 PERFORM INVOS_INV_SINIT( aCURSESSION,aINVOS_INVid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_INV_PARENT_T /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INV_PARENT_ID /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_INV where  INVOS_INVid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_ISLOCKED /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_INV where INVOS_INVid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_LOCK /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_INV_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_INV_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_INV set LockUserID =auserID ,LockSessionID =null where INVOS_INVid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_INV set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_INVid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_HCL /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_UNLOCK /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_INV_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_INV set LockUserID =null  where INVOS_INVid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_INV set LockSessionID =null  where INVOS_INVid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_SINIT /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_INV_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_INV_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_INV set securitystyleid =aStyleID where INVOS_INVid = aRowID;
else 
 update INVOS_INV set securitystyleid =aSecurityStyleID where INVOS_INVid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INV_propagate /*Отметки об инвентаризации*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_INV where INVOS_INVid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_LIZING_BRIEF  (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_LIZINGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_LIZING where INVOS_LIZINGID=aINVOS_LIZINGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_LIZING_BRIEF_F(aINVOS_LIZINGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_DELETE /*Лизинг*/ (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_LIZING where INVOS_LIZINGID=aINVOS_LIZINGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_LIZING_ISLOCKED( acursession,aINVOS_LIZINGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_LIZING');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_LIZINGid as varchar),   'INVOS_LIZING',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_LIZING' and OwnerRowID=aINVOS_LIZINGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_LIZING 
  where  INVOS_LIZINGID = aINVOS_LIZINGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Лизинг*/
 create or replace function  INVOS_LIZING_SAVE /*Лизинг*/ (
 aCURSESSION uuid,
 aINVOS_LIZINGid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер договора *//* Номер договора */
,aTheDate
 date/* Дата  передачи *//* Дата  передачи */
,aTheAgent
 uuid/* Контрагент *//* Контрагент */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_LIZING where INVOS_LIZINGID=aINVOS_LIZINGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_LIZING_ISLOCKED( acursession,aINVOS_LIZINGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_LIZING');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_LIZINGid as varchar),  'INVOS_LIZING',
 'EDITROW',  aInstanceID);
 update  INVOS_LIZING set ChangeStamp=localtimestamp
,
  DocNumber=aDocNumber
,
  TheDate=aTheDate
,
  TheAgent=aTheAgent
  where  INVOS_LIZINGID = aINVOS_LIZINGID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_LIZING');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_LIZINGid as varchar),  'INVOS_LIZING',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_LIZING
 (  INVOS_LIZINGID 
,InstanceID
,DocNumber

,TheDate

,TheAgent

 ) values ( aINVOS_LIZINGID 
,aInstanceID
,aDocNumber

,aTheDate

,aTheAgent

 ); 
 PERFORM INVOS_LIZING_SINIT( aCURSESSION,aINVOS_LIZINGid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_LIZING_PARENT_T /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_LIZING_PARENT_ID /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_LIZING where  INVOS_LIZINGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_ISLOCKED /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_LIZING where INVOS_LIZINGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_LOCK /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_LIZING_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_LIZING_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_LIZING set LockUserID =auserID ,LockSessionID =null where INVOS_LIZINGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_LIZING set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_LIZINGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_HCL /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_UNLOCK /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_LIZING_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_LIZING set LockUserID =null  where INVOS_LIZINGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_LIZING set LockSessionID =null  where INVOS_LIZINGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_SINIT /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_LIZING_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_LIZING_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_LIZING set securitystyleid =aStyleID where INVOS_LIZINGid = aRowID;
else 
 update INVOS_LIZING set securitystyleid =aSecurityStyleID where INVOS_LIZINGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_LIZING_propagate /*Лизинг*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_LIZING where INVOS_LIZINGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_CNSRV_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_CNSRVid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_CNSRV where INVOS_CNSRVID=aINVOS_CNSRVID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_CNSRV_BRIEF_F(aINVOS_CNSRVid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_DELETE /*Консервация*/ (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_CNSRV where INVOS_CNSRVID=aINVOS_CNSRVID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_CNSRV_ISLOCKED( acursession,aINVOS_CNSRVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_CNSRV');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_CNSRVid as varchar),   'INVOS_CNSRV',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_CNSRV' and OwnerRowID=aINVOS_CNSRVid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_CNSRV 
  where  INVOS_CNSRVID = aINVOS_CNSRVID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Консервация*/
 create or replace function  INVOS_CNSRV_SAVE /*Консервация*/ (
 aCURSESSION uuid,
 aINVOS_CNSRVid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала *//* Дата начала */
,aEndDate
 date/* Дата завершения *//* Дата завершения */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_CNSRV where INVOS_CNSRVID=aINVOS_CNSRVID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_CNSRV_ISLOCKED( acursession,aINVOS_CNSRVid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CNSRV');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_CNSRVid as varchar),  'INVOS_CNSRV',
 'EDITROW',  aInstanceID);
 update  INVOS_CNSRV set ChangeStamp=localtimestamp
,
  DocNumber=aDocNumber
,
  StartDate=aStartDate
,
  EndDate=aEndDate
  where  INVOS_CNSRVID = aINVOS_CNSRVID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CNSRV');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_CNSRVid as varchar),  'INVOS_CNSRV',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_CNSRV
 (  INVOS_CNSRVID 
,InstanceID
,DocNumber

,StartDate

,EndDate

 ) values ( aINVOS_CNSRVID 
,aInstanceID
,aDocNumber

,aStartDate

,aEndDate

 ); 
 PERFORM INVOS_CNSRV_SINIT( aCURSESSION,aINVOS_CNSRVid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_CNSRV_PARENT_T /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CNSRV_PARENT_ID /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_CNSRV where  INVOS_CNSRVid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_ISLOCKED /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_CNSRV where INVOS_CNSRVid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_LOCK /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CNSRV_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_CNSRV_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_CNSRV set LockUserID =auserID ,LockSessionID =null where INVOS_CNSRVid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_CNSRV set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_CNSRVid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_HCL /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_UNLOCK /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CNSRV_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_CNSRV set LockUserID =null  where INVOS_CNSRVid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_CNSRV set LockSessionID =null  where INVOS_CNSRVid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_SINIT /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_CNSRV_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_CNSRV_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_CNSRV set securitystyleid =aStyleID where INVOS_CNSRVid = aRowID;
else 
 update INVOS_CNSRV set securitystyleid =aSecurityStyleID where INVOS_CNSRVid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CNSRV_propagate /*Консервация*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_CNSRV where INVOS_CNSRVid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_INFO_BRIEF  (
 aCURSESSION uuid,
 aINVOS_INFOid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_INFOid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_INFO where INVOS_INFOID=aINVOS_INFOID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_INFO_BRIEF_F(aINVOS_INFOid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_DELETE /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aINVOS_INFOid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_INFO where INVOS_INFOID=aINVOS_INFOID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_INFO_ISLOCKED( acursession,aINVOS_INFOid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_INFO');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_INFOid as varchar),   'INVOS_INFO',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_INFO' and OwnerRowID=aINVOS_INFOid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_INFO 
  where  INVOS_INFOID = aINVOS_INFOID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Общие сведения*/
 create or replace function  INVOS_INFO_SAVE /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aINVOS_INFOid uuid,
ainstanceid uuid 
,aTheOrg
 uuid/* На учете в  *//* На учете в  */
,aIsMaterial
 INTEGER/* Материал *//* Материал */
,aOSType
 uuid/* Группа ОС *//* Группа ОС */
,aName
 VARCHAR/* Наименование *//* Наименование */
,aShortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aCardNum
 VARCHAR/* Номер карточки учета *//* Номер карточки учета */
,aINVNum
 VARCHAR/* Инвентарный номер *//* Инвентарный номер */
,aInLineNum
 integer/* Номер в партии *//* Номер в партии */
,aTheCost
 float/* Cтоимость *//* Cтоимость */
,aSrokPI
 integer/* Срок ПИ *//* Срок ПИ */
,aSrokFI
 integer/* Срок ФИ *//* Срок ФИ */
,aSrokOI
 integer/* Остаточный срок ПИ *//* Остаточный срок ПИ */
,aActivateDate
 date/* Дата ввода в эксп. *//* Дата ввода в эксп. */
,aInfo
 TEXT/* Описание *//* Описание */
,aTechFilePath
 VARCHAR/* Путь к файлу  с ТИ *//* Путь к файлу  с ТИ */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_INFO where INVOS_INFOID=aINVOS_INFOID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_INFO_ISLOCKED( acursession,aINVOS_INFOid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_INFO');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_INFOid as varchar),  'INVOS_INFO',
 'EDITROW',  aInstanceID);
 update  INVOS_INFO set ChangeStamp=localtimestamp
,
  TheOrg=aTheOrg
,
  IsMaterial=aIsMaterial
,
  OSType=aOSType
,
  Name=aName
,
  ShortName=aShortName
,
  CardNum=aCardNum
,
  INVNum=aINVNum
,
  InLineNum=aInLineNum
,
  TheCost=aTheCost
,
  SrokPI=aSrokPI
,
  SrokFI=aSrokFI
,
  SrokOI=aSrokOI
,
  ActivateDate=aActivateDate
,
  Info=aInfo
,
  TechFilePath=aTechFilePath
  where  INVOS_INFOID = aINVOS_INFOID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_INFO');
    return;
  end if;
select Count(*) into existsCnt from INVOS_INFO where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_INFO&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_INFOid as varchar),  'INVOS_INFO',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_INFO
 (  INVOS_INFOID 
,InstanceID
,TheOrg

,IsMaterial

,OSType

,Name

,ShortName

,CardNum

,INVNum

,InLineNum

,TheCost

,SrokPI

,SrokFI

,SrokOI

,ActivateDate

,Info

,TechFilePath

 ) values ( aINVOS_INFOID 
,aInstanceID
,aTheOrg

,aIsMaterial

,aOSType

,aName

,aShortName

,aCardNum

,aINVNum

,aInLineNum

,aTheCost

,aSrokPI

,aSrokFI

,aSrokOI

,aActivateDate

,aInfo

,aTechFilePath

 ); 
 PERFORM INVOS_INFO_SINIT( aCURSESSION,aINVOS_INFOid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_INFO_PARENT_T /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_INFO_PARENT_ID /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_INFO where  INVOS_INFOid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_ISLOCKED /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_INFO where INVOS_INFOid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_LOCK /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_INFO_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_INFO_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_INFO set LockUserID =auserID ,LockSessionID =null where INVOS_INFOid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_INFO set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_INFOid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_HCL /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_UNLOCK /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_INFO_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_INFO set LockUserID =null  where INVOS_INFOid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_INFO set LockSessionID =null  where INVOS_INFOid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_SINIT /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_INFO_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_INFO_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_INFO set securitystyleid =aStyleID where INVOS_INFOid = aRowID;
else 
 update INVOS_INFO set securitystyleid =aSecurityStyleID where INVOS_INFOid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_INFO_propagate /*Общие сведения об основном среддстве*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_INFO where INVOS_INFOid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_MOD_BRIEF  (
 aCURSESSION uuid,
 aINVOS_MODid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_MODid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_MOD where INVOS_MODID=aINVOS_MODID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_MOD_BRIEF_F(aINVOS_MODid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_DELETE /*Модернизация*/ (
 aCURSESSION uuid,
 aINVOS_MODid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_MOD where INVOS_MODID=aINVOS_MODID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_MOD_ISLOCKED( acursession,aINVOS_MODid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_MOD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_MODid as varchar),   'INVOS_MOD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_MOD' and OwnerRowID=aINVOS_MODid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_MOD 
  where  INVOS_MODID = aINVOS_MODID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Модернизация*/
 create or replace function  INVOS_MOD_SAVE /*Модернизация*/ (
 aCURSESSION uuid,
 aINVOS_MODid uuid,
ainstanceid uuid 
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
,aStartDate
 date/* Дата начала *//* Дата начала */
,aEndDate
 date/* Дата завершения *//* Дата завершения */
,aINFO
 TEXT/* Суть модернизации *//* Суть модернизации */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_MOD where INVOS_MODID=aINVOS_MODID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_MOD_ISLOCKED( acursession,aINVOS_MODid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_MOD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_MODid as varchar),  'INVOS_MOD',
 'EDITROW',  aInstanceID);
 update  INVOS_MOD set ChangeStamp=localtimestamp
,
  DocNumber=aDocNumber
,
  StartDate=aStartDate
,
  EndDate=aEndDate
,
  INFO=aINFO
  where  INVOS_MODID = aINVOS_MODID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_MOD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_MODid as varchar),  'INVOS_MOD',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_MOD
 (  INVOS_MODID 
,InstanceID
,DocNumber

,StartDate

,EndDate

,INFO

 ) values ( aINVOS_MODID 
,aInstanceID
,aDocNumber

,aStartDate

,aEndDate

,aINFO

 ); 
 PERFORM INVOS_MOD_SINIT( aCURSESSION,aINVOS_MODid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_MOD_PARENT_T /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_MOD_PARENT_ID /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_MOD where  INVOS_MODid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_ISLOCKED /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_MOD where INVOS_MODid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_LOCK /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_MOD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_MOD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_MOD set LockUserID =auserID ,LockSessionID =null where INVOS_MODid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_MOD set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_MODid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_HCL /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_UNLOCK /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_MOD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_MOD set LockUserID =null  where INVOS_MODid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_MOD set LockSessionID =null  where INVOS_MODid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_SINIT /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_MOD_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_MOD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_MOD set securitystyleid =aStyleID where INVOS_MODid = aRowID;
else 
 update INVOS_MOD set securitystyleid =aSecurityStyleID where INVOS_MODid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_MOD_propagate /*Модернизация*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_MOD where INVOS_MODid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_CMNT_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_CMNTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_CMNT where INVOS_CMNTID=aINVOS_CMNTID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_CMNT_BRIEF_F(aINVOS_CMNTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_DELETE /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_CMNT where INVOS_CMNTID=aINVOS_CMNTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_CMNT_ISLOCKED( acursession,aINVOS_CMNTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_CMNT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_CMNTid as varchar),   'INVOS_CMNT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_CMNT' and OwnerRowID=aINVOS_CMNTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_CMNT 
  where  INVOS_CMNTID = aINVOS_CMNTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Заметки о сосотоянии*/
 create or replace function  INVOS_CMNT_SAVE /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aINVOS_CMNTid uuid,
ainstanceid uuid 
,aTheCommenter
 uuid/* Запись сделал *//* Запись сделал */
,aTheDate
 date/* Дата записи *//* Дата записи */
,aInfo
 VARCHAR/* Информация *//* Информация */
,aTheComment
 TEXT/* Примечание *//* Примечание */
,aThePhoto
 BYTEA/* Фотография *//* Фотография */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_CMNT where INVOS_CMNTID=aINVOS_CMNTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_CMNT_ISLOCKED( acursession,aINVOS_CMNTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CMNT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_CMNTid as varchar),  'INVOS_CMNT',
 'EDITROW',  aInstanceID);
 update  INVOS_CMNT set ChangeStamp=localtimestamp
,
  TheCommenter=aTheCommenter
,
  TheDate=aTheDate
,
  Info=aInfo
,
  TheComment=aTheComment
,
  ThePhoto=aThePhoto
  where  INVOS_CMNTID = aINVOS_CMNTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CMNT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_CMNTid as varchar),  'INVOS_CMNT',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_CMNT
 (  INVOS_CMNTID 
,InstanceID
,TheCommenter

,TheDate

,Info

,TheComment

,ThePhoto

 ) values ( aINVOS_CMNTID 
,aInstanceID
,aTheCommenter

,aTheDate

,aInfo

,aTheComment

,aThePhoto

 ); 
 PERFORM INVOS_CMNT_SINIT( aCURSESSION,aINVOS_CMNTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_CMNT_PARENT_T /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CMNT_PARENT_ID /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_CMNT where  INVOS_CMNTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_ISLOCKED /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_CMNT where INVOS_CMNTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_LOCK /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CMNT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_CMNT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_CMNT set LockUserID =auserID ,LockSessionID =null where INVOS_CMNTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_CMNT set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_CMNTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_HCL /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_UNLOCK /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CMNT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_CMNT set LockUserID =null  where INVOS_CMNTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_CMNT set LockSessionID =null  where INVOS_CMNTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_SINIT /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_CMNT_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_CMNT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_CMNT set securitystyleid =aStyleID where INVOS_CMNTid = aRowID;
else 
 update INVOS_CMNT set securitystyleid =aSecurityStyleID where INVOS_CMNTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CMNT_propagate /*Заметки о сосотоянии*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_CMNT where INVOS_CMNTid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_CODE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_CODEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_CODEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_CODE where INVOS_CODEID=aINVOS_CODEID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_CODE_BRIEF_F(aINVOS_CODEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_DELETE /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aINVOS_CODEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_CODE where INVOS_CODEID=aINVOS_CODEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_CODE_ISLOCKED( acursession,aINVOS_CODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_CODE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_CODEid as varchar),   'INVOS_CODE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_CODE' and OwnerRowID=aINVOS_CODEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_CODE 
  where  INVOS_CODEID = aINVOS_CODEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Штрихкод*/
 create or replace function  INVOS_CODE_SAVE /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aINVOS_CODEid uuid,
ainstanceid uuid 
,aShCode
 VARCHAR/* Штрихкод *//* Штрихкод */
,aVisibleCode
 VARCHAR/* Читаемый код *//* Читаемый код */
,aCodePrinted
 INTEGER/* Штрихкод напечатан *//* Штрихкод напечатан */
,aMabualCreate
 INTEGER/* Создан вручную *//* Создан вручную */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_CODE where INVOS_CODEID=aINVOS_CODEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_CODE_ISLOCKED( acursession,aINVOS_CODEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CODE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_CODEid as varchar),  'INVOS_CODE',
 'EDITROW',  aInstanceID);
 update  INVOS_CODE set ChangeStamp=localtimestamp
,
  ShCode=aShCode
,
  VisibleCode=aVisibleCode
,
  CodePrinted=aCodePrinted
,
  MabualCreate=aMabualCreate
  where  INVOS_CODEID = aINVOS_CODEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_CODE');
    return;
  end if;
select Count(*) into existsCnt from INVOS_CODE where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_CODE&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_CODEid as varchar),  'INVOS_CODE',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_CODE
 (  INVOS_CODEID 
,InstanceID
,ShCode

,VisibleCode

,CodePrinted

,MabualCreate

 ) values ( aINVOS_CODEID 
,aInstanceID
,aShCode

,aVisibleCode

,aCodePrinted

,aMabualCreate

 ); 
 PERFORM INVOS_CODE_SINIT( aCURSESSION,aINVOS_CODEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_CODE_PARENT_T /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_CODE_PARENT_ID /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_CODE where  INVOS_CODEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_ISLOCKED /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_CODE where INVOS_CODEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_LOCK /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CODE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_CODE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_CODE set LockUserID =auserID ,LockSessionID =null where INVOS_CODEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_CODE set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_CODEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_HCL /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_UNLOCK /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_CODE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_CODE set LockUserID =null  where INVOS_CODEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_CODE set LockSessionID =null  where INVOS_CODEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_SINIT /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_CODE_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_CODE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_CODE set securitystyleid =aStyleID where INVOS_CODEid = aRowID;
else 
 update INVOS_CODE set securitystyleid =aSecurityStyleID where INVOS_CODEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_CODE_propagate /*Штрихкод ОС*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_CODE where INVOS_CODEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_REPAIR_BRIEF  (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_REPAIRid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_REPAIR where INVOS_REPAIRID=aINVOS_REPAIRID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_REPAIR_BRIEF_F(aINVOS_REPAIRid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_DELETE /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_REPAIR where INVOS_REPAIRID=aINVOS_REPAIRID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_REPAIR_ISLOCKED( acursession,aINVOS_REPAIRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_REPAIR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_REPAIRid as varchar),   'INVOS_REPAIR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_REPAIR' and OwnerRowID=aINVOS_REPAIRid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_REPAIR 
  where  INVOS_REPAIRID = aINVOS_REPAIRID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Ремонт*/
 create or replace function  INVOS_REPAIR_SAVE /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aINVOS_REPAIRid uuid,
ainstanceid uuid 
,aStartDate
 date/* Дата начала ремонта *//* Дата начала ремонта */
,aEndDate
 date/* Дата завершения ремонта *//* Дата завершения ремонта */
,aINFO
 TEXT/* Вид ремонта *//* Вид ремонта */
,aDocNumber
 VARCHAR/* Номер приказа *//* Номер приказа */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_REPAIR where INVOS_REPAIRID=aINVOS_REPAIRID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_REPAIR_ISLOCKED( acursession,aINVOS_REPAIRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_REPAIR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_REPAIRid as varchar),  'INVOS_REPAIR',
 'EDITROW',  aInstanceID);
 update  INVOS_REPAIR set ChangeStamp=localtimestamp
,
  StartDate=aStartDate
,
  EndDate=aEndDate
,
  INFO=aINFO
,
  DocNumber=aDocNumber
  where  INVOS_REPAIRID = aINVOS_REPAIRID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_REPAIR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_REPAIRid as varchar),  'INVOS_REPAIR',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_REPAIR
 (  INVOS_REPAIRID 
,InstanceID
,StartDate

,EndDate

,INFO

,DocNumber

 ) values ( aINVOS_REPAIRID 
,aInstanceID
,aStartDate

,aEndDate

,aINFO

,aDocNumber

 ); 
 PERFORM INVOS_REPAIR_SINIT( aCURSESSION,aINVOS_REPAIRid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_REPAIR_PARENT_T /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_REPAIR_PARENT_ID /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_REPAIR where  INVOS_REPAIRid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_ISLOCKED /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_REPAIR where INVOS_REPAIRid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_LOCK /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_REPAIR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_REPAIR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_REPAIR set LockUserID =auserID ,LockSessionID =null where INVOS_REPAIRid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_REPAIR set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_REPAIRid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_HCL /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_UNLOCK /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_REPAIR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_REPAIR set LockUserID =null  where INVOS_REPAIRid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_REPAIR set LockSessionID =null  where INVOS_REPAIRid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_SINIT /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_REPAIR_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_REPAIR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_REPAIR set securitystyleid =aStyleID where INVOS_REPAIRid = aRowID;
else 
 update INVOS_REPAIR set securitystyleid =aSecurityStyleID where INVOS_REPAIRid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_REPAIR_propagate /*Данные по ремонту*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_REPAIR where INVOS_REPAIRid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVOS_PLACE_BRIEF  (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVOS_PLACEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVOS_PLACE where INVOS_PLACEID=aINVOS_PLACEID;
if existsCnt &gt;0
 then
  aBRIEF:= INVOS_PLACE_BRIEF_F(aINVOS_PLACEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_DELETE /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVOS_PLACE where INVOS_PLACEID=aINVOS_PLACEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVOS_PLACE_ISLOCKED( acursession,aINVOS_PLACEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVOS_PLACE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVOS_PLACEid as varchar),   'INVOS_PLACE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVOS_PLACE' and OwnerRowID=aINVOS_PLACEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVOS_PLACE 
  where  INVOS_PLACEID = aINVOS_PLACEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Принадлежность*/
 create or replace function  INVOS_PLACE_SAVE /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aINVOS_PLACEid uuid,
ainstanceid uuid 
,aMatOtv
 uuid/* Матерально отв. *//* Матерально отв. */
,aTheHouse
 uuid/* Здание *//* Здание */
,aComplNumber
 VARCHAR/* Номер комплекта *//* Номер комплекта */
,aDIrection
 uuid/* Дирекция *//* Дирекция */
,aUprav
 uuid/* Управление *//* Управление */
,aOtdel
 uuid/* Отдел *//* Отдел */
,aFlow
 VARCHAR/* Этаж *//* Этаж */
,aRoom
 VARCHAR/* Кабинет *//* Кабинет */
,aWorkPlaceNum
 VARCHAR/* Номер рабочего места *//* Номер рабочего места */
,aTheOwner
 uuid/* Владелец *//* Владелец */
,aInfo
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVOS_PLACE where INVOS_PLACEID=aINVOS_PLACEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVOS_PLACE_ISLOCKED( acursession,aINVOS_PLACEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_PLACE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVOS_PLACEid as varchar),  'INVOS_PLACE',
 'EDITROW',  aInstanceID);
 update  INVOS_PLACE set ChangeStamp=localtimestamp
,
  MatOtv=aMatOtv
,
  TheHouse=aTheHouse
,
  ComplNumber=aComplNumber
,
  DIrection=aDIrection
,
  Uprav=aUprav
,
  Otdel=aOtdel
,
  Flow=aFlow
,
  Room=aRoom
,
  WorkPlaceNum=aWorkPlaceNum
,
  TheOwner=aTheOwner
,
  Info=aInfo
  where  INVOS_PLACEID = aINVOS_PLACEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVOS_PLACE');
    return;
  end if;
select Count(*) into existsCnt from INVOS_PLACE where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVOS_PLACE&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVOS_PLACEid as varchar),  'INVOS_PLACE',
 'CREATEROW',  aInstanceID);
 insert into   INVOS_PLACE
 (  INVOS_PLACEID 
,InstanceID
,MatOtv

,TheHouse

,ComplNumber

,DIrection

,Uprav

,Otdel

,Flow

,Room

,WorkPlaceNum

,TheOwner

,Info

 ) values ( aINVOS_PLACEID 
,aInstanceID
,aMatOtv

,aTheHouse

,aComplNumber

,aDIrection

,aUprav

,aOtdel

,aFlow

,aRoom

,aWorkPlaceNum

,aTheOwner

,aInfo

 ); 
 PERFORM INVOS_PLACE_SINIT( aCURSESSION,aINVOS_PLACEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVOS_PLACE_PARENT_T /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVOS_PLACE_PARENT_ID /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVOS_PLACE where  INVOS_PLACEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_ISLOCKED /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVOS_PLACE where INVOS_PLACEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_LOCK /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVOS_PLACE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVOS_PLACE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVOS_PLACE set LockUserID =auserID ,LockSessionID =null where INVOS_PLACEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVOS_PLACE set LockUserID =null,LockSessionID =aCURSESSION  where INVOS_PLACEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_HCL /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_UNLOCK /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVOS_PLACE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVOS_PLACE set LockUserID =null  where INVOS_PLACEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVOS_PLACE set LockSessionID =null  where INVOS_PLACEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_SINIT /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVOS_PLACE_parent_T( aCURSESSION,aROWID);
 aParentID:= INVOS_PLACE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVOS_PLACE set securitystyleid =aStyleID where INVOS_PLACEid = aRowID;
else 
 update INVOS_PLACE set securitystyleid =aSecurityStyleID where INVOS_PLACEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVOS_PLACE_propagate /*Принадлежность и метоположение*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVOS_PLACE where INVOS_PLACEid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZRprt" BlockCode=" create or replace function  MTZRprt_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZRprt'
then
Open aCurs  for select Reports.Reportsid ID from Reports where  Reports.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Reports_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select RPTStruct.RPTStructid ID from RPTStruct where  RPTStruct.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM RPTStruct_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select RPTFormula.RPTFormulaid ID from RPTFormula where  RPTFormula.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM RPTFormula_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZRprt_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZRprt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select Reports.Reportsid ID from Reports where  Reports.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Reports where Reportsid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Reports_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select RPTStruct.RPTStructid ID from RPTStruct where  RPTStruct.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from RPTStruct where RPTStructid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= RPTStruct_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select RPTFormula.RPTFormulaid ID from RPTFormula where  RPTFormula.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from RPTFormula where RPTFormulaid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= RPTFormula_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZRprt_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZRprt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select Reports.Reportsid id from Reports where  Reports.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Reports_SINIT( acursession,aid,assid);
 PERFORM Reports_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select RPTStruct.RPTStructid id from RPTStruct where  RPTStruct.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM RPTStruct_SINIT( acursession,aid,assid);
 PERFORM RPTStruct_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select RPTFormula.RPTFormulaid id from RPTFormula where  RPTFormula.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM RPTFormula_SINIT( acursession,aid,assid);
 PERFORM RPTFormula_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  Reports_BRIEF  (
 aCURSESSION uuid,
 aReportsid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aReportsid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0
 then
  aBRIEF:= Reports_BRIEF_F(aReportsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Reports_DELETE /*Описание*/ (
 aCURSESSION uuid,
 aReportsid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Reports_ISLOCKED( acursession,aReportsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Reports');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aReportsid as varchar),   'Reports',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Reports' and OwnerRowID=aReportsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Reports 
  where  ReportsID = aReportsID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание*/
 create or replace function  Reports_SAVE /*Описание*/ (
 aCURSESSION uuid,
 aReportsid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aReportFile
 bytea/* Файл отчета */
,aReportFile_EXT varchar /* Файл отчета */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aPrepareMethod
 uuid/* Метод для формирования *//* Метод для формирования */
,aReportType
 INTEGER/* Тип отчета *//* Тип отчета */
,aTheReportExt
 uuid/* Расширение для создания отчета *//* Расширение для создания отчета */
,aReportView
 VARCHAR/* Базовый запрос *//* Базовый запрос */
,aTheComment
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Reports_ISLOCKED( acursession,aReportsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Reports');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aReportsid as varchar),  'Reports',
 'EDITROW',  aInstanceID);
 update  Reports set ChangeStamp=localtimestamp
,
  Name=aName
,
  ReportFile=aReportFile
,ReportFile_EXT=
aReportFile_EXT 
,
  Caption=aCaption
,
  PrepareMethod=aPrepareMethod
,
  ReportType=aReportType
,
  TheReportExt=aTheReportExt
,
  ReportView=aReportView
,
  TheComment=aTheComment
  where  ReportsID = aReportsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Reports');
    return;
  end if;
select Count(*) into existsCnt from Reports where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Reports&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aReportsid as varchar),  'Reports',
 'CREATEROW',  aInstanceID);
 insert into   Reports
 (  ReportsID 
,InstanceID
,Name

,ReportFile

,ReportFile_EXT
,Caption

,PrepareMethod

,ReportType

,TheReportExt

,ReportView

,TheComment

 ) values ( aReportsID 
,aInstanceID
,aName

,aReportFile

,aReportFile_EXT
,aCaption

,aPrepareMethod

,aReportType

,aTheReportExt

,aReportView

,aTheComment

 ); 
 PERFORM Reports_SINIT( aCURSESSION,aReportsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Reports_PARENT_T /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Reports_PARENT_ID /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Reports where  Reportsid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Reports_ISLOCKED /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Reports where Reportsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Reports_LOCK /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Reports_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Reports_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Reports set LockUserID =auserID ,LockSessionID =null where Reportsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Reports set LockUserID =null,LockSessionID =aCURSESSION  where Reportsid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Reports_HCL /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Reports_UNLOCK /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Reports_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Reports set LockUserID =null  where Reportsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Reports set LockSessionID =null  where Reportsid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Reports_SINIT /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Reports_parent_T( aCURSESSION,aROWID);
 aParentID:= Reports_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Reports set securitystyleid =aStyleID where Reportsid = aRowID;
else 
 update Reports set securitystyleid =aSecurityStyleID where Reportsid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Reports_propagate /*Описание*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Reports where Reportsid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  RPTStruct_BRIEF  (
 aCURSESSION uuid,
 aRPTStructid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aRPTStructid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0
 then
  aBRIEF:= RPTStruct_BRIEF_F(aRPTStructid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_DELETE /*Секции*/ (
 aCURSESSION uuid,
 aRPTStructid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  RPTStruct_ISLOCKED( acursession,aRPTStructid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTStruct');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRPTStructid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  RPTFields_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aRPTStructid as varchar),   'RPTStruct',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='RPTStruct' and OwnerRowID=aRPTStructid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  RPTStruct 
  where  RPTStructID = aRPTStructID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Секции*/
 create or replace function  RPTStruct_SAVE /*Секции*/ (
 aCURSESSION uuid,
 aRPTStructid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  RPTStruct_ISLOCKED( acursession,aRPTStructid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTStruct');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aRPTStructid as varchar),  'RPTStruct',
 'EDITROW',  aInstanceID);
 update  RPTStruct set ChangeStamp=localtimestamp
,ParentRowid= aParentRowid
,
  Name=aName
,
  Caption=aCaption
  where  RPTStructID = aRPTStructID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTStruct');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aRPTStructid as varchar),  'RPTStruct',
 'CREATEROW',  aInstanceID);
 insert into   RPTStruct
 (  RPTStructID 
,ParentRowid
,InstanceID
,Name

,Caption

 ) values ( aRPTStructID 
,aParentRowid
,aInstanceID
,aName

,aCaption

 ); 
 PERFORM RPTStruct_SINIT( aCURSESSION,aRPTStructid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  RPTStruct_PARENT_T /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  RPTStruct_PARENT_ID /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from RPTStruct where  RPTStructid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_ISLOCKED /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTStruct where RPTStructid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_LOCK /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= RPTStruct_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= RPTStruct_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update RPTStruct set LockUserID =auserID ,LockSessionID =null where RPTStructid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTStruct set LockUserID =null,LockSessionID =aCURSESSION  where RPTStructid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_HCL /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from RPTFields where RPTFieldsid=row_RPTFields.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= RPTFields_HCL (acursession,row_RPTFields.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  RPTStruct_UNLOCK /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= RPTStruct_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTStruct set LockUserID =null  where RPTStructid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTStruct set LockSessionID =null  where RPTStructid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_SINIT /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=RPTStruct_parent_T( aCURSESSION,aROWID);
 aParentID:= RPTStruct_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update RPTStruct set securitystyleid =aStyleID where RPTStructid = aRowID;
else 
 update RPTStruct set securitystyleid =aSecurityStyleID where RPTStructid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  RPTStruct_propagate /*Секции*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from RPTStruct where RPTStructid=aRowid;
open aCurs for select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  RPTFields_SINIT( acursession,aid,assid);
 PERFORM  RPTFields_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  RPTFields_BRIEF  (
 aCURSESSION uuid,
 aRPTFieldsid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aRPTFieldsid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0
 then
  aBRIEF:= RPTFields_BRIEF_F(aRPTFieldsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  RPTFields_DELETE /*Поля секции*/ (
 aCURSESSION uuid,
 aRPTFieldsid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  RPTFields_ISLOCKED( acursession,aRPTFieldsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTFields');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aRPTFieldsid as varchar),   'RPTFields',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='RPTFields' and OwnerRowID=aRPTFieldsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  RPTFields 
  where  RPTFieldsID = aRPTFieldsID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Поля секции*/
 create or replace function  RPTFields_SAVE /*Поля секции*/ (
 aCURSESSION uuid,
 aRPTFieldsid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aFieldType
 uuid/* Тип поля *//* Тип поля */
,aFieldSize
 integer/* Размер *//* Размер */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  RPTFields_ISLOCKED( acursession,aRPTFieldsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFields');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aRPTFieldsid as varchar),  'RPTFields',
 'EDITROW',  aInstanceID);
 update  RPTFields set ChangeStamp=localtimestamp
,
  Name=aName
,
  FieldType=aFieldType
,
  FieldSize=aFieldSize
,
  Caption=aCaption
  where  RPTFieldsID = aRPTFieldsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= RPTStruct_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFields');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aRPTFieldsid as varchar),  'RPTFields',
 'CREATEROW',  aInstanceID);
 insert into   RPTFields
 (  RPTFieldsID 
,ParentStructRowID
,Name

,FieldType

,FieldSize

,Caption

 ) values ( aRPTFieldsID 
,aParentStructRowID
,aName

,aFieldType

,aFieldSize

,aCaption

 ); 
 PERFORM RPTFields_SINIT( aCURSESSION,aRPTFieldsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  RPTFields_PARENT_T /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'RPTStruct';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  RPTFields_PARENT_ID /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from RPTFields where  RPTFieldsid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_ISLOCKED /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTFields where RPTFieldsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_LOCK /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= RPTFields_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= RPTFields_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update RPTFields set LockUserID =auserID ,LockSessionID =null where RPTFieldsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTFields set LockUserID =null,LockSessionID =aCURSESSION  where RPTFieldsid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_HCL /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  RPTFields_UNLOCK /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= RPTFields_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTFields set LockUserID =null  where RPTFieldsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTFields set LockSessionID =null  where RPTFieldsid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_SINIT /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=RPTFields_parent_T( aCURSESSION,aROWID);
 aParentID:= RPTFields_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update RPTFields set securitystyleid =aStyleID where RPTFieldsid = aRowID;
else 
 update RPTFields set securitystyleid =aSecurityStyleID where RPTFieldsid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  RPTFields_propagate /*Поля секции*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from RPTFields where RPTFieldsid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  RPTFormula_BRIEF  (
 aCURSESSION uuid,
 aRPTFormulaid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aRPTFormulaid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0
 then
  aBRIEF:= RPTFormula_BRIEF_F(aRPTFormulaid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_DELETE /*Формулы*/ (
 aCURSESSION uuid,
 aRPTFormulaid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  RPTFormula_ISLOCKED( acursession,aRPTFormulaid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTFormula');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aRPTFormulaid as varchar),   'RPTFormula',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='RPTFormula' and OwnerRowID=aRPTFormulaid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  RPTFormula 
  where  RPTFormulaID = aRPTFormulaID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Формулы*/
 create or replace function  RPTFormula_SAVE /*Формулы*/ (
 aCURSESSION uuid,
 aRPTFormulaid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 TEXT/* Выражение *//* Выражение */
,aPlatform
 uuid/* Платформа *//* Платформа */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  RPTFormula_ISLOCKED( acursession,aRPTFormulaid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFormula');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aRPTFormulaid as varchar),  'RPTFormula',
 'EDITROW',  aInstanceID);
 update  RPTFormula set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
,
  Platform=aPlatform
  where  RPTFormulaID = aRPTFormulaID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFormula');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aRPTFormulaid as varchar),  'RPTFormula',
 'CREATEROW',  aInstanceID);
 insert into   RPTFormula
 (  RPTFormulaID 
,InstanceID
,Name

,Code

,Platform

 ) values ( aRPTFormulaID 
,aInstanceID
,aName

,aCode

,aPlatform

 ); 
 PERFORM RPTFormula_SINIT( aCURSESSION,aRPTFormulaid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  RPTFormula_PARENT_T /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  RPTFormula_PARENT_ID /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from RPTFormula where  RPTFormulaid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_ISLOCKED /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTFormula where RPTFormulaid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_LOCK /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= RPTFormula_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= RPTFormula_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update RPTFormula set LockUserID =auserID ,LockSessionID =null where RPTFormulaid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTFormula set LockUserID =null,LockSessionID =aCURSESSION  where RPTFormulaid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_HCL /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  RPTFormula_UNLOCK /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= RPTFormula_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTFormula set LockUserID =null  where RPTFormulaid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTFormula set LockSessionID =null  where RPTFormulaid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_SINIT /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=RPTFormula_parent_T( aCURSESSION,aROWID);
 aParentID:= RPTFormula_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update RPTFormula set securitystyleid =aStyleID where RPTFormulaid = aRowID;
else 
 update RPTFormula set securitystyleid =aSecurityStyleID where RPTFormulaid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  RPTFormula_propagate /*Формулы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from RPTFormula where RPTFormulaid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZUsers" BlockCode=" create or replace function  MTZUsers_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZUsers'
then
Open aCurs  for select Users.Usersid ID from Users where  Users.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Users_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Groups.Groupsid ID from Groups where  Groups.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Groups_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZUsers_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZUsers'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select Users.Usersid ID from Users where  Users.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Users where Usersid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Users_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Groups.Groupsid ID from Groups where  Groups.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Groups where Groupsid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Groups_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZUsers_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZUsers'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select Users.Usersid id from Users where  Users.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Users_SINIT( acursession,aid,assid);
 PERFORM Users_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Groups.Groupsid id from Groups where  Groups.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Groups_SINIT( acursession,aid,assid);
 PERFORM Groups_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  Users_BRIEF  (
 aCURSESSION uuid,
 aUsersid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aUsersid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0
 then
  aBRIEF:= Users_BRIEF_F(aUsersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Users_DELETE /*Пользователи*/ (
 aCURSESSION uuid,
 aUsersid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Users_ISLOCKED( acursession,aUsersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Users');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aUsersid as varchar),   'Users',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Users' and OwnerRowID=aUsersid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Users 
  where  UsersID = aUsersID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Пользователи*/
 create or replace function  Users_SAVE /*Пользователи*/ (
 aCURSESSION uuid,
 aUsersid uuid,
ainstanceid uuid 
,aFamily
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
,aLogin
 VARCHAR/* Имя для входа *//* Имя для входа */
,aPassword varchar/* Пароль *//* Пароль */
,aDomaiName
 VARCHAR/* Доменное имя *//* Доменное имя */
,aEMail varchar/* e-mail *//* e-mail */
,aPhone
 VARCHAR/* Телефон *//* Телефон */
,aLocalPhone
 VARCHAR/* Местный телефон *//* Местный телефон */
,aMobilePhone
 VARCHAR/* Мобильный телефон *//* Мобильный телефон */
,aPhoto
 BYTEA/* Фото *//* Фото */
,aBirthDay
 date/* Дата рождения *//* Дата рождения */
,aActivity
 uuid/* Журнал активности *//* Журнал активности */
,aCertificateID
 VARCHAR/* CertificateID *//* CertificateID */
,aCertData
 TEXT/* CertData *//* CertData */
,aClientDef
 uuid/* Ассоциация с клиентом *//* Ассоциация с клиентом */
,aPersonaData
 uuid/* PersonaData *//* PersonaData */
,aPositionU
 VARCHAR/* Должность *//* Должность */
,aWorkPlace
 VARCHAR/* Место работы *//* Место работы */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Users_ISLOCKED( acursession,aUsersid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Users');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aUsersid as varchar),  'Users',
 'EDITROW',  aInstanceID);
 update  Users set ChangeStamp=localtimestamp
,
  Family=aFamily
,
  Name=aName
,
  SurName=aSurName
,
  Login=aLogin
,
  Password=aPassword
,
  DomaiName=aDomaiName
,
  EMail=aEMail
,
  Phone=aPhone
,
  LocalPhone=aLocalPhone
,
  MobilePhone=aMobilePhone
,
  Photo=aPhoto
,
  BirthDay=aBirthDay
,
  Activity=aActivity
,
  CertificateID=aCertificateID
,
  CertData=aCertData
,
  ClientDef=aClientDef
,
  PersonaData=aPersonaData
,
  PositionU=aPositionU
,
  WorkPlace=aWorkPlace
  where  UsersID = aUsersID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Users where InstanceID=aInstanceID 
 and Login=aLogin;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Users');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Users');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aUsersid as varchar),  'Users',
 'CREATEROW',  aInstanceID);
 insert into   Users
 (  UsersID 
,InstanceID
,Family

,Name

,SurName

,Login

,Password

,DomaiName

,EMail

,Phone

,LocalPhone

,MobilePhone

,Photo

,BirthDay

,Activity

,CertificateID

,CertData

,ClientDef

,PersonaData

,PositionU

,WorkPlace

 ) values ( aUsersID 
,aInstanceID
,aFamily

,aName

,aSurName

,aLogin

,aPassword

,aDomaiName

,aEMail

,aPhone

,aLocalPhone

,aMobilePhone

,aPhoto

,aBirthDay

,aActivity

,aCertificateID

,aCertData

,aClientDef

,aPersonaData

,aPositionU

,aWorkPlace

 ); 
 PERFORM Users_SINIT( aCURSESSION,aUsersid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Users where InstanceID=aInstanceID 
 and Login=aLogin;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Users');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Users_PARENT_T /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Users_PARENT_ID /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Users where  Usersid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Users_ISLOCKED /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Users where Usersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Users_LOCK /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Users_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Users_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Users set LockUserID =auserID ,LockSessionID =null where Usersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Users set LockUserID =null,LockSessionID =aCURSESSION  where Usersid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Users_HCL /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Users_UNLOCK /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Users_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Users set LockUserID =null  where Usersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Users set LockSessionID =null  where Usersid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Users_SINIT /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Users_parent_T( aCURSESSION,aROWID);
 aParentID:= Users_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Users set securitystyleid =aStyleID where Usersid = aRowID;
else 
 update Users set securitystyleid =aSecurityStyleID where Usersid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Users_propagate /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Users where Usersid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Groups_BRIEF  (
 aCURSESSION uuid,
 aGroupsid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGroupsid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0
 then
  aBRIEF:= Groups_BRIEF_F(aGroupsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Groups_DELETE /*Группы*/ (
 aCURSESSION uuid,
 aGroupsid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Groups_ISLOCKED( acursession,aGroupsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Groups');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aGroupsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GroupUser_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGroupsid as varchar),   'Groups',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Groups' and OwnerRowID=aGroupsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Groups 
  where  GroupsID = aGroupsID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Группы*/
 create or replace function  Groups_SAVE /*Группы*/ (
 aCURSESSION uuid,
 aGroupsid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Groups_ISLOCKED( acursession,aGroupsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Groups');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGroupsid as varchar),  'Groups',
 'EDITROW',  aInstanceID);
 update  Groups set ChangeStamp=localtimestamp
,
  Name=aName
  where  GroupsID = aGroupsID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Groups where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Groups');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Groups');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGroupsid as varchar),  'Groups',
 'CREATEROW',  aInstanceID);
 insert into   Groups
 (  GroupsID 
,InstanceID
,Name

 ) values ( aGroupsID 
,aInstanceID
,aName

 ); 
 PERFORM Groups_SINIT( aCURSESSION,aGroupsid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Groups where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Groups');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Groups_PARENT_T /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Groups_PARENT_ID /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Groups where  Groupsid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Groups_ISLOCKED /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Groups where Groupsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Groups_LOCK /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Groups_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Groups_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Groups set LockUserID =auserID ,LockSessionID =null where Groupsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Groups set LockUserID =null,LockSessionID =aCURSESSION  where Groupsid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Groups_HCL /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GroupUser where GroupUserid=row_GroupUser.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= GroupUser_HCL (acursession,row_GroupUser.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Groups_UNLOCK /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Groups_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Groups set LockUserID =null  where Groupsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Groups set LockSessionID =null  where Groupsid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Groups_SINIT /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Groups_parent_T( aCURSESSION,aROWID);
 aParentID:= Groups_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Groups set securitystyleid =aStyleID where Groupsid = aRowID;
else 
 update Groups set securitystyleid =aSecurityStyleID where Groupsid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Groups_propagate /*Группы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Groups where Groupsid=aRowid;
open aCurs for select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  GroupUser_SINIT( acursession,aid,assid);
 PERFORM  GroupUser_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  GroupUser_BRIEF  (
 aCURSESSION uuid,
 aGroupUserid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aGroupUserid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0
 then
  aBRIEF:= GroupUser_BRIEF_F(aGroupUserid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  GroupUser_DELETE /*Состав группы*/ (
 aCURSESSION uuid,
 aGroupUserid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  GroupUser_ISLOCKED( acursession,aGroupUserid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GroupUser');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aGroupUserid as varchar),   'GroupUser',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='GroupUser' and OwnerRowID=aGroupUserid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  GroupUser 
  where  GroupUserID = aGroupUserID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Состав группы*/
 create or replace function  GroupUser_SAVE /*Состав группы*/ (
 aCURSESSION uuid,
 aGroupUserid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  GroupUser_ISLOCKED( acursession,aGroupUserid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GroupUser');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aGroupUserid as varchar),  'GroupUser',
 'EDITROW',  aInstanceID);
 update  GroupUser set ChangeStamp=localtimestamp
,
  TheUser=aTheUser
  where  GroupUserID = aGroupUserID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from GroupUser where ParentStructRowID=aParentStructRowID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=GroupUser');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 aaccess:= Groups_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GroupUser');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aGroupUserid as varchar),  'GroupUser',
 'CREATEROW',  aInstanceID);
 insert into   GroupUser
 (  GroupUserID 
,ParentStructRowID
,TheUser

 ) values ( aGroupUserID 
,aParentStructRowID
,aTheUser

 ); 
 PERFORM GroupUser_SINIT( aCURSESSION,aGroupUserid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from GroupUser where ParentStructRowID=aParentStructRowID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=GroupUser');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  GroupUser_PARENT_T /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'Groups';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  GroupUser_PARENT_ID /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from GroupUser where  GroupUserid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_ISLOCKED /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GroupUser where GroupUserid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_LOCK /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= GroupUser_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= GroupUser_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update GroupUser set LockUserID =auserID ,LockSessionID =null where GroupUserid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GroupUser set LockUserID =null,LockSessionID =aCURSESSION  where GroupUserid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_HCL /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  GroupUser_UNLOCK /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= GroupUser_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GroupUser set LockUserID =null  where GroupUserid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GroupUser set LockSessionID =null  where GroupUserid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_SINIT /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=GroupUser_parent_T( aCURSESSION,aROWID);
 aParentID:= GroupUser_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update GroupUser set securitystyleid =aStyleID where GroupUserid = aRowID;
else 
 update GroupUser set securitystyleid =aSecurityStyleID where GroupUserid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  GroupUser_propagate /*Состав группы*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from GroupUser where GroupUserid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZSystem" BlockCode=" create or replace function  MTZSystem_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZSystem'
then
Open aCurs  for select SysLog.SysLogid ID from SysLog where  SysLog.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SysLog_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select the_Session.the_Sessionid ID from the_Session where  the_Session.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM the_Session_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select LogReader.LogReaderid ID from LogReader where  LogReader.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM LogReader_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Verb.Verbid ID from Verb where  Verb.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Verb_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSystem_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZSystem'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select SysLog.SysLogid ID from SysLog where  SysLog.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SysLog where SysLogid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= SysLog_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select the_Session.the_Sessionid ID from the_Session where  the_Session.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from the_Session where the_Sessionid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= the_Session_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select LogReader.LogReaderid ID from LogReader where  LogReader.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from LogReader where LogReaderid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= LogReader_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Verb.Verbid ID from Verb where  Verb.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Verb where Verbid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Verb_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZSystem_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZSystem'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select SysLog.SysLogid id from SysLog where  SysLog.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM SysLog_SINIT( acursession,aid,assid);
 PERFORM SysLog_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select the_Session.the_Sessionid id from the_Session where  the_Session.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM the_Session_SINIT( acursession,aid,assid);
 PERFORM the_Session_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select LogReader.LogReaderid id from LogReader where  LogReader.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM LogReader_SINIT( acursession,aid,assid);
 PERFORM LogReader_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Verb.Verbid id from Verb where  Verb.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Verb_SINIT( acursession,aid,assid);
 PERFORM Verb_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  SysLog_BRIEF  (
 aCURSESSION uuid,
 aSysLogid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aSysLogid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0
 then
  aBRIEF:= SysLog_BRIEF_F(aSysLogid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  SysLog_DELETE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aSysLogid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  SysLog_ISLOCKED( acursession,aSysLogid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SysLog');
    return;
  end if;
  --begin tran--  
 -- erase child items --
open aCurs for select  instanceid ID from instance where OwnerPartName ='SysLog' and OwnerRowID=aSysLogid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  SysLog 
  where  SysLogID = aSysLogID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Журнал событий*/
 create or replace function  SysLog_SAVE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aSysLogid uuid,
ainstanceid uuid 
,aTheSession
 uuid/* Сессия *//* Сессия */
,athe_Resource
 VARCHAR/* Ресурс *//* Ресурс */
,aLogStructID
 VARCHAR/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,aVERB
 VARCHAR/* Действие *//* Действие */
,aLogInstanceID
 uuid/* Идентификатор документа *//* Идентификатор документа */
)  returns void as $$
 declare 
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  SysLog_ISLOCKED( acursession,aSysLogid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysLog');
    return;
  end if;
 -- update row  --
 update  SysLog set ChangeStamp=localtimestamp
,
  TheSession=aTheSession
,
  the_Resource=athe_Resource
,
  LogStructID=aLogStructID
,
  VERB=aVERB
,
  LogInstanceID=aLogInstanceID
  where  SysLogID = aSysLogID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysLog');
    return;
  end if;
 insert into   SysLog
 (  SysLogID 
,InstanceID
,TheSession

,the_Resource

,LogStructID

,VERB

,LogInstanceID

 ) values ( aSysLogID 
,aInstanceID
,aTheSession

,athe_Resource

,aLogStructID

,aVERB

,aLogInstanceID

 ); 
 PERFORM SysLog_SINIT( aCURSESSION,aSysLogid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  SysLog_PARENT_T /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  SysLog_PARENT_ID /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from SysLog where  SysLogid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  SysLog_ISLOCKED /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SysLog where SysLogid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  SysLog_LOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= SysLog_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= SysLog_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update SysLog set LockUserID =auserID ,LockSessionID =null where SysLogid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SysLog set LockUserID =null,LockSessionID =aCURSESSION  where SysLogid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  SysLog_HCL /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  SysLog_UNLOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= SysLog_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SysLog set LockUserID =null  where SysLogid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SysLog set LockSessionID =null  where SysLogid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  SysLog_SINIT /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=SysLog_parent_T( aCURSESSION,aROWID);
 aParentID:= SysLog_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update SysLog set securitystyleid =aStyleID where SysLogid = aRowID;
else 
 update SysLog set securitystyleid =aSecurityStyleID where SysLogid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  SysLog_propagate /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from SysLog where SysLogid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  the_Session_BRIEF  (
 aCURSESSION uuid,
 athe_Sessionid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if athe_Sessionid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0
 then
  aBRIEF:= the_Session_BRIEF_F(athe_Sessionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  the_Session_DELETE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 athe_Sessionid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  the_Session_ISLOCKED( acursession,athe_Sessionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=the_Session');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( athe_Sessionid as varchar),   'the_Session',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='the_Session' and OwnerRowID=athe_Sessionid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  the_Session 
  where  the_SessionID = athe_SessionID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Сессия пользователя*/
 create or replace function  the_Session_SAVE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 athe_Sessionid uuid,
ainstanceid uuid 
,aUserRole
 uuid/* Текущая роль пользователя *//* Текущая роль пользователя */
,aClosedAt
 timestamp/* Момент закрытия *//* Момент закрытия */
,aClosed
 integer/* Закрыта *//* Закрыта */
,aUsersid
 uuid/* Пользователь *//* Пользователь */
,aLastAccess
 timestamp/* Последнее подтверждение *//* Последнее подтверждение */
,aStartAt
 timestamp/* Момент открытия *//* Момент открытия */
,aLang
 VARCHAR/* Локализация *//* Локализация */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  the_Session_ISLOCKED( acursession,athe_Sessionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_Session');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(athe_Sessionid as varchar),  'the_Session',
 'EDITROW',  aInstanceID);
 update  the_Session set ChangeStamp=localtimestamp
,
  UserRole=aUserRole
,
  ClosedAt=aClosedAt
,
  Closed=aClosed
,
  Usersid=aUsersid
,
  LastAccess=aLastAccess
,
  StartAt=aStartAt
,
  Lang=aLang
  where  the_SessionID = athe_SessionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_Session');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(athe_Sessionid as varchar),  'the_Session',
 'CREATEROW',  aInstanceID);
 insert into   the_Session
 (  the_SessionID 
,InstanceID
,UserRole

,ClosedAt

,Closed

,Usersid

,LastAccess

,StartAt

,Lang

 ) values ( athe_SessionID 
,aInstanceID
,aUserRole

,aClosedAt

,aClosed

,aUsersid

,aLastAccess

,aStartAt

,aLang

 ); 
 PERFORM the_Session_SINIT( aCURSESSION,athe_Sessionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  the_Session_PARENT_T /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  the_Session_PARENT_ID /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from the_Session where  the_Sessionid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  the_Session_ISLOCKED /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from the_Session where the_Sessionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  the_Session_LOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= the_Session_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= the_Session_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update the_Session set LockUserID =auserID ,LockSessionID =null where the_Sessionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update the_Session set LockUserID =null,LockSessionID =aCURSESSION  where the_Sessionid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  the_Session_HCL /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  the_Session_UNLOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= the_Session_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update the_Session set LockUserID =null  where the_Sessionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update the_Session set LockSessionID =null  where the_Sessionid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  the_Session_SINIT /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=the_Session_parent_T( aCURSESSION,aROWID);
 aParentID:= the_Session_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update the_Session set securitystyleid =aStyleID where the_Sessionid = aRowID;
else 
 update the_Session set securitystyleid =aSecurityStyleID where the_Sessionid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  the_Session_propagate /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from the_Session where the_Sessionid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  LogReader_BRIEF  (
 aCURSESSION uuid,
 aLogReaderid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aLogReaderid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from LogReader where LogReaderID=aLogReaderID;
if existsCnt &gt;0
 then
  aBRIEF:= LogReader_BRIEF_F(aLogReaderid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  LogReader_DELETE /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aLogReaderid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from LogReader where LogReaderID=aLogReaderID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  LogReader_ISLOCKED( acursession,aLogReaderid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=LogReader');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aLogReaderid as varchar),   'LogReader',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='LogReader' and OwnerRowID=aLogReaderid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  LogReader 
  where  LogReaderID = aLogReaderID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Роботы журнала событий*/
 create or replace function  LogReader_SAVE /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aLogReaderid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aAutoStart
 integer/* Автоматизированный запуск *//* Автоматизированный запуск */
,aAutoProgid
 VARCHAR/* Класс для автоматического запуска *//* Класс для автоматического запуска */
,aReadMarker
 timestamp/* Дата последней прочитанной записи *//* Дата последней прочитанной записи */
,aStartInterval
 integer/* Интервал запуска (мин) *//* Интервал запуска (мин) */
,aLastStart
 timestamp/* Дата последнего запуска *//* Дата последнего запуска */
,aLastStop
 timestamp/* Дата последне останвки *//* Дата последне останвки */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from LogReader where LogReaderID=aLogReaderID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  LogReader_ISLOCKED( acursession,aLogReaderid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LogReader');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aLogReaderid as varchar),  'LogReader',
 'EDITROW',  aInstanceID);
 update  LogReader set ChangeStamp=localtimestamp
,
  Name=aName
,
  AutoStart=aAutoStart
,
  AutoProgid=aAutoProgid
,
  ReadMarker=aReadMarker
,
  StartInterval=aStartInterval
,
  LastStart=aLastStart
,
  LastStop=aLastStop
  where  LogReaderID = aLogReaderID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LogReader');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aLogReaderid as varchar),  'LogReader',
 'CREATEROW',  aInstanceID);
 insert into   LogReader
 (  LogReaderID 
,InstanceID
,Name

,AutoStart

,AutoProgid

,ReadMarker

,StartInterval

,LastStart

,LastStop

 ) values ( aLogReaderID 
,aInstanceID
,aName

,aAutoStart

,aAutoProgid

,aReadMarker

,aStartInterval

,aLastStart

,aLastStop

 ); 
 PERFORM LogReader_SINIT( aCURSESSION,aLogReaderid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  LogReader_PARENT_T /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  LogReader_PARENT_ID /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from LogReader where  LogReaderid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  LogReader_ISLOCKED /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from LogReader where LogReaderid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  LogReader_LOCK /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= LogReader_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= LogReader_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update LogReader set LockUserID =auserID ,LockSessionID =null where LogReaderid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update LogReader set LockUserID =null,LockSessionID =aCURSESSION  where LogReaderid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  LogReader_HCL /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  LogReader_UNLOCK /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= LogReader_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update LogReader set LockUserID =null  where LogReaderid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update LogReader set LockSessionID =null  where LogReaderid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  LogReader_SINIT /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=LogReader_parent_T( aCURSESSION,aROWID);
 aParentID:= LogReader_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update LogReader set securitystyleid =aStyleID where LogReaderid = aRowID;
else 
 update LogReader set securitystyleid =aSecurityStyleID where LogReaderid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  LogReader_propagate /*Программы, которые регистрируют себя как 
обработчики лога событий.*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from LogReader where LogReaderid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Verb_BRIEF  (
 aCURSESSION uuid,
 aVerbid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aVerbid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Verb where VerbID=aVerbID;
if existsCnt &gt;0
 then
  aBRIEF:= Verb_BRIEF_F(aVerbid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Verb_DELETE /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aVerbid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Verb where VerbID=aVerbID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Verb_ISLOCKED( acursession,aVerbid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Verb');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aVerbid as varchar),   'Verb',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Verb' and OwnerRowID=aVerbid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Verb 
  where  VerbID = aVerbID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Действия*/
 create or replace function  Verb_SAVE /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aVerbid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Verb where VerbID=aVerbID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Verb_ISLOCKED( acursession,aVerbid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Verb');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aVerbid as varchar),  'Verb',
 'EDITROW',  aInstanceID);
 update  Verb set ChangeStamp=localtimestamp
,
  Name=aName
  where  VerbID = aVerbID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Verb');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aVerbid as varchar),  'Verb',
 'CREATEROW',  aInstanceID);
 insert into   Verb
 (  VerbID 
,InstanceID
,Name

 ) values ( aVerbID 
,aInstanceID
,aName

 ); 
 PERFORM Verb_SINIT( aCURSESSION,aVerbid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Verb_PARENT_T /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Verb_PARENT_ID /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Verb where  Verbid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Verb_ISLOCKED /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Verb where Verbid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Verb_LOCK /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Verb_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Verb_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Verb set LockUserID =auserID ,LockSessionID =null where Verbid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Verb set LockUserID =null,LockSessionID =aCURSESSION  where Verbid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Verb_HCL /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Verb_UNLOCK /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Verb_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Verb set LockUserID =null  where Verbid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Verb set LockSessionID =null  where Verbid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Verb_SINIT /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Verb_parent_T( aCURSESSION,aROWID);
 aParentID:= Verb_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Verb set securitystyleid =aStyleID where Verbid = aRowID;
else 
 update Verb set securitystyleid =aSecurityStyleID where Verbid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Verb_propagate /*Защищаемые системой дейсвия*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Verb where Verbid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--ROLES" BlockCode=" create or replace function  ROLES_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='ROLES'
then
Open aCurs  for select ROLES_USER.ROLES_USERid ID from ROLES_USER where  ROLES_USER.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_USER_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ROLES_MAP.ROLES_MAPid ID from ROLES_MAP where  ROLES_MAP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_MAP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ROLES_DOC.ROLES_DOCid ID from ROLES_DOC where  ROLES_DOC.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_DOC_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ROLES_DEF.ROLES_DEFid ID from ROLES_DEF where  ROLES_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_DEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ROLES_REPORTS.ROLES_REPORTSid ID from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_REPORTS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ROLES_WP.ROLES_WPid ID from ROLES_WP where  ROLES_WP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_WP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'ROLES'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select ROLES_USER.ROLES_USERid ID from ROLES_USER where  ROLES_USER.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_USER where ROLES_USERid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_USER_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ROLES_MAP.ROLES_MAPid ID from ROLES_MAP where  ROLES_MAP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_MAP where ROLES_MAPid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_MAP_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ROLES_DOC.ROLES_DOCid ID from ROLES_DOC where  ROLES_DOC.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_DOC where ROLES_DOCid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_DOC_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ROLES_DEF.ROLES_DEFid ID from ROLES_DEF where  ROLES_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_DEF where ROLES_DEFid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_DEF_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ROLES_REPORTS.ROLES_REPORTSid ID from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_REPORTS where ROLES_REPORTSid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_REPORTS_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ROLES_WP.ROLES_WPid ID from ROLES_WP where  ROLES_WP.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_WP where ROLES_WPid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ROLES_WP_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  ROLES_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'ROLES'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select ROLES_USER.ROLES_USERid id from ROLES_USER where  ROLES_USER.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_USER_SINIT( acursession,aid,assid);
 PERFORM ROLES_USER_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ROLES_MAP.ROLES_MAPid id from ROLES_MAP where  ROLES_MAP.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_MAP_SINIT( acursession,aid,assid);
 PERFORM ROLES_MAP_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ROLES_DOC.ROLES_DOCid id from ROLES_DOC where  ROLES_DOC.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_DOC_SINIT( acursession,aid,assid);
 PERFORM ROLES_DOC_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ROLES_DEF.ROLES_DEFid id from ROLES_DEF where  ROLES_DEF.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_DEF_SINIT( acursession,aid,assid);
 PERFORM ROLES_DEF_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ROLES_REPORTS.ROLES_REPORTSid id from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_REPORTS_SINIT( acursession,aid,assid);
 PERFORM ROLES_REPORTS_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ROLES_WP.ROLES_WPid id from ROLES_WP where  ROLES_WP.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ROLES_WP_SINIT( acursession,aid,assid);
 PERFORM ROLES_WP_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  ROLES_USER_BRIEF  (
 aCURSESSION uuid,
 aROLES_USERid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_USERid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_USER_BRIEF_F(aROLES_USERid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_DELETE /*Пользователи*/ (
 aCURSESSION uuid,
 aROLES_USERid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_USER_ISLOCKED( acursession,aROLES_USERid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_USER');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_USERid as varchar),   'ROLES_USER',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_USER' and OwnerRowID=aROLES_USERid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_USER 
  where  ROLES_USERID = aROLES_USERID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Пользователи*/
 create or replace function  ROLES_USER_SAVE /*Пользователи*/ (
 aCURSESSION uuid,
 aROLES_USERid uuid,
ainstanceid uuid 
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_USER_ISLOCKED( acursession,aROLES_USERid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_USER');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_USERid as varchar),  'ROLES_USER',
 'EDITROW',  aInstanceID);
 update  ROLES_USER set ChangeStamp=localtimestamp
,
  TheUser=aTheUser
  where  ROLES_USERID = aROLES_USERID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;
 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_USER');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_USERid as varchar),  'ROLES_USER',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_USER
 (  ROLES_USERID 
,InstanceID
,TheUser

 ) values ( aROLES_USERID 
,aInstanceID
,aTheUser

 ); 
 PERFORM ROLES_USER_SINIT( aCURSESSION,aROLES_USERid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;
 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_USER_PARENT_T /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_USER_PARENT_ID /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_USER where  ROLES_USERid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_ISLOCKED /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_USER where ROLES_USERid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_LOCK /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_USER_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_USER_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_USER set LockUserID =auserID ,LockSessionID =null where ROLES_USERid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_USER set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_USERid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_HCL /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_UNLOCK /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_USER_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_USER set LockUserID =null  where ROLES_USERid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_USER set LockSessionID =null  where ROLES_USERid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_SINIT /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_USER_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_USER_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_USER set securitystyleid =aStyleID where ROLES_USERid = aRowID;
else 
 update ROLES_USER set securitystyleid =aSecurityStyleID where ROLES_USERid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_USER_propagate /*Пользователи*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_USER where ROLES_USERid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_MAP_BRIEF  (
 aCURSESSION uuid,
 aROLES_MAPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_MAPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_MAP_BRIEF_F(aROLES_MAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_DELETE /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aROLES_MAPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_MAP_ISLOCKED( acursession,aROLES_MAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_MAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_MAPid as varchar),   'ROLES_MAP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_MAP' and OwnerRowID=aROLES_MAPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_MAP 
  where  ROLES_MAPID = aROLES_MAPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отображение на группы защиты*/
 create or replace function  ROLES_MAP_SAVE /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aROLES_MAPid uuid,
ainstanceid uuid 
,aTheGroup
 uuid/* Группа *//* Группа */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_MAP_ISLOCKED( acursession,aROLES_MAPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_MAP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_MAPid as varchar),  'ROLES_MAP',
 'EDITROW',  aInstanceID);
 update  ROLES_MAP set ChangeStamp=localtimestamp
,
  TheGroup=aTheGroup
  where  ROLES_MAPID = aROLES_MAPID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_MAP where InstanceID=aInstanceID 
 and TheGroup=aTheGroup;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_MAP');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_MAP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_MAPid as varchar),  'ROLES_MAP',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_MAP
 (  ROLES_MAPID 
,InstanceID
,TheGroup

 ) values ( aROLES_MAPID 
,aInstanceID
,aTheGroup

 ); 
 PERFORM ROLES_MAP_SINIT( aCURSESSION,aROLES_MAPid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_MAP where InstanceID=aInstanceID 
 and TheGroup=aTheGroup;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_MAP');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_MAP_PARENT_T /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_MAP_PARENT_ID /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_MAP where  ROLES_MAPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_ISLOCKED /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_MAP where ROLES_MAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_LOCK /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_MAP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_MAP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_MAP set LockUserID =auserID ,LockSessionID =null where ROLES_MAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_MAP set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_MAPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_HCL /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_UNLOCK /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_MAP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_MAP set LockUserID =null  where ROLES_MAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_MAP set LockSessionID =null  where ROLES_MAPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_SINIT /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_MAP_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_MAP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_MAP set securitystyleid =aStyleID where ROLES_MAPid = aRowID;
else 
 update ROLES_MAP set securitystyleid =aSecurityStyleID where ROLES_MAPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_MAP_propagate /*Отображение на группы защиты*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_MAP where ROLES_MAPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_DOC_BRIEF  (
 aCURSESSION uuid,
 aROLES_DOCid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_DOCid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_DOC_BRIEF_F(aROLES_DOCid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_DELETE /**/ (
 aCURSESSION uuid,
 aROLES_DOCid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_DOC_ISLOCKED( acursession,aROLES_DOCid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DOC');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aROLES_DOCid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ROLES_DOC_STATE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_DOCid as varchar),   'ROLES_DOC',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_DOC' and OwnerRowID=aROLES_DOCid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_DOC 
  where  ROLES_DOCID = aROLES_DOCID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Доступные документы*/
 create or replace function  ROLES_DOC_SAVE /**/ (
 aCURSESSION uuid,
 aROLES_DOCid uuid,
ainstanceid uuid 
,aThe_Document
 uuid/* Тип документа *//* Тип документа */
,aThe_Denied
 integer/* Запрещен *//* Запрещен */
,aAllowDeleteDoc
 INTEGER/* Разрешено удаление *//* Разрешено удаление */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_DOC_ISLOCKED( acursession,aROLES_DOCid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_DOCid as varchar),  'ROLES_DOC',
 'EDITROW',  aInstanceID);
 update  ROLES_DOC set ChangeStamp=localtimestamp
,
  The_Document=aThe_Document
,
  The_Denied=aThe_Denied
,
  AllowDeleteDoc=aAllowDeleteDoc
  where  ROLES_DOCID = aROLES_DOCID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DOC where InstanceID=aInstanceID 
 and The_Document=aThe_Document;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DOC');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_DOCid as varchar),  'ROLES_DOC',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_DOC
 (  ROLES_DOCID 
,InstanceID
,The_Document

,The_Denied

,AllowDeleteDoc

 ) values ( aROLES_DOCID 
,aInstanceID
,aThe_Document

,aThe_Denied

,aAllowDeleteDoc

 ); 
 PERFORM ROLES_DOC_SINIT( aCURSESSION,aROLES_DOCid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DOC where InstanceID=aInstanceID 
 and The_Document=aThe_Document;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DOC');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_DOC_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_DOC where  ROLES_DOCid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DOC where ROLES_DOCid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DOC_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_DOC_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_DOC set LockUserID =auserID ,LockSessionID =null where ROLES_DOCid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DOC set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DOCid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ROLES_DOC_STATE where ROLES_DOC_STATEid=row_ROLES_DOC_STATE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ROLES_DOC_STATE_HCL (acursession,row_ROLES_DOC_STATE.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DOC_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DOC set LockUserID =null  where ROLES_DOCid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DOC set LockSessionID =null  where ROLES_DOCid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_DOC_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_DOC_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_DOC set securitystyleid =aStyleID where ROLES_DOCid = aRowID;
else 
 update ROLES_DOC set securitystyleid =aSecurityStyleID where ROLES_DOCid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_DOC where ROLES_DOCid=aRowid;
open aCurs for select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ROLES_DOC_STATE_SINIT( acursession,aid,assid);
 PERFORM  ROLES_DOC_STATE_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_DOC_STATE_BRIEF  (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_DOC_STATEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_DOC_STATE_BRIEF_F(aROLES_DOC_STATEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_DELETE /**/ (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_DOC_STATE_ISLOCKED( acursession,aROLES_DOC_STATEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_DOC_STATEid as varchar),   'ROLES_DOC_STATE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_DOC_STATE' and OwnerRowID=aROLES_DOC_STATEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_DOC_STATE 
  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Доступные состояния*/
 create or replace function  ROLES_DOC_STATE_SAVE /**/ (
 aCURSESSION uuid,
 aROLES_DOC_STATEid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aThe_State
 uuid/* Состояние *//* Состояние */
,aThe_Mode
 uuid/* Режим *//* Режим */
,aAllowDelete
 INTEGER/* Можно удалять *//* Можно удалять */
,aStateChangeDisabled
 INTEGER/* Запрещена смена состояния *//* Запрещена смена состояния */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_DOC_STATE_ISLOCKED( acursession,aROLES_DOC_STATEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_DOC_STATEid as varchar),  'ROLES_DOC_STATE',
 'EDITROW',  aInstanceID);
 update  ROLES_DOC_STATE set ChangeStamp=localtimestamp
,
  The_State=aThe_State
,
  The_Mode=aThe_Mode
,
  AllowDelete=aAllowDelete
,
  StateChangeDisabled=aStateChangeDisabled
  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= ROLES_DOC_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_DOC_STATEid as varchar),  'ROLES_DOC_STATE',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_DOC_STATE
 (  ROLES_DOC_STATEID 
,ParentStructRowID
,The_State

,The_Mode

,AllowDelete

,StateChangeDisabled

 ) values ( aROLES_DOC_STATEID 
,aParentStructRowID
,aThe_State

,aThe_Mode

,aAllowDelete

,aStateChangeDisabled

 ); 
 PERFORM ROLES_DOC_STATE_SINIT( aCURSESSION,aROLES_DOC_STATEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_DOC_STATE_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'ROLES_DOC';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DOC_STATE_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ROLES_DOC_STATE where  ROLES_DOC_STATEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DOC_STATE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_DOC_STATE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_DOC_STATE set LockUserID =auserID ,LockSessionID =null where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DOC_STATE set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DOC_STATE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DOC_STATE set LockUserID =null  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DOC_STATE set LockSessionID =null  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_DOC_STATE_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_DOC_STATE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_DOC_STATE set securitystyleid =aStyleID where ROLES_DOC_STATEid = aRowID;
else 
 update ROLES_DOC_STATE set securitystyleid =aSecurityStyleID where ROLES_DOC_STATEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DOC_STATE_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_DEF_BRIEF  (
 aCURSESSION uuid,
 aROLES_DEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_DEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_DEF_BRIEF_F(aROLES_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_DELETE /*Определение роли*/ (
 aCURSESSION uuid,
 aROLES_DEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_DEF_ISLOCKED( acursession,aROLES_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_DEFid as varchar),   'ROLES_DEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_DEF' and OwnerRowID=aROLES_DEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_DEF 
  where  ROLES_DEFID = aROLES_DEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Определение роли*/
 create or replace function  ROLES_DEF_SAVE /*Определение роли*/ (
 aCURSESSION uuid,
 aROLES_DEFid uuid,
ainstanceid uuid 
,aname
 VARCHAR/* Название *//* Название */
,aTheComment
 TEXT/* Описание *//* Описание */
,aRightsSet_Denied
 INTEGER/* Настройка прав запрещена *//* Настройка прав запрещена */
,aFormCFG_Denied
 INTEGER/* Настройки форм запрещены *//* Настройки форм запрещены */
,aListCFG_Denied
 INTEGER/* Настройка журналов запрещена *//* Настройка журналов запрещена */
,aFileExch_Denied
 INTEGER/* Файловый обмен запрещен *//* Файловый обмен запрещен */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_DEF_ISLOCKED( acursession,aROLES_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_DEFid as varchar),  'ROLES_DEF',
 'EDITROW',  aInstanceID);
 update  ROLES_DEF set ChangeStamp=localtimestamp
,
  name=aname
,
  TheComment=aTheComment
,
  RightsSet_Denied=aRightsSet_Denied
,
  FormCFG_Denied=aFormCFG_Denied
,
  ListCFG_Denied=aListCFG_Denied
,
  FileExch_Denied=aFileExch_Denied
  where  ROLES_DEFID = aROLES_DEFID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DEF where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DEF');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DEF');
    return;
  end if;
select Count(*) into existsCnt from ROLES_DEF where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;ROLES_DEF&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_DEFid as varchar),  'ROLES_DEF',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_DEF
 (  ROLES_DEFID 
,InstanceID
,name

,TheComment

,RightsSet_Denied

,FormCFG_Denied

,ListCFG_Denied

,FileExch_Denied

 ) values ( aROLES_DEFID 
,aInstanceID
,aname

,aTheComment

,aRightsSet_Denied

,aFormCFG_Denied

,aListCFG_Denied

,aFileExch_Denied

 ); 
 PERFORM ROLES_DEF_SINIT( aCURSESSION,aROLES_DEFid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DEF where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DEF');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_DEF_PARENT_T /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_DEF_PARENT_ID /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_DEF where  ROLES_DEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_ISLOCKED /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DEF where ROLES_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_LOCK /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_DEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_DEF set LockUserID =auserID ,LockSessionID =null where ROLES_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DEF set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_HCL /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_UNLOCK /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_DEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DEF set LockUserID =null  where ROLES_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DEF set LockSessionID =null  where ROLES_DEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_SINIT /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_DEF_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_DEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_DEF set securitystyleid =aStyleID where ROLES_DEFid = aRowID;
else 
 update ROLES_DEF set securitystyleid =aSecurityStyleID where ROLES_DEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_DEF_propagate /*Определение роли*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_DEF where ROLES_DEFid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_REPORTS_BRIEF  (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_REPORTSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_REPORTS_BRIEF_F(aROLES_REPORTSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_DELETE /**/ (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_REPORTS_ISLOCKED( acursession,aROLES_REPORTSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_REPORTS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_REPORTSid as varchar),   'ROLES_REPORTS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_REPORTS' and OwnerRowID=aROLES_REPORTSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_REPORTS 
  where  ROLES_REPORTSID = aROLES_REPORTSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отчёты*/
 create or replace function  ROLES_REPORTS_SAVE /**/ (
 aCURSESSION uuid,
 aROLES_REPORTSid uuid,
ainstanceid uuid 
,aThe_Report
 uuid/* Отчёт *//* Отчёт */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_REPORTS_ISLOCKED( acursession,aROLES_REPORTSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_REPORTS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_REPORTSid as varchar),  'ROLES_REPORTS',
 'EDITROW',  aInstanceID);
 update  ROLES_REPORTS set ChangeStamp=localtimestamp
,
  The_Report=aThe_Report
  where  ROLES_REPORTSID = aROLES_REPORTSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_REPORTS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_REPORTSid as varchar),  'ROLES_REPORTS',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_REPORTS
 (  ROLES_REPORTSID 
,InstanceID
,The_Report

 ) values ( aROLES_REPORTSID 
,aInstanceID
,aThe_Report

 ); 
 PERFORM ROLES_REPORTS_SINIT( aCURSESSION,aROLES_REPORTSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_REPORTS_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_REPORTS_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_REPORTS where  ROLES_REPORTSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_REPORTS where ROLES_REPORTSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_REPORTS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_REPORTS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_REPORTS set LockUserID =auserID ,LockSessionID =null where ROLES_REPORTSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_REPORTS set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_REPORTSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_REPORTS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_REPORTS set LockUserID =null  where ROLES_REPORTSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_REPORTS set LockSessionID =null  where ROLES_REPORTSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_REPORTS_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_REPORTS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_REPORTS set securitystyleid =aStyleID where ROLES_REPORTSid = aRowID;
else 
 update ROLES_REPORTS set securitystyleid =aSecurityStyleID where ROLES_REPORTSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_REPORTS_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_REPORTS where ROLES_REPORTSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_WP_BRIEF  (
 aCURSESSION uuid,
 aROLES_WPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_WPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_WP_BRIEF_F(aROLES_WPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_DELETE /*Доступные приложения*/ (
 aCURSESSION uuid,
 aROLES_WPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_WP_ISLOCKED( acursession,aROLES_WPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_WP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aROLES_WPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ROLES_ACT_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_WPid as varchar),   'ROLES_WP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_WP' and OwnerRowID=aROLES_WPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_WP 
  where  ROLES_WPID = aROLES_WPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Доступные приложения*/
 create or replace function  ROLES_WP_SAVE /*Доступные приложения*/ (
 aCURSESSION uuid,
 aROLES_WPid uuid,
ainstanceid uuid 
,aWP
 uuid/* Приложение *//* Приложение */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_WP_ISLOCKED( acursession,aROLES_WPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_WP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_WPid as varchar),  'ROLES_WP',
 'EDITROW',  aInstanceID);
 update  ROLES_WP set ChangeStamp=localtimestamp
,
  WP=aWP
  where  ROLES_WPID = aROLES_WPID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_WP where InstanceID=aInstanceID 
 and WP=aWP;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_WP');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_WP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_WPid as varchar),  'ROLES_WP',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_WP
 (  ROLES_WPID 
,InstanceID
,WP

 ) values ( aROLES_WPID 
,aInstanceID
,aWP

 ); 
 PERFORM ROLES_WP_SINIT( aCURSESSION,aROLES_WPid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_WP where InstanceID=aInstanceID 
 and WP=aWP;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_WP');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_WP_PARENT_T /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_WP_PARENT_ID /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ROLES_WP where  ROLES_WPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_ISLOCKED /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_WP where ROLES_WPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_LOCK /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_WP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_WP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_WP set LockUserID =auserID ,LockSessionID =null where ROLES_WPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_WP set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_WPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_HCL /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ROLES_ACT where ROLES_ACTid=row_ROLES_ACT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ROLES_ACT_HCL (acursession,row_ROLES_ACT.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_UNLOCK /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_WP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_WP set LockUserID =null  where ROLES_WPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_WP set LockSessionID =null  where ROLES_WPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_SINIT /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_WP_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_WP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_WP set securitystyleid =aStyleID where ROLES_WPid = aRowID;
else 
 update ROLES_WP set securitystyleid =aSecurityStyleID where ROLES_WPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_WP_propagate /*Доступные приложения*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_WP where ROLES_WPid=aRowid;
open aCurs for select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ROLES_ACT_SINIT( acursession,aid,assid);
 PERFORM  ROLES_ACT_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  ROLES_ACT_BRIEF  (
 aCURSESSION uuid,
 aROLES_ACTid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aROLES_ACTid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0
 then
  aBRIEF:= ROLES_ACT_BRIEF_F(aROLES_ACTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_DELETE /*Допустимые действия*/ (
 aCURSESSION uuid,
 aROLES_ACTid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ROLES_ACT_ISLOCKED( acursession,aROLES_ACTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_ACT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aROLES_ACTid as varchar),   'ROLES_ACT',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ROLES_ACT' and OwnerRowID=aROLES_ACTid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ROLES_ACT 
  where  ROLES_ACTID = aROLES_ACTID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Допустимые действия*/
 create or replace function  ROLES_ACT_SAVE /*Допустимые действия*/ (
 aCURSESSION uuid,
 aROLES_ACTid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
, aParentRowid uuid 
,aAccesible
 integer/* Доступность *//* Доступность */
,aEntryPoints
 uuid/* Доступные действия *//* Доступные действия */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ROLES_ACT_ISLOCKED( acursession,aROLES_ACTid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_ACT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aROLES_ACTid as varchar),  'ROLES_ACT',
 'EDITROW',  aInstanceID);
 update  ROLES_ACT set ChangeStamp=localtimestamp
,ParentRowid= aParentRowid
,
  Accesible=aAccesible
,
  EntryPoints=aEntryPoints
  where  ROLES_ACTID = aROLES_ACTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= ROLES_WP_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_ACT');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aROLES_ACTid as varchar),  'ROLES_ACT',
 'CREATEROW',  aInstanceID);
 insert into   ROLES_ACT
 (  ROLES_ACTID 
,ParentRowid
,ParentStructRowID
,Accesible

,EntryPoints

 ) values ( aROLES_ACTID 
,aParentRowid
,aParentStructRowID
,aAccesible

,aEntryPoints

 ); 
 PERFORM ROLES_ACT_SINIT( aCURSESSION,aROLES_ACTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ROLES_ACT_PARENT_T /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'ROLES_WP';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ROLES_ACT_PARENT_ID /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ROLES_ACT where  ROLES_ACTid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_ISLOCKED /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_ACT where ROLES_ACTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_LOCK /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ROLES_ACT_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ROLES_ACT_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ROLES_ACT set LockUserID =auserID ,LockSessionID =null where ROLES_ACTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_ACT set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_ACTid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_HCL /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_UNLOCK /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ROLES_ACT_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_ACT set LockUserID =null  where ROLES_ACTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_ACT set LockSessionID =null  where ROLES_ACTid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_SINIT /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ROLES_ACT_parent_T( aCURSESSION,aROWID);
 aParentID:= ROLES_ACT_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ROLES_ACT set securitystyleid =aStyleID where ROLES_ACTid = aRowID;
else 
 update ROLES_ACT set securitystyleid =aSecurityStyleID where ROLES_ACTid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ROLES_ACT_propagate /*Допустимые действия*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ROLES_ACT where ROLES_ACTid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZwp" BlockCode=" create or replace function  MTZwp_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZwp'
then
Open aCurs  for select WorkPlace.WorkPlaceid ID from WorkPlace where  WorkPlace.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM WorkPlace_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select EntryPoints.EntryPointsid ID from EntryPoints where  EntryPoints.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM EntryPoints_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ARMTypes.ARMTypesid ID from ARMTypes where  ARMTypes.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ARMTypes_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select ARMJournal.ARMJournalid ID from ARMJournal where  ARMJournal.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ARMJournal_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZwp_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZwp'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select WorkPlace.WorkPlaceid ID from WorkPlace where  WorkPlace.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from WorkPlace where WorkPlaceid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= WorkPlace_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select EntryPoints.EntryPointsid ID from EntryPoints where  EntryPoints.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from EntryPoints where EntryPointsid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= EntryPoints_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ARMTypes.ARMTypesid ID from ARMTypes where  ARMTypes.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ARMTypes where ARMTypesid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ARMTypes_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select ARMJournal.ARMJournalid ID from ARMJournal where  ARMJournal.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ARMJournal where ARMJournalid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= ARMJournal_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZwp_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZwp'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select WorkPlace.WorkPlaceid id from WorkPlace where  WorkPlace.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM WorkPlace_SINIT( acursession,aid,assid);
 PERFORM WorkPlace_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select EntryPoints.EntryPointsid id from EntryPoints where  EntryPoints.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM EntryPoints_SINIT( acursession,aid,assid);
 PERFORM EntryPoints_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ARMTypes.ARMTypesid id from ARMTypes where  ARMTypes.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ARMTypes_SINIT( acursession,aid,assid);
 PERFORM ARMTypes_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select ARMJournal.ARMJournalid id from ARMJournal where  ARMJournal.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM ARMJournal_SINIT( acursession,aid,assid);
 PERFORM ARMJournal_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  WorkPlace_BRIEF  (
 aCURSESSION uuid,
 aWorkPlaceid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aWorkPlaceid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0
 then
  aBRIEF:= WorkPlace_BRIEF_F(aWorkPlaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_DELETE /*Арм*/ (
 aCURSESSION uuid,
 aWorkPlaceid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  WorkPlace_ISLOCKED( acursession,aWorkPlaceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=WorkPlace');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aWorkPlaceid as varchar),   'WorkPlace',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='WorkPlace' and OwnerRowID=aWorkPlaceid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  WorkPlace 
  where  WorkPlaceID = aWorkPlaceID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Арм*/
 create or replace function  WorkPlace_SAVE /*Арм*/ (
 aCURSESSION uuid,
 aWorkPlaceid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aTheVersion
 VARCHAR/* Версия *//* Версия */
,aThePlatform
 INTEGER/* Платформа реализации *//* Платформа реализации */
,aTheComment
 TEXT/* Примечание *//* Примечание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  WorkPlace_ISLOCKED( acursession,aWorkPlaceid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=WorkPlace');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aWorkPlaceid as varchar),  'WorkPlace',
 'EDITROW',  aInstanceID);
 update  WorkPlace set ChangeStamp=localtimestamp
,
  Name=aName
,
  Caption=aCaption
,
  TheVersion=aTheVersion
,
  ThePlatform=aThePlatform
,
  TheComment=aTheComment
  where  WorkPlaceID = aWorkPlaceID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=WorkPlace');
    return;
  end if;
select Count(*) into existsCnt from WorkPlace where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;WorkPlace&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aWorkPlaceid as varchar),  'WorkPlace',
 'CREATEROW',  aInstanceID);
 insert into   WorkPlace
 (  WorkPlaceID 
,InstanceID
,Name

,Caption

,TheVersion

,ThePlatform

,TheComment

 ) values ( aWorkPlaceID 
,aInstanceID
,aName

,aCaption

,aTheVersion

,aThePlatform

,aTheComment

 ); 
 PERFORM WorkPlace_SINIT( aCURSESSION,aWorkPlaceid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  WorkPlace_PARENT_T /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  WorkPlace_PARENT_ID /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from WorkPlace where  WorkPlaceid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_ISLOCKED /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from WorkPlace where WorkPlaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_LOCK /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= WorkPlace_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= WorkPlace_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update WorkPlace set LockUserID =auserID ,LockSessionID =null where WorkPlaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update WorkPlace set LockUserID =null,LockSessionID =aCURSESSION  where WorkPlaceid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_HCL /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  WorkPlace_UNLOCK /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= WorkPlace_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update WorkPlace set LockUserID =null  where WorkPlaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update WorkPlace set LockSessionID =null  where WorkPlaceid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_SINIT /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=WorkPlace_parent_T( aCURSESSION,aROWID);
 aParentID:= WorkPlace_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update WorkPlace set securitystyleid =aStyleID where WorkPlaceid = aRowID;
else 
 update WorkPlace set securitystyleid =aSecurityStyleID where WorkPlaceid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  WorkPlace_propagate /*Арм*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from WorkPlace where WorkPlaceid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  EntryPoints_BRIEF  (
 aCURSESSION uuid,
 aEntryPointsid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aEntryPointsid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0
 then
  aBRIEF:= EntryPoints_BRIEF_F(aEntryPointsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_DELETE /*Меню*/ (
 aCURSESSION uuid,
 aEntryPointsid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  EntryPoints_ISLOCKED( acursession,aEntryPointsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=EntryPoints');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aEntryPointsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  EPFilterLink_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aEntryPointsid as varchar),   'EntryPoints',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='EntryPoints' and OwnerRowID=aEntryPointsid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  EntryPoints 
  where  EntryPointsID = aEntryPointsID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Меню*/
 create or replace function  EntryPoints_SAVE /*Меню*/ (
 aCURSESSION uuid,
 aEntryPointsid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,asequence
 integer/* Последовательность *//* Последовательность */
,aName
 VARCHAR/* Название *//* Название */
,aCaption
 VARCHAR/* Заголовок *//* Заголовок */
,aAsToolbarItem
 INTEGER/* Включить в тулбар *//* Включить в тулбар */
,aActionType
 INTEGER/* Вариант действия *//* Вариант действия */
,aTheFilter
 uuid/* Фильтр *//* Фильтр */
,aJournal
 uuid/* Журнал *//* Журнал */
,aReport
 uuid/* Отчет *//* Отчет */
,aDocument
 uuid/* Документ *//* Документ */
,aMethod
 uuid/* Метод *//* Метод */
,aIconFile
 VARCHAR/* Файл картинки *//* Файл картинки */
,aTheExtention
 uuid/* Расширение *//* Расширение */
,aARM
 uuid/* АРМ *//* АРМ */
,aTheComment
 TEXT/* Примечание *//* Примечание */
,aObjectType
 uuid/* Тип документа *//* Тип документа */
,aJournalFixedQuery
 TEXT/* Ограничения к журналу *//* Ограничения к журналу */
,aAllowAdd
 INTEGER/* Разрешено добавление *//* Разрешено добавление */
,aAllowEdit
 INTEGER/* Разрешено редактирование *//* Разрешено редактирование */
,aAllowDel
 INTEGER/* Рарешено удаление *//* Рарешено удаление */
,aAllowFilter
 INTEGER/* Разрешен фильтр *//* Разрешен фильтр */
,aAllowPrint
 INTEGER/* Разрешена печать *//* Разрешена печать */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  EntryPoints_ISLOCKED( acursession,aEntryPointsid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EntryPoints');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aEntryPointsid as varchar),  'EntryPoints',
 'EDITROW',  aInstanceID);
 update  EntryPoints set ChangeStamp=localtimestamp
,ParentRowid= aParentRowid
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  AsToolbarItem=aAsToolbarItem
,
  ActionType=aActionType
,
  TheFilter=aTheFilter
,
  Journal=aJournal
,
  Report=aReport
,
  Document=aDocument
,
  Method=aMethod
,
  IconFile=aIconFile
,
  TheExtention=aTheExtention
,
  ARM=aARM
,
  TheComment=aTheComment
,
  ObjectType=aObjectType
,
  JournalFixedQuery=aJournalFixedQuery
,
  AllowAdd=aAllowAdd
,
  AllowEdit=aAllowEdit
,
  AllowDel=aAllowDel
,
  AllowFilter=aAllowFilter
,
  AllowPrint=aAllowPrint
  where  EntryPointsID = aEntryPointsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EntryPoints');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aEntryPointsid as varchar),  'EntryPoints',
 'CREATEROW',  aInstanceID);
 insert into   EntryPoints
 (  EntryPointsID 
,ParentRowid
,InstanceID
,sequence

,Name

,Caption

,AsToolbarItem

,ActionType

,TheFilter

,Journal

,Report

,Document

,Method

,IconFile

,TheExtention

,ARM

,TheComment

,ObjectType

,JournalFixedQuery

,AllowAdd

,AllowEdit

,AllowDel

,AllowFilter

,AllowPrint

 ) values ( aEntryPointsID 
,aParentRowid
,aInstanceID
,asequence

,aName

,aCaption

,aAsToolbarItem

,aActionType

,aTheFilter

,aJournal

,aReport

,aDocument

,aMethod

,aIconFile

,aTheExtention

,aARM

,aTheComment

,aObjectType

,aJournalFixedQuery

,aAllowAdd

,aAllowEdit

,aAllowDel

,aAllowFilter

,aAllowPrint

 ); 
 PERFORM EntryPoints_SINIT( aCURSESSION,aEntryPointsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  EntryPoints_PARENT_T /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  EntryPoints_PARENT_ID /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from EntryPoints where  EntryPointsid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_ISLOCKED /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from EntryPoints where EntryPointsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_LOCK /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= EntryPoints_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= EntryPoints_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update EntryPoints set LockUserID =auserID ,LockSessionID =null where EntryPointsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update EntryPoints set LockUserID =null,LockSessionID =aCURSESSION  where EntryPointsid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_HCL /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from EPFilterLink where EPFilterLinkid=row_EPFilterLink.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= EPFilterLink_HCL (acursession,row_EPFilterLink.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  EntryPoints_UNLOCK /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= EntryPoints_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update EntryPoints set LockUserID =null  where EntryPointsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update EntryPoints set LockSessionID =null  where EntryPointsid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_SINIT /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=EntryPoints_parent_T( aCURSESSION,aROWID);
 aParentID:= EntryPoints_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update EntryPoints set securitystyleid =aStyleID where EntryPointsid = aRowID;
else 
 update EntryPoints set securitystyleid =aSecurityStyleID where EntryPointsid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  EntryPoints_propagate /*Меню*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from EntryPoints where EntryPointsid=aRowid;
open aCurs for select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  EPFilterLink_SINIT( acursession,aid,assid);
 PERFORM  EPFilterLink_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  EPFilterLink_BRIEF  (
 aCURSESSION uuid,
 aEPFilterLinkid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aEPFilterLinkid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0
 then
  aBRIEF:= EPFilterLink_BRIEF_F(aEPFilterLinkid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_DELETE /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aEPFilterLinkid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  EPFilterLink_ISLOCKED( acursession,aEPFilterLinkid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=EPFilterLink');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aEPFilterLinkid as varchar),   'EPFilterLink',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='EPFilterLink' and OwnerRowID=aEPFilterLinkid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  EPFilterLink 
  where  EPFilterLinkID = aEPFilterLinkID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Привязка фильтра*/
 create or replace function  EPFilterLink_SAVE /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aEPFilterLinkid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aRowSource
 VARCHAR/* Источник *//* Источник */
,aTheExpression
 TEXT/* Выражение *//* Выражение */
,aFilterField
 VARCHAR/* Поле фильтра *//* Поле фильтра */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  EPFilterLink_ISLOCKED( acursession,aEPFilterLinkid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EPFilterLink');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aEPFilterLinkid as varchar),  'EPFilterLink',
 'EDITROW',  aInstanceID);
 update  EPFilterLink set ChangeStamp=localtimestamp
,
  RowSource=aRowSource
,
  TheExpression=aTheExpression
,
  FilterField=aFilterField
  where  EPFilterLinkID = aEPFilterLinkID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= EntryPoints_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EPFilterLink');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aEPFilterLinkid as varchar),  'EPFilterLink',
 'CREATEROW',  aInstanceID);
 insert into   EPFilterLink
 (  EPFilterLinkID 
,ParentStructRowID
,RowSource

,TheExpression

,FilterField

 ) values ( aEPFilterLinkID 
,aParentStructRowID
,aRowSource

,aTheExpression

,aFilterField

 ); 
 PERFORM EPFilterLink_SINIT( aCURSESSION,aEPFilterLinkid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  EPFilterLink_PARENT_T /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'EntryPoints';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  EPFilterLink_PARENT_ID /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from EPFilterLink where  EPFilterLinkid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_ISLOCKED /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from EPFilterLink where EPFilterLinkid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_LOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= EPFilterLink_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= EPFilterLink_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update EPFilterLink set LockUserID =auserID ,LockSessionID =null where EPFilterLinkid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update EPFilterLink set LockUserID =null,LockSessionID =aCURSESSION  where EPFilterLinkid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_HCL /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_UNLOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= EPFilterLink_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update EPFilterLink set LockUserID =null  where EPFilterLinkid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update EPFilterLink set LockSessionID =null  where EPFilterLinkid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_SINIT /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=EPFilterLink_parent_T( aCURSESSION,aROWID);
 aParentID:= EPFilterLink_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update EPFilterLink set securitystyleid =aStyleID where EPFilterLinkid = aRowID;
else 
 update EPFilterLink set securitystyleid =aSecurityStyleID where EPFilterLinkid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  EPFilterLink_propagate /*Привязка фильтра к журналу*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from EPFilterLink where EPFilterLinkid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ARMTypes_BRIEF  (
 aCURSESSION uuid,
 aARMTypesid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aARMTypesid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0
 then
  aBRIEF:= ARMTypes_BRIEF_F(aARMTypesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_DELETE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aARMTypesid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ARMTypes_ISLOCKED( acursession,aARMTypesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMTypes');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aARMTypesid as varchar),   'ARMTypes',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ARMTypes' and OwnerRowID=aARMTypesid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ARMTypes 
  where  ARMTypesID = aARMTypesID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Список типов*/
 create or replace function  ARMTypes_SAVE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aARMTypesid uuid,
ainstanceid uuid 
,aTheDocumentType
 uuid/* Тип документа *//* Тип документа */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ARMTypes_ISLOCKED( acursession,aARMTypesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMTypes');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aARMTypesid as varchar),  'ARMTypes',
 'EDITROW',  aInstanceID);
 update  ARMTypes set ChangeStamp=localtimestamp
,
  TheDocumentType=aTheDocumentType
  where  ARMTypesID = aARMTypesID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMTypes');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aARMTypesid as varchar),  'ARMTypes',
 'CREATEROW',  aInstanceID);
 insert into   ARMTypes
 (  ARMTypesID 
,InstanceID
,TheDocumentType

 ) values ( aARMTypesID 
,aInstanceID
,aTheDocumentType

 ); 
 PERFORM ARMTypes_SINIT( aCURSESSION,aARMTypesid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ARMTypes_PARENT_T /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ARMTypes_PARENT_ID /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ARMTypes where  ARMTypesid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_ISLOCKED /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMTypes where ARMTypesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_LOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ARMTypes_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ARMTypes_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ARMTypes set LockUserID =auserID ,LockSessionID =null where ARMTypesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMTypes set LockUserID =null,LockSessionID =aCURSESSION  where ARMTypesid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_HCL /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ARMTypes_UNLOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ARMTypes_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMTypes set LockUserID =null  where ARMTypesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMTypes set LockSessionID =null  where ARMTypesid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_SINIT /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ARMTypes_parent_T( aCURSESSION,aROWID);
 aParentID:= ARMTypes_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ARMTypes set securitystyleid =aStyleID where ARMTypesid = aRowID;
else 
 update ARMTypes set securitystyleid =aSecurityStyleID where ARMTypesid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ARMTypes_propagate /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ARMTypes where ARMTypesid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ARMJournal_BRIEF  (
 aCURSESSION uuid,
 aARMJournalid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aARMJournalid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0
 then
  aBRIEF:= ARMJournal_BRIEF_F(aARMJournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_DELETE /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aARMJournalid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ARMJournal_ISLOCKED( acursession,aARMJournalid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJournal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aARMJournalid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLADD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aARMJournalid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLREP_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs for select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aARMJournalid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLRUN_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aARMJournalid as varchar),   'ARMJournal',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ARMJournal' and OwnerRowID=aARMJournalid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ARMJournal 
  where  ARMJournalID = aARMJournalID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Поведение журналов*/
 create or replace function  ARMJournal_SAVE /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aARMJournalid uuid,
ainstanceid uuid 
,aTheJournal
 uuid/* Журнал *//* Журнал */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ARMJournal_ISLOCKED( acursession,aARMJournalid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJournal');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aARMJournalid as varchar),  'ARMJournal',
 'EDITROW',  aInstanceID);
 update  ARMJournal set ChangeStamp=localtimestamp
,
  TheJournal=aTheJournal
  where  ARMJournalID = aARMJournalID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJournal');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aARMJournalid as varchar),  'ARMJournal',
 'CREATEROW',  aInstanceID);
 insert into   ARMJournal
 (  ARMJournalID 
,InstanceID
,TheJournal

 ) values ( aARMJournalID 
,aInstanceID
,aTheJournal

 ); 
 PERFORM ARMJournal_SINIT( aCURSESSION,aARMJournalid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ARMJournal_PARENT_T /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ARMJournal_PARENT_ID /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from ARMJournal where  ARMJournalid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_ISLOCKED /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJournal where ARMJournalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_LOCK /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ARMJournal_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ARMJournal_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ARMJournal set LockUserID =auserID ,LockSessionID =null where ARMJournalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJournal set LockUserID =null,LockSessionID =aCURSESSION  where ARMJournalid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_HCL /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLADD where ARMJRNLADDid=row_ARMJRNLADD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ARMJRNLADD_HCL (acursession,row_ARMJRNLADD.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLREP where ARMJRNLREPid=row_ARMJRNLREP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ARMJRNLREP_HCL (acursession,row_ARMJRNLREP.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
open aCurs for select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLRUN where ARMJRNLRUNid=row_ARMJRNLRUN.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= ARMJRNLRUN_HCL (acursession,row_ARMJRNLRUN.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ARMJournal_UNLOCK /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ARMJournal_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJournal set LockUserID =null  where ARMJournalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJournal set LockSessionID =null  where ARMJournalid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_SINIT /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ARMJournal_parent_T( aCURSESSION,aROWID);
 aParentID:= ARMJournal_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ARMJournal set securitystyleid =aStyleID where ARMJournalid = aRowID;
else 
 update ARMJournal set securitystyleid =aSecurityStyleID where ARMJournalid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJournal_propagate /*Описание действий журанлов*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ARMJournal where ARMJournalid=aRowid;
open aCurs for select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLADD_SINIT( acursession,aid,assid);
 PERFORM  ARMJRNLADD_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLREP_SINIT( acursession,aid,assid);
 PERFORM  ARMJRNLREP_propagate( acursession,aid);
END LOOP;
close aCurs;
open aCurs for select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  ARMJRNLRUN_SINIT( acursession,aid,assid);
 PERFORM  ARMJRNLRUN_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  ARMJRNLADD_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLADDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aARMJRNLADDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0
 then
  aBRIEF:= ARMJRNLADD_BRIEF_F(aARMJRNLADDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_DELETE /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aARMJRNLADDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ARMJRNLADD_ISLOCKED( acursession,aARMJRNLADDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLADD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aARMJRNLADDid as varchar),   'ARMJRNLADD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ARMJRNLADD' and OwnerRowID=aARMJRNLADDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ARMJRNLADD 
  where  ARMJRNLADDID = aARMJRNLADDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Добавление*/
 create or replace function  ARMJRNLADD_SAVE /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aARMJRNLADDid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheExtention
 uuid/* Расширение *//* Расширение */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ARMJRNLADD_ISLOCKED( acursession,aARMJRNLADDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLADD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aARMJRNLADDid as varchar),  'ARMJRNLADD',
 'EDITROW',  aInstanceID);
 update  ARMJRNLADD set ChangeStamp=localtimestamp
,
  Name=aName
,
  TheExtention=aTheExtention
  where  ARMJRNLADDID = aARMJRNLADDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= ARMJournal_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLADD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aARMJRNLADDid as varchar),  'ARMJRNLADD',
 'CREATEROW',  aInstanceID);
 insert into   ARMJRNLADD
 (  ARMJRNLADDID 
,ParentStructRowID
,Name

,TheExtention

 ) values ( aARMJRNLADDID 
,aParentStructRowID
,aName

,aTheExtention

 ); 
 PERFORM ARMJRNLADD_SINIT( aCURSESSION,aARMJRNLADDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ARMJRNLADD_PARENT_T /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'ARMJournal';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLADD_PARENT_ID /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLADD where  ARMJRNLADDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_ISLOCKED /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLADD where ARMJRNLADDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_LOCK /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLADD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ARMJRNLADD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ARMJRNLADD set LockUserID =auserID ,LockSessionID =null where ARMJRNLADDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLADD set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLADDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_HCL /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_UNLOCK /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLADD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLADD set LockUserID =null  where ARMJRNLADDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLADD set LockSessionID =null  where ARMJRNLADDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_SINIT /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ARMJRNLADD_parent_T( aCURSESSION,aROWID);
 aParentID:= ARMJRNLADD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ARMJRNLADD set securitystyleid =aStyleID where ARMJRNLADDid = aRowID;
else 
 update ARMJRNLADD set securitystyleid =aSecurityStyleID where ARMJRNLADDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLADD_propagate /*Варианты обработки добавления*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ARMJRNLADD where ARMJRNLADDid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ARMJRNLREP_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLREPid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aARMJRNLREPid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0
 then
  aBRIEF:= ARMJRNLREP_BRIEF_F(aARMJRNLREPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_DELETE /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aARMJRNLREPid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ARMJRNLREP_ISLOCKED( acursession,aARMJRNLREPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLREP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aARMJRNLREPid as varchar),   'ARMJRNLREP',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ARMJRNLREP' and OwnerRowID=aARMJRNLREPid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ARMJRNLREP 
  where  ARMJRNLREPID = aARMJRNLREPID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отчеты*/
 create or replace function  ARMJRNLREP_SAVE /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aARMJRNLREPid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,arepname
 VARCHAR/* Название отчета *//* Название отчета */
,aTheReport
 uuid/* Отчет *//* Отчет */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ARMJRNLREP_ISLOCKED( acursession,aARMJRNLREPid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLREP');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aARMJRNLREPid as varchar),  'ARMJRNLREP',
 'EDITROW',  aInstanceID);
 update  ARMJRNLREP set ChangeStamp=localtimestamp
,
  repname=arepname
,
  TheReport=aTheReport
  where  ARMJRNLREPID = aARMJRNLREPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= ARMJournal_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLREP');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aARMJRNLREPid as varchar),  'ARMJRNLREP',
 'CREATEROW',  aInstanceID);
 insert into   ARMJRNLREP
 (  ARMJRNLREPID 
,ParentStructRowID
,repname

,TheReport

 ) values ( aARMJRNLREPID 
,aParentStructRowID
,arepname

,aTheReport

 ); 
 PERFORM ARMJRNLREP_SINIT( aCURSESSION,aARMJRNLREPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ARMJRNLREP_PARENT_T /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'ARMJournal';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLREP_PARENT_ID /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLREP where  ARMJRNLREPid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_ISLOCKED /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLREP where ARMJRNLREPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_LOCK /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLREP_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ARMJRNLREP_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ARMJRNLREP set LockUserID =auserID ,LockSessionID =null where ARMJRNLREPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLREP set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLREPid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_HCL /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_UNLOCK /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLREP_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLREP set LockUserID =null  where ARMJRNLREPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLREP set LockSessionID =null  where ARMJRNLREPid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_SINIT /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ARMJRNLREP_parent_T( aCURSESSION,aROWID);
 aParentID:= ARMJRNLREP_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ARMJRNLREP set securitystyleid =aStyleID where ARMJRNLREPid = aRowID;
else 
 update ARMJRNLREP set securitystyleid =aSecurityStyleID where ARMJRNLREPid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLREP_propagate /*Отчеты из журнала*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ARMJRNLREP where ARMJRNLREPid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  ARMJRNLRUN_BRIEF  (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aARMJRNLRUNid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0
 then
  aBRIEF:= ARMJRNLRUN_BRIEF_F(aARMJRNLRUNid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_DELETE /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  ARMJRNLRUN_ISLOCKED( acursession,aARMJRNLRUNid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLRUN');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aARMJRNLRUNid as varchar),   'ARMJRNLRUN',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='ARMJRNLRUN' and OwnerRowID=aARMJRNLRUNid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  ARMJRNLRUN 
  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Действия*/
 create or replace function  ARMJRNLRUN_SAVE /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aARMJRNLRUNid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aName
 VARCHAR/* Название *//* Название */
,aTheExtention
 uuid/* Расширение *//* Расширение */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  ARMJRNLRUN_ISLOCKED( acursession,aARMJRNLRUNid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLRUN');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aARMJRNLRUNid as varchar),  'ARMJRNLRUN',
 'EDITROW',  aInstanceID);
 update  ARMJRNLRUN set ChangeStamp=localtimestamp
,
  Name=aName
,
  TheExtention=aTheExtention
  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= ARMJournal_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLRUN');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aARMJRNLRUNid as varchar),  'ARMJRNLRUN',
 'CREATEROW',  aInstanceID);
 insert into   ARMJRNLRUN
 (  ARMJRNLRUNID 
,ParentStructRowID
,Name

,TheExtention

 ) values ( aARMJRNLRUNID 
,aParentStructRowID
,aName

,aTheExtention

 ); 
 PERFORM ARMJRNLRUN_SINIT( aCURSESSION,aARMJRNLRUNid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  ARMJRNLRUN_PARENT_T /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'ARMJournal';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  ARMJRNLRUN_PARENT_ID /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLRUN where  ARMJRNLRUNid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_ISLOCKED /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLRUN where ARMJRNLRUNid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_LOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLRUN_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= ARMJRNLRUN_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update ARMJRNLRUN set LockUserID =auserID ,LockSessionID =null where ARMJRNLRUNid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLRUN set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLRUNid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_HCL /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_UNLOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= ARMJRNLRUN_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLRUN set LockUserID =null  where ARMJRNLRUNid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLRUN set LockSessionID =null  where ARMJRNLRUNid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_SINIT /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=ARMJRNLRUN_parent_T( aCURSESSION,aROWID);
 aParentID:= ARMJRNLRUN_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update ARMJRNLRUN set securitystyleid =aStyleID where ARMJRNLRUNid = aRowID;
else 
 update ARMJRNLRUN set securitystyleid =aSecurityStyleID where ARMJRNLRUNid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  ARMJRNLRUN_propagate /*Дополнительные действия в журнале*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from ARMJRNLRUN where ARMJRNLRUNid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_DIC" BlockCode=" create or replace function  INV_DIC_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='INV_DIC'
then
Open aCurs  for select INVD_UPR.INVD_UPRid ID from INVD_UPR where  INVD_UPR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_UPR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_OTDEL.INVD_OTDELid ID from INVD_OTDEL where  INVD_OTDEL.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OTDEL_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_BLD.INVD_BLDid ID from INVD_BLD where  INVD_BLD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_BLD_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_DRAG.INVD_DRAGid ID from INVD_DRAG where  INVD_DRAG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_DRAG_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_ORG.INVD_ORGid ID from INVD_ORG where  INVD_ORG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_ORG_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_OSSTATUS.INVD_OSSTATUSid ID from INVD_OSSTATUS where  INVD_OSSTATUS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OSSTATUS_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_OWNER.INVD_OWNERid ID from INVD_OWNER where  INVD_OWNER.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OWNER_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_UR.INVD_URid ID from INVD_UR where  INVD_UR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_UR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_OSTYPE.INVD_OSTYPEid ID from INVD_OSTYPE where  INVD_OSTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OSTYPE_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select INVD_DIR.INVD_DIRid ID from INVD_DIR where  INVD_DIR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_DIR_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_DIC_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'INV_DIC'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select INVD_UPR.INVD_UPRid ID from INVD_UPR where  INVD_UPR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_UPR where INVD_UPRid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_UPR_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_OTDEL.INVD_OTDELid ID from INVD_OTDEL where  INVD_OTDEL.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_OTDEL where INVD_OTDELid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_OTDEL_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_BLD.INVD_BLDid ID from INVD_BLD where  INVD_BLD.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_BLD where INVD_BLDid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_BLD_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_DRAG.INVD_DRAGid ID from INVD_DRAG where  INVD_DRAG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_DRAG where INVD_DRAGid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_DRAG_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_ORG.INVD_ORGid ID from INVD_ORG where  INVD_ORG.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_ORG where INVD_ORGid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_ORG_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_OSSTATUS.INVD_OSSTATUSid ID from INVD_OSSTATUS where  INVD_OSSTATUS.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_OSSTATUS where INVD_OSSTATUSid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_OSSTATUS_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_OWNER.INVD_OWNERid ID from INVD_OWNER where  INVD_OWNER.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_OWNER where INVD_OWNERid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_OWNER_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_UR.INVD_URid ID from INVD_UR where  INVD_UR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_UR where INVD_URid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_UR_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_OSTYPE.INVD_OSTYPEid ID from INVD_OSTYPE where  INVD_OSTYPE.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_OSTYPE where INVD_OSTYPEid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_OSTYPE_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select INVD_DIR.INVD_DIRid ID from INVD_DIR where  INVD_DIR.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVD_DIR where INVD_DIRid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVD_DIR_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_DIC_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'INV_DIC'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select INVD_UPR.INVD_UPRid id from INVD_UPR where  INVD_UPR.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_UPR_SINIT( acursession,aid,assid);
 PERFORM INVD_UPR_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_OTDEL.INVD_OTDELid id from INVD_OTDEL where  INVD_OTDEL.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OTDEL_SINIT( acursession,aid,assid);
 PERFORM INVD_OTDEL_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_BLD.INVD_BLDid id from INVD_BLD where  INVD_BLD.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_BLD_SINIT( acursession,aid,assid);
 PERFORM INVD_BLD_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_DRAG.INVD_DRAGid id from INVD_DRAG where  INVD_DRAG.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_DRAG_SINIT( acursession,aid,assid);
 PERFORM INVD_DRAG_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_ORG.INVD_ORGid id from INVD_ORG where  INVD_ORG.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_ORG_SINIT( acursession,aid,assid);
 PERFORM INVD_ORG_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_OSSTATUS.INVD_OSSTATUSid id from INVD_OSSTATUS where  INVD_OSSTATUS.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OSSTATUS_SINIT( acursession,aid,assid);
 PERFORM INVD_OSSTATUS_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_OWNER.INVD_OWNERid id from INVD_OWNER where  INVD_OWNER.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OWNER_SINIT( acursession,aid,assid);
 PERFORM INVD_OWNER_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_UR.INVD_URid id from INVD_UR where  INVD_UR.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_UR_SINIT( acursession,aid,assid);
 PERFORM INVD_UR_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_OSTYPE.INVD_OSTYPEid id from INVD_OSTYPE where  INVD_OSTYPE.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_OSTYPE_SINIT( acursession,aid,assid);
 PERFORM INVD_OSTYPE_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select INVD_DIR.INVD_DIRid id from INVD_DIR where  INVD_DIR.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVD_DIR_SINIT( acursession,aid,assid);
 PERFORM INVD_DIR_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  INVD_UPR_BRIEF  (
 aCURSESSION uuid,
 aINVD_UPRid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_UPRid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_UPR where INVD_UPRID=aINVD_UPRID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_UPR_BRIEF_F(aINVD_UPRid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_DELETE /*Управление*/ (
 aCURSESSION uuid,
 aINVD_UPRid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_UPR where INVD_UPRID=aINVD_UPRID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_UPR_ISLOCKED( acursession,aINVD_UPRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_UPR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_UPRid as varchar),   'INVD_UPR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_UPR' and OwnerRowID=aINVD_UPRid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_UPR 
  where  INVD_UPRID = aINVD_UPRID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Управление*/
 create or replace function  INVD_UPR_SAVE /*Управление*/ (
 aCURSESSION uuid,
 aINVD_UPRid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_UPR where INVD_UPRID=aINVD_UPRID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_UPR_ISLOCKED( acursession,aINVD_UPRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_UPR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_UPRid as varchar),  'INVD_UPR',
 'EDITROW',  aInstanceID);
 update  INVD_UPR set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
  where  INVD_UPRID = aINVD_UPRID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_UPR where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_UPR');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_UPR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_UPRid as varchar),  'INVD_UPR',
 'CREATEROW',  aInstanceID);
 insert into   INVD_UPR
 (  INVD_UPRID 
,InstanceID
,Name

,Code

 ) values ( aINVD_UPRID 
,aInstanceID
,aName

,aCode

 ); 
 PERFORM INVD_UPR_SINIT( aCURSESSION,aINVD_UPRid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_UPR where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_UPR');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_UPR_PARENT_T /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UPR_PARENT_ID /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_UPR where  INVD_UPRid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_ISLOCKED /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_UPR where INVD_UPRid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_LOCK /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_UPR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_UPR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_UPR set LockUserID =auserID ,LockSessionID =null where INVD_UPRid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_UPR set LockUserID =null,LockSessionID =aCURSESSION  where INVD_UPRid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_HCL /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_UNLOCK /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_UPR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_UPR set LockUserID =null  where INVD_UPRid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_UPR set LockSessionID =null  where INVD_UPRid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_SINIT /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_UPR_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_UPR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_UPR set securitystyleid =aStyleID where INVD_UPRid = aRowID;
else 
 update INVD_UPR set securitystyleid =aSecurityStyleID where INVD_UPRid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_UPR_propagate /*Управление*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_UPR where INVD_UPRid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_OTDEL_BRIEF  (
 aCURSESSION uuid,
 aINVD_OTDELid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_OTDELid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_OTDEL where INVD_OTDELID=aINVD_OTDELID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_OTDEL_BRIEF_F(aINVD_OTDELid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_DELETE /*Отдел*/ (
 aCURSESSION uuid,
 aINVD_OTDELid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_OTDEL where INVD_OTDELID=aINVD_OTDELID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_OTDEL_ISLOCKED( acursession,aINVD_OTDELid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_OTDEL');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_OTDELid as varchar),   'INVD_OTDEL',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_OTDEL' and OwnerRowID=aINVD_OTDELid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_OTDEL 
  where  INVD_OTDELID = aINVD_OTDELID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Отдел*/
 create or replace function  INVD_OTDEL_SAVE /*Отдел*/ (
 aCURSESSION uuid,
 aINVD_OTDELid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_OTDEL where INVD_OTDELID=aINVD_OTDELID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_OTDEL_ISLOCKED( acursession,aINVD_OTDELid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OTDEL');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_OTDELid as varchar),  'INVD_OTDEL',
 'EDITROW',  aInstanceID);
 update  INVD_OTDEL set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
  where  INVD_OTDELID = aINVD_OTDELID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OTDEL where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OTDEL');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OTDEL');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_OTDELid as varchar),  'INVD_OTDEL',
 'CREATEROW',  aInstanceID);
 insert into   INVD_OTDEL
 (  INVD_OTDELID 
,InstanceID
,Name

,Code

 ) values ( aINVD_OTDELID 
,aInstanceID
,aName

,aCode

 ); 
 PERFORM INVD_OTDEL_SINIT( aCURSESSION,aINVD_OTDELid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OTDEL where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OTDEL');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_OTDEL_PARENT_T /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OTDEL_PARENT_ID /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_OTDEL where  INVD_OTDELid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_ISLOCKED /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_OTDEL where INVD_OTDELid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_LOCK /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_OTDEL_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_OTDEL_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_OTDEL set LockUserID =auserID ,LockSessionID =null where INVD_OTDELid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_OTDEL set LockUserID =null,LockSessionID =aCURSESSION  where INVD_OTDELid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_HCL /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_UNLOCK /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_OTDEL_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_OTDEL set LockUserID =null  where INVD_OTDELid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_OTDEL set LockSessionID =null  where INVD_OTDELid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_SINIT /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_OTDEL_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_OTDEL_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_OTDEL set securitystyleid =aStyleID where INVD_OTDELid = aRowID;
else 
 update INVD_OTDEL set securitystyleid =aSecurityStyleID where INVD_OTDELid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OTDEL_propagate /*Отдел*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_OTDEL where INVD_OTDELid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_BLD_BRIEF  (
 aCURSESSION uuid,
 aINVD_BLDid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_BLDid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_BLD where INVD_BLDID=aINVD_BLDID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_BLD_BRIEF_F(aINVD_BLDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_DELETE /*Здание*/ (
 aCURSESSION uuid,
 aINVD_BLDid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_BLD where INVD_BLDID=aINVD_BLDID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_BLD_ISLOCKED( acursession,aINVD_BLDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_BLD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_BLDid as varchar),   'INVD_BLD',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_BLD' and OwnerRowID=aINVD_BLDid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_BLD 
  where  INVD_BLDID = aINVD_BLDID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Здание*/
 create or replace function  INVD_BLD_SAVE /*Здание*/ (
 aCURSESSION uuid,
 aINVD_BLDid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aAddr
 TEXT/* Адрес *//* Адрес */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_BLD where INVD_BLDID=aINVD_BLDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_BLD_ISLOCKED( acursession,aINVD_BLDid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_BLD');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_BLDid as varchar),  'INVD_BLD',
 'EDITROW',  aInstanceID);
 update  INVD_BLD set ChangeStamp=localtimestamp
,
  Name=aName
,
  Addr=aAddr
  where  INVD_BLDID = aINVD_BLDID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_BLD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_BLD');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_BLD');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_BLDid as varchar),  'INVD_BLD',
 'CREATEROW',  aInstanceID);
 insert into   INVD_BLD
 (  INVD_BLDID 
,InstanceID
,Name

,Addr

 ) values ( aINVD_BLDID 
,aInstanceID
,aName

,aAddr

 ); 
 PERFORM INVD_BLD_SINIT( aCURSESSION,aINVD_BLDid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_BLD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_BLD');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_BLD_PARENT_T /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_BLD_PARENT_ID /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_BLD where  INVD_BLDid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_ISLOCKED /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_BLD where INVD_BLDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_LOCK /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_BLD_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_BLD_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_BLD set LockUserID =auserID ,LockSessionID =null where INVD_BLDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_BLD set LockUserID =null,LockSessionID =aCURSESSION  where INVD_BLDid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_HCL /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_UNLOCK /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_BLD_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_BLD set LockUserID =null  where INVD_BLDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_BLD set LockSessionID =null  where INVD_BLDid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_SINIT /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_BLD_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_BLD_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_BLD set securitystyleid =aStyleID where INVD_BLDid = aRowID;
else 
 update INVD_BLD set securitystyleid =aSecurityStyleID where INVD_BLDid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_BLD_propagate /*Здание*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_BLD where INVD_BLDid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_DRAG_BRIEF  (
 aCURSESSION uuid,
 aINVD_DRAGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_DRAGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_DRAG where INVD_DRAGID=aINVD_DRAGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_DRAG_BRIEF_F(aINVD_DRAGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_DELETE /**/ (
 aCURSESSION uuid,
 aINVD_DRAGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_DRAG where INVD_DRAGID=aINVD_DRAGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_DRAG_ISLOCKED( acursession,aINVD_DRAGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_DRAG');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_DRAGid as varchar),   'INVD_DRAG',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_DRAG' and OwnerRowID=aINVD_DRAGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_DRAG 
  where  INVD_DRAGID = aINVD_DRAGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Драг. металлы*/
 create or replace function  INVD_DRAG_SAVE /**/ (
 aCURSESSION uuid,
 aINVD_DRAGid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aedIzm
 VARCHAR/* Ед. изм. *//* Ед. изм. */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_DRAG where INVD_DRAGID=aINVD_DRAGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_DRAG_ISLOCKED( acursession,aINVD_DRAGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_DRAG');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_DRAGid as varchar),  'INVD_DRAG',
 'EDITROW',  aInstanceID);
 update  INVD_DRAG set ChangeStamp=localtimestamp
,
  Name=aName
,
  edIzm=aedIzm
  where  INVD_DRAGID = aINVD_DRAGID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_DRAG where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_DRAG');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_DRAG');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_DRAGid as varchar),  'INVD_DRAG',
 'CREATEROW',  aInstanceID);
 insert into   INVD_DRAG
 (  INVD_DRAGID 
,InstanceID
,Name

,edIzm

 ) values ( aINVD_DRAGID 
,aInstanceID
,aName

,aedIzm

 ); 
 PERFORM INVD_DRAG_SINIT( aCURSESSION,aINVD_DRAGid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_DRAG where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_DRAG');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_DRAG_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DRAG_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_DRAG where  INVD_DRAGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_DRAG where INVD_DRAGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_DRAG_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_DRAG_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_DRAG set LockUserID =auserID ,LockSessionID =null where INVD_DRAGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_DRAG set LockUserID =null,LockSessionID =aCURSESSION  where INVD_DRAGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_DRAG_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_DRAG set LockUserID =null  where INVD_DRAGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_DRAG set LockSessionID =null  where INVD_DRAGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_DRAG_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_DRAG_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_DRAG set securitystyleid =aStyleID where INVD_DRAGid = aRowID;
else 
 update INVD_DRAG set securitystyleid =aSecurityStyleID where INVD_DRAGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_DRAG_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_DRAG where INVD_DRAGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_ORG_BRIEF  (
 aCURSESSION uuid,
 aINVD_ORGid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_ORGid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_ORG where INVD_ORGID=aINVD_ORGID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_ORG_BRIEF_F(aINVD_ORGid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_DELETE /*Информация об организациях*/ (
 aCURSESSION uuid,
 aINVD_ORGid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_ORG where INVD_ORGID=aINVD_ORGID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_ORG_ISLOCKED( acursession,aINVD_ORGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_ORG');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_ORGid as varchar),   'INVD_ORG',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_ORG' and OwnerRowID=aINVD_ORGid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_ORG 
  where  INVD_ORGID = aINVD_ORGID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Свои юр. лица*/
 create or replace function  INVD_ORG_SAVE /*Информация об организациях*/ (
 aCURSESSION uuid,
 aINVD_ORGid uuid,
ainstanceid uuid 
,aNumPrefix
 integer/* Префикс инв. номера *//* Префикс инв. номера */
,aFullName
 VARCHAR/* Наименование *//* Наименование */
,aSortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aINN
 VARCHAR/* ИНН *//* ИНН */
,aKPP
 VARCHAR/* КПП *//* КПП */
,aUrAddr
 TEXT/* Юридический адрес *//* Юридический адрес */
,aFaktAddr
 TEXT/* Фактический адрес *//* Фактический адрес */
,aPhone
 VARCHAR/* Телефон \ Факс *//* Телефон \ Факс */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_ORG where INVD_ORGID=aINVD_ORGID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_ORG_ISLOCKED( acursession,aINVD_ORGid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_ORG');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_ORGid as varchar),  'INVD_ORG',
 'EDITROW',  aInstanceID);
 update  INVD_ORG set ChangeStamp=localtimestamp
,
  NumPrefix=aNumPrefix
,
  FullName=aFullName
,
  SortName=aSortName
,
  INN=aINN
,
  KPP=aKPP
,
  UrAddr=aUrAddr
,
  FaktAddr=aFaktAddr
,
  Phone=aPhone
  where  INVD_ORGID = aINVD_ORGID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_ORG where 1=1  
 and NumPrefix=aNumPrefix;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_ORG');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_ORG');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_ORGid as varchar),  'INVD_ORG',
 'CREATEROW',  aInstanceID);
 insert into   INVD_ORG
 (  INVD_ORGID 
,InstanceID
,NumPrefix

,FullName

,SortName

,INN

,KPP

,UrAddr

,FaktAddr

,Phone

 ) values ( aINVD_ORGID 
,aInstanceID
,aNumPrefix

,aFullName

,aSortName

,aINN

,aKPP

,aUrAddr

,aFaktAddr

,aPhone

 ); 
 PERFORM INVD_ORG_SINIT( aCURSESSION,aINVD_ORGid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_ORG where 1=1  
 and NumPrefix=aNumPrefix;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_ORG');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_ORG_PARENT_T /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_ORG_PARENT_ID /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_ORG where  INVD_ORGid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_ISLOCKED /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_ORG where INVD_ORGid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_LOCK /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_ORG_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_ORG_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_ORG set LockUserID =auserID ,LockSessionID =null where INVD_ORGid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_ORG set LockUserID =null,LockSessionID =aCURSESSION  where INVD_ORGid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_HCL /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_UNLOCK /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_ORG_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_ORG set LockUserID =null  where INVD_ORGid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_ORG set LockSessionID =null  where INVD_ORGid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_SINIT /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_ORG_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_ORG_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_ORG set securitystyleid =aStyleID where INVD_ORGid = aRowID;
else 
 update INVD_ORG set securitystyleid =aSecurityStyleID where INVD_ORGid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_ORG_propagate /*Информация об организациях*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_ORG where INVD_ORGid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_OSSTATUS_BRIEF  (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_OSSTATUSid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_OSSTATUS where INVD_OSSTATUSID=aINVD_OSSTATUSID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_OSSTATUS_BRIEF_F(aINVD_OSSTATUSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_DELETE /**/ (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_OSSTATUS where INVD_OSSTATUSID=aINVD_OSSTATUSID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_OSSTATUS_ISLOCKED( acursession,aINVD_OSSTATUSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_OSSTATUS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_OSSTATUSid as varchar),   'INVD_OSSTATUS',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_OSSTATUS' and OwnerRowID=aINVD_OSSTATUSid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_OSSTATUS 
  where  INVD_OSSTATUSID = aINVD_OSSTATUSID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Состояние ОС*/
 create or replace function  INVD_OSSTATUS_SAVE /**/ (
 aCURSESSION uuid,
 aINVD_OSSTATUSid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_OSSTATUS where INVD_OSSTATUSID=aINVD_OSSTATUSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_OSSTATUS_ISLOCKED( acursession,aINVD_OSSTATUSid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OSSTATUS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_OSSTATUSid as varchar),  'INVD_OSSTATUS',
 'EDITROW',  aInstanceID);
 update  INVD_OSSTATUS set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
  where  INVD_OSSTATUSID = aINVD_OSSTATUSID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OSSTATUS where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OSSTATUS');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OSSTATUS');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_OSSTATUSid as varchar),  'INVD_OSSTATUS',
 'CREATEROW',  aInstanceID);
 insert into   INVD_OSSTATUS
 (  INVD_OSSTATUSID 
,InstanceID
,Name

,Code

 ) values ( aINVD_OSSTATUSID 
,aInstanceID
,aName

,aCode

 ); 
 PERFORM INVD_OSSTATUS_SINIT( aCURSESSION,aINVD_OSSTATUSid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OSSTATUS where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OSSTATUS');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_OSSTATUS_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSSTATUS_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_OSSTATUS where  INVD_OSSTATUSid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_OSSTATUS where INVD_OSSTATUSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_OSSTATUS_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_OSSTATUS_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_OSSTATUS set LockUserID =auserID ,LockSessionID =null where INVD_OSSTATUSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_OSSTATUS set LockUserID =null,LockSessionID =aCURSESSION  where INVD_OSSTATUSid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_OSSTATUS_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_OSSTATUS set LockUserID =null  where INVD_OSSTATUSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_OSSTATUS set LockSessionID =null  where INVD_OSSTATUSid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_OSSTATUS_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_OSSTATUS_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_OSSTATUS set securitystyleid =aStyleID where INVD_OSSTATUSid = aRowID;
else 
 update INVD_OSSTATUS set securitystyleid =aSecurityStyleID where INVD_OSSTATUSid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSSTATUS_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_OSSTATUS where INVD_OSSTATUSid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_OWNER_BRIEF  (
 aCURSESSION uuid,
 aINVD_OWNERid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_OWNERid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_OWNER where INVD_OWNERID=aINVD_OWNERID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_OWNER_BRIEF_F(aINVD_OWNERid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_DELETE /*Владелец*/ (
 aCURSESSION uuid,
 aINVD_OWNERid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_OWNER where INVD_OWNERID=aINVD_OWNERID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_OWNER_ISLOCKED( acursession,aINVD_OWNERid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_OWNER');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_OWNERid as varchar),   'INVD_OWNER',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_OWNER' and OwnerRowID=aINVD_OWNERid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_OWNER 
  where  INVD_OWNERID = aINVD_OWNERID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Владелец*/
 create or replace function  INVD_OWNER_SAVE /*Владелец*/ (
 aCURSESSION uuid,
 aINVD_OWNERid uuid,
ainstanceid uuid 
,aFamiliName
 VARCHAR/* Фамилия *//* Фамилия */
,aName
 VARCHAR/* Имя *//* Имя */
,aSurName
 VARCHAR/* Отчество *//* Отчество */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_OWNER where INVD_OWNERID=aINVD_OWNERID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_OWNER_ISLOCKED( acursession,aINVD_OWNERid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OWNER');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_OWNERid as varchar),  'INVD_OWNER',
 'EDITROW',  aInstanceID);
 update  INVD_OWNER set ChangeStamp=localtimestamp
,
  FamiliName=aFamiliName
,
  Name=aName
,
  SurName=aSurName
  where  INVD_OWNERID = aINVD_OWNERID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OWNER where 1=1  
 and FamiliName=aFamiliName
 and Name=aName
 and SurName=aSurName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OWNER');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OWNER');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_OWNERid as varchar),  'INVD_OWNER',
 'CREATEROW',  aInstanceID);
 insert into   INVD_OWNER
 (  INVD_OWNERID 
,InstanceID
,FamiliName

,Name

,SurName

 ) values ( aINVD_OWNERID 
,aInstanceID
,aFamiliName

,aName

,aSurName

 ); 
 PERFORM INVD_OWNER_SINIT( aCURSESSION,aINVD_OWNERid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OWNER where 1=1  
 and FamiliName=aFamiliName
 and Name=aName
 and SurName=aSurName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OWNER');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_OWNER_PARENT_T /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OWNER_PARENT_ID /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_OWNER where  INVD_OWNERid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_ISLOCKED /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_OWNER where INVD_OWNERid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_LOCK /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_OWNER_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_OWNER_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_OWNER set LockUserID =auserID ,LockSessionID =null where INVD_OWNERid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_OWNER set LockUserID =null,LockSessionID =aCURSESSION  where INVD_OWNERid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_HCL /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_UNLOCK /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_OWNER_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_OWNER set LockUserID =null  where INVD_OWNERid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_OWNER set LockSessionID =null  where INVD_OWNERid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_SINIT /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_OWNER_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_OWNER_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_OWNER set securitystyleid =aStyleID where INVD_OWNERid = aRowID;
else 
 update INVD_OWNER set securitystyleid =aSecurityStyleID where INVD_OWNERid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OWNER_propagate /*Владелец*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_OWNER where INVD_OWNERid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_UR_BRIEF  (
 aCURSESSION uuid,
 aINVD_URid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_URid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_UR where INVD_URID=aINVD_URID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_UR_BRIEF_F(aINVD_URid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_DELETE /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aINVD_URid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_UR where INVD_URID=aINVD_URID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_UR_ISLOCKED( acursession,aINVD_URid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_UR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_URid as varchar),   'INVD_UR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_UR' and OwnerRowID=aINVD_URid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_UR 
  where  INVD_URID = aINVD_URID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Юридическое лицо*/
 create or replace function  INVD_UR_SAVE /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aINVD_URid uuid,
ainstanceid uuid 
,aFullName
 VARCHAR/* Наименование *//* Наименование */
,aSortName
 VARCHAR/* Краткое наименование *//* Краткое наименование */
,aINN
 VARCHAR/* ИНН *//* ИНН */
,aKPP
 VARCHAR/* КПП *//* КПП */
,aUrAddr
 TEXT/* Юридический адрес *//* Юридический адрес */
,aFaktAddr
 TEXT/* Фактический адрес *//* Фактический адрес */
,aPhone
 VARCHAR/* Телефон \ Факс *//* Телефон \ Факс */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_UR where INVD_URID=aINVD_URID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_UR_ISLOCKED( acursession,aINVD_URid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_UR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_URid as varchar),  'INVD_UR',
 'EDITROW',  aInstanceID);
 update  INVD_UR set ChangeStamp=localtimestamp
,
  FullName=aFullName
,
  SortName=aSortName
,
  INN=aINN
,
  KPP=aKPP
,
  UrAddr=aUrAddr
,
  FaktAddr=aFaktAddr
,
  Phone=aPhone
  where  INVD_URID = aINVD_URID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_UR where 1=1  
 and KPP=aKPP
 and FullName=aFullName
 and INN=aINN;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_UR');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_UR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_URid as varchar),  'INVD_UR',
 'CREATEROW',  aInstanceID);
 insert into   INVD_UR
 (  INVD_URID 
,InstanceID
,FullName

,SortName

,INN

,KPP

,UrAddr

,FaktAddr

,Phone

 ) values ( aINVD_URID 
,aInstanceID
,aFullName

,aSortName

,aINN

,aKPP

,aUrAddr

,aFaktAddr

,aPhone

 ); 
 PERFORM INVD_UR_SINIT( aCURSESSION,aINVD_URid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_UR where 1=1  
 and KPP=aKPP
 and FullName=aFullName
 and INN=aINN;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_UR');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_UR_PARENT_T /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_UR_PARENT_ID /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_UR where  INVD_URid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_ISLOCKED /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_UR where INVD_URid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_LOCK /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_UR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_UR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_UR set LockUserID =auserID ,LockSessionID =null where INVD_URid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_UR set LockUserID =null,LockSessionID =aCURSESSION  where INVD_URid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_HCL /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_UR_UNLOCK /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_UR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_UR set LockUserID =null  where INVD_URid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_UR set LockSessionID =null  where INVD_URid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_SINIT /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_UR_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_UR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_UR set securitystyleid =aStyleID where INVD_URid = aRowID;
else 
 update INVD_UR set securitystyleid =aSecurityStyleID where INVD_URid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_UR_propagate /*Юридическое лицо*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_UR where INVD_URid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_OSTYPE_BRIEF  (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_OSTYPEid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_OSTYPE where INVD_OSTYPEID=aINVD_OSTYPEID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_OSTYPE_BRIEF_F(aINVD_OSTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_DELETE /*Тип основного средства*/ (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_OSTYPE where INVD_OSTYPEID=aINVD_OSTYPEID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_OSTYPE_ISLOCKED( acursession,aINVD_OSTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_OSTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_OSTYPEid as varchar),   'INVD_OSTYPE',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_OSTYPE' and OwnerRowID=aINVD_OSTYPEid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_OSTYPE 
  where  INVD_OSTYPEID = aINVD_OSTYPEID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Тип основного средства*/
 create or replace function  INVD_OSTYPE_SAVE /*Тип основного средства*/ (
 aCURSESSION uuid,
 aINVD_OSTYPEid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
,aShowTech
 INTEGER/* Отображать тех. инф. *//* Отображать тех. инф. */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_OSTYPE where INVD_OSTYPEID=aINVD_OSTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_OSTYPE_ISLOCKED( acursession,aINVD_OSTYPEid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OSTYPE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_OSTYPEid as varchar),  'INVD_OSTYPE',
 'EDITROW',  aInstanceID);
 update  INVD_OSTYPE set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
,
  ShowTech=aShowTech
  where  INVD_OSTYPEID = aINVD_OSTYPEID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OSTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OSTYPE');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_OSTYPE');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_OSTYPEid as varchar),  'INVD_OSTYPE',
 'CREATEROW',  aInstanceID);
 insert into   INVD_OSTYPE
 (  INVD_OSTYPEID 
,InstanceID
,Name

,Code

,ShowTech

 ) values ( aINVD_OSTYPEID 
,aInstanceID
,aName

,aCode

,aShowTech

 ); 
 PERFORM INVD_OSTYPE_SINIT( aCURSESSION,aINVD_OSTYPEid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_OSTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_OSTYPE');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_OSTYPE_PARENT_T /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_OSTYPE_PARENT_ID /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_OSTYPE where  INVD_OSTYPEid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_ISLOCKED /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_OSTYPE where INVD_OSTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_LOCK /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_OSTYPE_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_OSTYPE_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_OSTYPE set LockUserID =auserID ,LockSessionID =null where INVD_OSTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_OSTYPE set LockUserID =null,LockSessionID =aCURSESSION  where INVD_OSTYPEid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_HCL /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_UNLOCK /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_OSTYPE_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_OSTYPE set LockUserID =null  where INVD_OSTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_OSTYPE set LockSessionID =null  where INVD_OSTYPEid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_SINIT /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_OSTYPE_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_OSTYPE_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_OSTYPE set securitystyleid =aStyleID where INVD_OSTYPEid = aRowID;
else 
 update INVD_OSTYPE set securitystyleid =aSecurityStyleID where INVD_OSTYPEid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_OSTYPE_propagate /*Тип основного средства*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_OSTYPE where INVD_OSTYPEid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  INVD_DIR_BRIEF  (
 aCURSESSION uuid,
 aINVD_DIRid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVD_DIRid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVD_DIR where INVD_DIRID=aINVD_DIRID;
if existsCnt &gt;0
 then
  aBRIEF:= INVD_DIR_BRIEF_F(aINVD_DIRid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_DELETE /*Дирекция*/ (
 aCURSESSION uuid,
 aINVD_DIRid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVD_DIR where INVD_DIRID=aINVD_DIRID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVD_DIR_ISLOCKED( acursession,aINVD_DIRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVD_DIR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVD_DIRid as varchar),   'INVD_DIR',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVD_DIR' and OwnerRowID=aINVD_DIRid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVD_DIR 
  where  INVD_DIRID = aINVD_DIRID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Дирекция*/
 create or replace function  INVD_DIR_SAVE /*Дирекция*/ (
 aCURSESSION uuid,
 aINVD_DIRid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aCode
 VARCHAR/* Код *//* Код */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVD_DIR where INVD_DIRID=aINVD_DIRID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVD_DIR_ISLOCKED( acursession,aINVD_DIRid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_DIR');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVD_DIRid as varchar),  'INVD_DIR',
 'EDITROW',  aInstanceID);
 update  INVD_DIR set ChangeStamp=localtimestamp
,
  Name=aName
,
  Code=aCode
  where  INVD_DIRID = aINVD_DIRID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_DIR where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_DIR');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVD_DIR');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVD_DIRid as varchar),  'INVD_DIR',
 'CREATEROW',  aInstanceID);
 insert into   INVD_DIR
 (  INVD_DIRID 
,InstanceID
,Name

,Code

 ) values ( aINVD_DIRID 
,aInstanceID
,aName

,aCode

 ); 
 PERFORM INVD_DIR_SINIT( aCURSESSION,aINVD_DIRid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVD_DIR where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVD_DIR');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVD_DIR_PARENT_T /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVD_DIR_PARENT_ID /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVD_DIR where  INVD_DIRid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_ISLOCKED /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVD_DIR where INVD_DIRid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_LOCK /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVD_DIR_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVD_DIR_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVD_DIR set LockUserID =auserID ,LockSessionID =null where INVD_DIRid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVD_DIR set LockUserID =null,LockSessionID =aCURSESSION  where INVD_DIRid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_HCL /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_UNLOCK /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVD_DIR_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVD_DIR set LockUserID =null  where INVD_DIRid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVD_DIR set LockSessionID =null  where INVD_DIRid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_SINIT /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVD_DIR_parent_T( aCURSESSION,aROWID);
 aParentID:= INVD_DIR_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVD_DIR set securitystyleid =aStyleID where INVD_DIRid = aRowID;
else 
 update INVD_DIR set securitystyleid =aSecurityStyleID where INVD_DIRid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVD_DIR_propagate /*Дирекция*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVD_DIR where INVD_DIRid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZ_Install" BlockCode=" create or replace function  MTZ_Install_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZ_Install'
then
Open aCurs  for select MTZ_Inst_Build.MTZ_Inst_Buildid ID from MTZ_Inst_Build where  MTZ_Inst_Build.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Build_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select MTZ_Inst_Section.MTZ_Inst_Sectionid ID from MTZ_Inst_Section where  MTZ_Inst_Section.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Section_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select MTZ_Inst_Common.MTZ_Inst_Commonid ID from MTZ_Inst_Common where  MTZ_Inst_Common.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Common_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Install_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZ_Install'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select MTZ_Inst_Build.MTZ_Inst_Buildid ID from MTZ_Inst_Build where  MTZ_Inst_Build.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZ_Inst_Build where MTZ_Inst_Buildid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZ_Inst_Build_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select MTZ_Inst_Section.MTZ_Inst_Sectionid ID from MTZ_Inst_Section where  MTZ_Inst_Section.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZ_Inst_Section where MTZ_Inst_Sectionid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZ_Inst_Section_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select MTZ_Inst_Common.MTZ_Inst_Commonid ID from MTZ_Inst_Common where  MTZ_Inst_Common.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZ_Inst_Common where MTZ_Inst_Commonid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZ_Inst_Common_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZ_Install_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZ_Install'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select MTZ_Inst_Build.MTZ_Inst_Buildid id from MTZ_Inst_Build where  MTZ_Inst_Build.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Build_SINIT( acursession,aid,assid);
 PERFORM MTZ_Inst_Build_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select MTZ_Inst_Section.MTZ_Inst_Sectionid id from MTZ_Inst_Section where  MTZ_Inst_Section.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Section_SINIT( acursession,aid,assid);
 PERFORM MTZ_Inst_Section_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select MTZ_Inst_Common.MTZ_Inst_Commonid id from MTZ_Inst_Common where  MTZ_Inst_Common.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZ_Inst_Common_SINIT( acursession,aid,assid);
 PERFORM MTZ_Inst_Common_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  MTZ_Inst_Build_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ_Inst_Buildid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ_Inst_Build where MTZ_Inst_BuildID=aMTZ_Inst_BuildID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ_Inst_Build_BRIEF_F(aMTZ_Inst_Buildid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_DELETE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ_Inst_Build where MTZ_Inst_BuildID=aMTZ_Inst_BuildID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ_Inst_Build_ISLOCKED( acursession,aMTZ_Inst_Buildid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ_Inst_Build');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select MTZ_Inst_Build_Sec.MTZ_Inst_Build_Secid ID from MTZ_Inst_Build_Sec where  MTZ_Inst_Build_Sec.ParentStructRowID = aMTZ_Inst_Buildid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  MTZ_Inst_Build_Sec_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ_Inst_Buildid as varchar),   'MTZ_Inst_Build',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ_Inst_Build' and OwnerRowID=aMTZ_Inst_Buildid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ_Inst_Build 
  where  MTZ_Inst_BuildID = aMTZ_Inst_BuildID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Сборки*/
 create or replace function  MTZ_Inst_Build_SAVE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Buildid uuid,
ainstanceid uuid 
,aPRODUCT_NAME
 VARCHAR/* PRODUCT_NAME *//* PRODUCT_NAME */
,aPRODUCT_VERSION
 VARCHAR/* PRODUCT_VERSION *//* PRODUCT_VERSION */
,aPRODUCT_PUBLISHER
 VARCHAR/* PRODUCT_PUBLISHER *//* PRODUCT_PUBLISHER */
,aPRODUCT_WEB_SITE
 VARCHAR/* PRODUCT_WEB_SITE *//* PRODUCT_WEB_SITE */
,aLicensFilePath
 VARCHAR/* Файл с лицензионным соглашением *//* Файл с лицензионным соглашением */
,aMainFileRef
 uuid/* Главный файл *//* Главный файл */
,aInstallDir
 VARCHAR/* InstallDir *//* InstallDir */
,aShortCutDir
 VARCHAR/* ShortCutDir *//* ShortCutDir */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ_Inst_Build where MTZ_Inst_BuildID=aMTZ_Inst_BuildID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ_Inst_Build_ISLOCKED( acursession,aMTZ_Inst_Buildid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Build');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ_Inst_Buildid as varchar),  'MTZ_Inst_Build',
 'EDITROW',  aInstanceID);
 update  MTZ_Inst_Build set ChangeStamp=localtimestamp
,
  PRODUCT_NAME=aPRODUCT_NAME
,
  PRODUCT_VERSION=aPRODUCT_VERSION
,
  PRODUCT_PUBLISHER=aPRODUCT_PUBLISHER
,
  PRODUCT_WEB_SITE=aPRODUCT_WEB_SITE
,
  LicensFilePath=aLicensFilePath
,
  MainFileRef=aMainFileRef
,
  InstallDir=aInstallDir
,
  ShortCutDir=aShortCutDir
  where  MTZ_Inst_BuildID = aMTZ_Inst_BuildID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Build');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ_Inst_Buildid as varchar),  'MTZ_Inst_Build',
 'CREATEROW',  aInstanceID);
 insert into   MTZ_Inst_Build
 (  MTZ_Inst_BuildID 
,InstanceID
,PRODUCT_NAME

,PRODUCT_VERSION

,PRODUCT_PUBLISHER

,PRODUCT_WEB_SITE

,LicensFilePath

,MainFileRef

,InstallDir

,ShortCutDir

 ) values ( aMTZ_Inst_BuildID 
,aInstanceID
,aPRODUCT_NAME

,aPRODUCT_VERSION

,aPRODUCT_PUBLISHER

,aPRODUCT_WEB_SITE

,aLicensFilePath

,aMainFileRef

,aInstallDir

,aShortCutDir

 ); 
 PERFORM MTZ_Inst_Build_SINIT( aCURSESSION,aMTZ_Inst_Buildid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ_Inst_Build_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZ_Inst_Build where  MTZ_Inst_Buildid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ_Inst_Build where MTZ_Inst_Buildid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Build_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ_Inst_Build_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ_Inst_Build set LockUserID =auserID ,LockSessionID =null where MTZ_Inst_Buildid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ_Inst_Build set LockUserID =null,LockSessionID =aCURSESSION  where MTZ_Inst_Buildid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select MTZ_Inst_Build_Sec.MTZ_Inst_Build_Secid ID from MTZ_Inst_Build_Sec where  MTZ_Inst_Build_Sec.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from MTZ_Inst_Build_Sec where MTZ_Inst_Build_Secid=row_MTZ_Inst_Build_Sec.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= MTZ_Inst_Build_Sec_HCL (acursession,row_MTZ_Inst_Build_Sec.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Build_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ_Inst_Build set LockUserID =null  where MTZ_Inst_Buildid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ_Inst_Build set LockSessionID =null  where MTZ_Inst_Buildid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ_Inst_Build_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ_Inst_Build_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ_Inst_Build set securitystyleid =aStyleID where MTZ_Inst_Buildid = aRowID;
else 
 update MTZ_Inst_Build set securitystyleid =aSecurityStyleID where MTZ_Inst_Buildid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ_Inst_Build where MTZ_Inst_Buildid=aRowid;
open aCurs for select MTZ_Inst_Build_Sec.MTZ_Inst_Build_Secid ID from MTZ_Inst_Build_Sec where  MTZ_Inst_Build_Sec.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  MTZ_Inst_Build_Sec_SINIT( acursession,aid,assid);
 PERFORM  MTZ_Inst_Build_Sec_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZ_Inst_Build_Sec_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ_Inst_Build_Secid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ_Inst_Build_Sec where MTZ_Inst_Build_SecID=aMTZ_Inst_Build_SecID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ_Inst_Build_Sec_BRIEF_F(aMTZ_Inst_Build_Secid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_DELETE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ_Inst_Build_Sec where MTZ_Inst_Build_SecID=aMTZ_Inst_Build_SecID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ_Inst_Build_Sec_ISLOCKED( acursession,aMTZ_Inst_Build_Secid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ_Inst_Build_Sec');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ_Inst_Build_Secid as varchar),   'MTZ_Inst_Build_Sec',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ_Inst_Build_Sec' and OwnerRowID=aMTZ_Inst_Build_Secid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ_Inst_Build_Sec 
  where  MTZ_Inst_Build_SecID = aMTZ_Inst_Build_SecID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Секции*/
 create or replace function  MTZ_Inst_Build_Sec_SAVE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Build_Secid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheSection
 uuid/* Секция *//* Секция */
,aTheDescription
 VARCHAR/* Комментарий *//* Комментарий */
,aIsRewriteSectionDesc
 integer/* Перезаписывать комментарий секции *//* Перезаписывать комментарий секции */
,aSEQ
 integer/* Порядок (от 1 до ...) *//* Порядок (от 1 до ...) */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ_Inst_Build_Sec where MTZ_Inst_Build_SecID=aMTZ_Inst_Build_SecID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ_Inst_Build_Sec_ISLOCKED( acursession,aMTZ_Inst_Build_Secid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Build_Sec');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ_Inst_Build_Secid as varchar),  'MTZ_Inst_Build_Sec',
 'EDITROW',  aInstanceID);
 update  MTZ_Inst_Build_Sec set ChangeStamp=localtimestamp
,
  TheSection=aTheSection
,
  TheDescription=aTheDescription
,
  IsRewriteSectionDesc=aIsRewriteSectionDesc
,
  SEQ=aSEQ
  where  MTZ_Inst_Build_SecID = aMTZ_Inst_Build_SecID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= MTZ_Inst_Build_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Build_Sec');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ_Inst_Build_Secid as varchar),  'MTZ_Inst_Build_Sec',
 'CREATEROW',  aInstanceID);
 insert into   MTZ_Inst_Build_Sec
 (  MTZ_Inst_Build_SecID 
,ParentStructRowID
,TheSection

,TheDescription

,IsRewriteSectionDesc

,SEQ

 ) values ( aMTZ_Inst_Build_SecID 
,aParentStructRowID
,aTheSection

,aTheDescription

,aIsRewriteSectionDesc

,aSEQ

 ); 
 PERFORM MTZ_Inst_Build_Sec_SINIT( aCURSESSION,aMTZ_Inst_Build_Secid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ_Inst_Build_Sec_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'MTZ_Inst_Build';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Build_Sec_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from MTZ_Inst_Build_Sec where  MTZ_Inst_Build_Secid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ_Inst_Build_Sec where MTZ_Inst_Build_Secid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Build_Sec_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ_Inst_Build_Sec_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ_Inst_Build_Sec set LockUserID =auserID ,LockSessionID =null where MTZ_Inst_Build_Secid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ_Inst_Build_Sec set LockUserID =null,LockSessionID =aCURSESSION  where MTZ_Inst_Build_Secid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Build_Sec_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ_Inst_Build_Sec set LockUserID =null  where MTZ_Inst_Build_Secid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ_Inst_Build_Sec set LockSessionID =null  where MTZ_Inst_Build_Secid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ_Inst_Build_Sec_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ_Inst_Build_Sec_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ_Inst_Build_Sec set securitystyleid =aStyleID where MTZ_Inst_Build_Secid = aRowID;
else 
 update MTZ_Inst_Build_Sec set securitystyleid =aSecurityStyleID where MTZ_Inst_Build_Secid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Build_Sec_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ_Inst_Build_Sec where MTZ_Inst_Build_Secid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZ_Inst_Section_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ_Inst_Sectionid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ_Inst_Section where MTZ_Inst_SectionID=aMTZ_Inst_SectionID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ_Inst_Section_BRIEF_F(aMTZ_Inst_Sectionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_DELETE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ_Inst_Section where MTZ_Inst_SectionID=aMTZ_Inst_SectionID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ_Inst_Section_ISLOCKED( acursession,aMTZ_Inst_Sectionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ_Inst_Section');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select MTZ_Inst_Sec_Files.MTZ_Inst_Sec_Filesid ID from MTZ_Inst_Sec_Files where  MTZ_Inst_Sec_Files.ParentStructRowID = aMTZ_Inst_Sectionid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  MTZ_Inst_Sec_Files_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ_Inst_Sectionid as varchar),   'MTZ_Inst_Section',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ_Inst_Section' and OwnerRowID=aMTZ_Inst_Sectionid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ_Inst_Section 
  where  MTZ_Inst_SectionID = aMTZ_Inst_SectionID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Секции*/
 create or replace function  MTZ_Inst_Section_SAVE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Sectionid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название (Eng) *//* Название (Eng) */
,aIsVisible
 integer/* Видимая *//* Видимая */
,aTheDescription
 VARCHAR/* Комментарий (ToolTip) *//* Комментарий (ToolTip) */
,aIsNotDeletable
 integer/* Обязательная *//* Обязательная */
,aTheTargetPlatform
 INTEGER/* Целевая платформа *//* Целевая платформа */
,aIsCustomSection
 integer/* Custom Section *//* Custom Section */
,aCustomSectionInstall
 uuid/* Custom Section Install *//* Custom Section Install */
,aCustomSectionUnInstall
 uuid/* Custom Section UnInstall *//* Custom Section UnInstall */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ_Inst_Section where MTZ_Inst_SectionID=aMTZ_Inst_SectionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ_Inst_Section_ISLOCKED( acursession,aMTZ_Inst_Sectionid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Section');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ_Inst_Sectionid as varchar),  'MTZ_Inst_Section',
 'EDITROW',  aInstanceID);
 update  MTZ_Inst_Section set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  IsVisible=aIsVisible
,
  TheDescription=aTheDescription
,
  IsNotDeletable=aIsNotDeletable
,
  TheTargetPlatform=aTheTargetPlatform
,
  IsCustomSection=aIsCustomSection
,
  CustomSectionInstall=aCustomSectionInstall
,
  CustomSectionUnInstall=aCustomSectionUnInstall
  where  MTZ_Inst_SectionID = aMTZ_Inst_SectionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Section');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ_Inst_Sectionid as varchar),  'MTZ_Inst_Section',
 'CREATEROW',  aInstanceID);
 insert into   MTZ_Inst_Section
 (  MTZ_Inst_SectionID 
,InstanceID
,TheName

,IsVisible

,TheDescription

,IsNotDeletable

,TheTargetPlatform

,IsCustomSection

,CustomSectionInstall

,CustomSectionUnInstall

 ) values ( aMTZ_Inst_SectionID 
,aInstanceID
,aTheName

,aIsVisible

,aTheDescription

,aIsNotDeletable

,aTheTargetPlatform

,aIsCustomSection

,aCustomSectionInstall

,aCustomSectionUnInstall

 ); 
 PERFORM MTZ_Inst_Section_SINIT( aCURSESSION,aMTZ_Inst_Sectionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ_Inst_Section_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Section_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZ_Inst_Section where  MTZ_Inst_Sectionid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ_Inst_Section where MTZ_Inst_Sectionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Section_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ_Inst_Section_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ_Inst_Section set LockUserID =auserID ,LockSessionID =null where MTZ_Inst_Sectionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ_Inst_Section set LockUserID =null,LockSessionID =aCURSESSION  where MTZ_Inst_Sectionid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select MTZ_Inst_Sec_Files.MTZ_Inst_Sec_Filesid ID from MTZ_Inst_Sec_Files where  MTZ_Inst_Sec_Files.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_Filesid=row_MTZ_Inst_Sec_Files.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= MTZ_Inst_Sec_Files_HCL (acursession,row_MTZ_Inst_Sec_Files.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Section_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ_Inst_Section set LockUserID =null  where MTZ_Inst_Sectionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ_Inst_Section set LockSessionID =null  where MTZ_Inst_Sectionid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ_Inst_Section_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ_Inst_Section_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ_Inst_Section set securitystyleid =aStyleID where MTZ_Inst_Sectionid = aRowID;
else 
 update MTZ_Inst_Section set securitystyleid =aSecurityStyleID where MTZ_Inst_Sectionid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Section_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ_Inst_Section where MTZ_Inst_Sectionid=aRowid;
open aCurs for select MTZ_Inst_Sec_Files.MTZ_Inst_Sec_Filesid ID from MTZ_Inst_Sec_Files where  MTZ_Inst_Sec_Files.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  MTZ_Inst_Sec_Files_SINIT( acursession,aid,assid);
 PERFORM  MTZ_Inst_Sec_Files_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZ_Inst_Sec_Files_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ_Inst_Sec_Filesid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_FilesID=aMTZ_Inst_Sec_FilesID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ_Inst_Sec_Files_BRIEF_F(aMTZ_Inst_Sec_Filesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_DELETE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_FilesID=aMTZ_Inst_Sec_FilesID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ_Inst_Sec_Files_ISLOCKED( acursession,aMTZ_Inst_Sec_Filesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ_Inst_Sec_Files');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ_Inst_Sec_Filesid as varchar),   'MTZ_Inst_Sec_Files',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ_Inst_Sec_Files' and OwnerRowID=aMTZ_Inst_Sec_Filesid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ_Inst_Sec_Files 
  where  MTZ_Inst_Sec_FilesID = aMTZ_Inst_Sec_FilesID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Файлы секции*/
 create or replace function  MTZ_Inst_Sec_Files_SAVE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Sec_Filesid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aTheSource
 VARCHAR/* Файл или каталог *//* Файл или каталог */
,aIsCOM
 integer/* Является COM объектом *//* Является COM объектом */
,aHaveToRun
 integer/* Обязательно запустить *//* Обязательно запустить */
,aCommanLineParams
 VARCHAR/* Ключи запуска *//* Ключи запуска */
,aSysstemObject
 uuid/* Объект системы *//* Объект системы */
,aTheApplication
 uuid/* Приложение системы *//* Приложение системы */
,aSubDir
 VARCHAR/* Подкаталог *//* Подкаталог */
,aIsShortcut
 integer/* Ярлык в меню *//* Ярлык в меню */
,aShortcutName
 VARCHAR/* Имя ярлыка *//* Имя ярлыка */
,aShortCutInfo
 VARCHAR/* Комментярий ярлыка *//* Комментярий ярлыка */
,aDefaultInterface
 VARCHAR/* Интерфейс по умолчанию *//* Интерфейс по умолчанию */
,aHaveToRunDeinst
 integer/* Запустить при деинсталляции *//* Запустить при деинсталляции */
,aDeinstallComandParam
 VARCHAR/* Ключи деинсталляции *//* Ключи деинсталляции */
,aIsCustomScript
 integer/* Пользовательский скрипт (см. поле Файл или каталог) *//* Пользовательский скрипт (см. поле Файл или каталог) */
,aCustomScriptInstall
 uuid/* Custom Script Install *//* Custom Script Install */
,aCustomScriptUnInstall
 uuid/* Custom Script UnInstall *//* Custom Script UnInstall */
,aSEQ
 integer/* Порядок *//* Порядок */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_FilesID=aMTZ_Inst_Sec_FilesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ_Inst_Sec_Files_ISLOCKED( acursession,aMTZ_Inst_Sec_Filesid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Sec_Files');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ_Inst_Sec_Filesid as varchar),  'MTZ_Inst_Sec_Files',
 'EDITROW',  aInstanceID);
 update  MTZ_Inst_Sec_Files set ChangeStamp=localtimestamp
,
  TheSource=aTheSource
,
  IsCOM=aIsCOM
,
  HaveToRun=aHaveToRun
,
  CommanLineParams=aCommanLineParams
,
  SysstemObject=aSysstemObject
,
  TheApplication=aTheApplication
,
  SubDir=aSubDir
,
  IsShortcut=aIsShortcut
,
  ShortcutName=aShortcutName
,
  ShortCutInfo=aShortCutInfo
,
  DefaultInterface=aDefaultInterface
,
  HaveToRunDeinst=aHaveToRunDeinst
,
  DeinstallComandParam=aDeinstallComandParam
,
  IsCustomScript=aIsCustomScript
,
  CustomScriptInstall=aCustomScriptInstall
,
  CustomScriptUnInstall=aCustomScriptUnInstall
,
  SEQ=aSEQ
  where  MTZ_Inst_Sec_FilesID = aMTZ_Inst_Sec_FilesID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= MTZ_Inst_Section_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Sec_Files');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ_Inst_Sec_Filesid as varchar),  'MTZ_Inst_Sec_Files',
 'CREATEROW',  aInstanceID);
 insert into   MTZ_Inst_Sec_Files
 (  MTZ_Inst_Sec_FilesID 
,ParentStructRowID
,TheSource

,IsCOM

,HaveToRun

,CommanLineParams

,SysstemObject

,TheApplication

,SubDir

,IsShortcut

,ShortcutName

,ShortCutInfo

,DefaultInterface

,HaveToRunDeinst

,DeinstallComandParam

,IsCustomScript

,CustomScriptInstall

,CustomScriptUnInstall

,SEQ

 ) values ( aMTZ_Inst_Sec_FilesID 
,aParentStructRowID
,aTheSource

,aIsCOM

,aHaveToRun

,aCommanLineParams

,aSysstemObject

,aTheApplication

,aSubDir

,aIsShortcut

,aShortcutName

,aShortCutInfo

,aDefaultInterface

,aHaveToRunDeinst

,aDeinstallComandParam

,aIsCustomScript

,aCustomScriptInstall

,aCustomScriptUnInstall

,aSEQ

 ); 
 PERFORM MTZ_Inst_Sec_Files_SINIT( aCURSESSION,aMTZ_Inst_Sec_Filesid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ_Inst_Sec_Files_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'MTZ_Inst_Section';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Sec_Files_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from MTZ_Inst_Sec_Files where  MTZ_Inst_Sec_Filesid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_Filesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Sec_Files_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ_Inst_Sec_Files_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ_Inst_Sec_Files set LockUserID =auserID ,LockSessionID =null where MTZ_Inst_Sec_Filesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ_Inst_Sec_Files set LockUserID =null,LockSessionID =aCURSESSION  where MTZ_Inst_Sec_Filesid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Sec_Files_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ_Inst_Sec_Files set LockUserID =null  where MTZ_Inst_Sec_Filesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ_Inst_Sec_Files set LockSessionID =null  where MTZ_Inst_Sec_Filesid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ_Inst_Sec_Files_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ_Inst_Sec_Files_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ_Inst_Sec_Files set securitystyleid =aStyleID where MTZ_Inst_Sec_Filesid = aRowID;
else 
 update MTZ_Inst_Sec_Files set securitystyleid =aSecurityStyleID where MTZ_Inst_Sec_Filesid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Sec_Files_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ_Inst_Sec_Files where MTZ_Inst_Sec_Filesid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZ_Inst_Common_BRIEF  (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZ_Inst_Commonid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ_Inst_Common where MTZ_Inst_CommonID=aMTZ_Inst_CommonID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZ_Inst_Common_BRIEF_F(aMTZ_Inst_Commonid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_DELETE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ_Inst_Common where MTZ_Inst_CommonID=aMTZ_Inst_CommonID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZ_Inst_Common_ISLOCKED( acursession,aMTZ_Inst_Commonid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ_Inst_Common');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZ_Inst_Commonid as varchar),   'MTZ_Inst_Common',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZ_Inst_Common' and OwnerRowID=aMTZ_Inst_Commonid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZ_Inst_Common 
  where  MTZ_Inst_CommonID = aMTZ_Inst_CommonID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Пользовательские скрипты*/
 create or replace function  MTZ_Inst_Common_SAVE /**/ (
 aCURSESSION uuid,
 aMTZ_Inst_Commonid uuid,
ainstanceid uuid 
,aTheName
 VARCHAR/* Название *//* Название */
,aTheInstallScript
 TEXT/* Секция инсталляции *//* Секция инсталляции */
,aSEQ
 integer/* Порядок (сортировка) *//* Порядок (сортировка) */
,aIsDeinstallUSE
 integer/* Использовать при деинсталляции *//* Использовать при деинсталляции */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ_Inst_Common where MTZ_Inst_CommonID=aMTZ_Inst_CommonID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZ_Inst_Common_ISLOCKED( acursession,aMTZ_Inst_Commonid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Common');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZ_Inst_Commonid as varchar),  'MTZ_Inst_Common',
 'EDITROW',  aInstanceID);
 update  MTZ_Inst_Common set ChangeStamp=localtimestamp
,
  TheName=aTheName
,
  TheInstallScript=aTheInstallScript
,
  SEQ=aSEQ
,
  IsDeinstallUSE=aIsDeinstallUSE
  where  MTZ_Inst_CommonID = aMTZ_Inst_CommonID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ_Inst_Common');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZ_Inst_Commonid as varchar),  'MTZ_Inst_Common',
 'CREATEROW',  aInstanceID);
 insert into   MTZ_Inst_Common
 (  MTZ_Inst_CommonID 
,InstanceID
,TheName

,TheInstallScript

,SEQ

,IsDeinstallUSE

 ) values ( aMTZ_Inst_CommonID 
,aInstanceID
,aTheName

,aTheInstallScript

,aSEQ

,aIsDeinstallUSE

 ); 
 PERFORM MTZ_Inst_Common_SINIT( aCURSESSION,aMTZ_Inst_Commonid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZ_Inst_Common_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZ_Inst_Common_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZ_Inst_Common where  MTZ_Inst_Commonid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ_Inst_Common where MTZ_Inst_Commonid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Common_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZ_Inst_Common_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZ_Inst_Common set LockUserID =auserID ,LockSessionID =null where MTZ_Inst_Commonid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ_Inst_Common set LockUserID =null,LockSessionID =aCURSESSION  where MTZ_Inst_Commonid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZ_Inst_Common_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ_Inst_Common set LockUserID =null  where MTZ_Inst_Commonid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ_Inst_Common set LockSessionID =null  where MTZ_Inst_Commonid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZ_Inst_Common_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZ_Inst_Common_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZ_Inst_Common set securitystyleid =aStyleID where MTZ_Inst_Commonid = aRowID;
else 
 update MTZ_Inst_Common set securitystyleid =aSecurityStyleID where MTZ_Inst_Commonid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZ_Inst_Common_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZ_Inst_Common where MTZ_Inst_Commonid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--STDInfoStore" BlockCode=" create or replace function  STDInfoStore_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='STDInfoStore'
then
Open aCurs  for select InfoStoreDef.InfoStoreDefid ID from InfoStoreDef where  InfoStoreDef.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM InfoStoreDef_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select Folder.Folderid ID from Folder where  Folder.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Folder_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDInfoStore_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'STDInfoStore'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select InfoStoreDef.InfoStoreDefid ID from InfoStoreDef where  InfoStoreDef.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from InfoStoreDef where InfoStoreDefid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= InfoStoreDef_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select Folder.Folderid ID from Folder where  Folder.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Folder where Folderid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= Folder_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  STDInfoStore_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'STDInfoStore'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select InfoStoreDef.InfoStoreDefid id from InfoStoreDef where  InfoStoreDef.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM InfoStoreDef_SINIT( acursession,aid,assid);
 PERFORM InfoStoreDef_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select Folder.Folderid id from Folder where  Folder.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM Folder_SINIT( acursession,aid,assid);
 PERFORM Folder_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  InfoStoreDef_BRIEF  (
 aCURSESSION uuid,
 aInfoStoreDefid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aInfoStoreDefid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0
 then
  aBRIEF:= InfoStoreDef_BRIEF_F(aInfoStoreDefid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_DELETE /*Описание каталога*/ (
 aCURSESSION uuid,
 aInfoStoreDefid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  InfoStoreDef_ISLOCKED( acursession,aInfoStoreDefid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=InfoStoreDef');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aInfoStoreDefid as varchar),   'InfoStoreDef',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='InfoStoreDef' and OwnerRowID=aInfoStoreDefid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  InfoStoreDef 
  where  InfoStoreDefID = aInfoStoreDefID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание*/
 create or replace function  InfoStoreDef_SAVE /*Описание каталога*/ (
 aCURSESSION uuid,
 aInfoStoreDefid uuid,
ainstanceid uuid 
,aTheGroup
 uuid/* Группа *//* Группа */
,aName
 VARCHAR/* Название *//* Название */
,aInfoStoreType
 INTEGER/* Тип каталога *//* Тип каталога */
,aTheUser
 uuid/* Пользователь *//* Пользователь */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  InfoStoreDef_ISLOCKED( acursession,aInfoStoreDefid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=InfoStoreDef');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aInfoStoreDefid as varchar),  'InfoStoreDef',
 'EDITROW',  aInstanceID);
 update  InfoStoreDef set ChangeStamp=localtimestamp
,
  TheGroup=aTheGroup
,
  Name=aName
,
  InfoStoreType=aInfoStoreType
,
  TheUser=aTheUser
  where  InfoStoreDefID = aInfoStoreDefID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=InfoStoreDef');
    return;
  end if;
select Count(*) into existsCnt from InfoStoreDef where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;InfoStoreDef&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aInfoStoreDefid as varchar),  'InfoStoreDef',
 'CREATEROW',  aInstanceID);
 insert into   InfoStoreDef
 (  InfoStoreDefID 
,InstanceID
,TheGroup

,Name

,InfoStoreType

,TheUser

 ) values ( aInfoStoreDefID 
,aInstanceID
,aTheGroup

,aName

,aInfoStoreType

,aTheUser

 ); 
 PERFORM InfoStoreDef_SINIT( aCURSESSION,aInfoStoreDefid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  InfoStoreDef_PARENT_T /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  InfoStoreDef_PARENT_ID /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from InfoStoreDef where  InfoStoreDefid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_ISLOCKED /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from InfoStoreDef where InfoStoreDefid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_LOCK /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= InfoStoreDef_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= InfoStoreDef_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update InfoStoreDef set LockUserID =auserID ,LockSessionID =null where InfoStoreDefid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update InfoStoreDef set LockUserID =null,LockSessionID =aCURSESSION  where InfoStoreDefid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_HCL /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_UNLOCK /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= InfoStoreDef_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update InfoStoreDef set LockUserID =null  where InfoStoreDefid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update InfoStoreDef set LockSessionID =null  where InfoStoreDefid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_SINIT /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=InfoStoreDef_parent_T( aCURSESSION,aROWID);
 aParentID:= InfoStoreDef_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update InfoStoreDef set securitystyleid =aStyleID where InfoStoreDefid = aRowID;
else 
 update InfoStoreDef set securitystyleid =aSecurityStyleID where InfoStoreDefid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  InfoStoreDef_propagate /*Описание каталога*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from InfoStoreDef where InfoStoreDefid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  Folder_BRIEF  (
 aCURSESSION uuid,
 aFolderid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aFolderid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0
 then
  aBRIEF:= Folder_BRIEF_F(aFolderid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Folder_DELETE /*Папка каталога*/ (
 aCURSESSION uuid,
 aFolderid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Folder_ISLOCKED( acursession,aFolderid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Folder');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
Open aCurs for select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aFolderid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Shortcut_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aFolderid as varchar),   'Folder',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Folder' and OwnerRowID=aFolderid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Folder 
  where  FolderID = aFolderID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Папка*/
 create or replace function  Folder_SAVE /*Папка каталога*/ (
 aCURSESSION uuid,
 aFolderid uuid,
ainstanceid uuid 
, aParentRowid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aFolderType
 INTEGER/* Тип папки *//* Тип папки */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Folder_ISLOCKED( acursession,aFolderid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Folder');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aFolderid as varchar),  'Folder',
 'EDITROW',  aInstanceID);
 update  Folder set ChangeStamp=localtimestamp
,ParentRowid= aParentRowid
,
  Name=aName
,
  FolderType=aFolderType
  where  FolderID = aFolderID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Folder');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aFolderid as varchar),  'Folder',
 'CREATEROW',  aInstanceID);
 insert into   Folder
 (  FolderID 
,ParentRowid
,InstanceID
,Name

,FolderType

 ) values ( aFolderID 
,aParentRowid
,aInstanceID
,aName

,aFolderType

 ); 
 PERFORM Folder_SINIT( aCURSESSION,aFolderid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Folder_PARENT_T /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Folder_PARENT_ID /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from Folder where  Folderid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Folder_ISLOCKED /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Folder where Folderid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Folder_LOCK /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Folder_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Folder_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Folder set LockUserID =auserID ,LockSessionID =null where Folderid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Folder set LockUserID =null,LockSessionID =aCURSESSION  where Folderid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Folder_HCL /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
open aCurs for select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from Shortcut where Shortcutid=row_Shortcut.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close aCurs;
     return  aislocked;
   end if; 
 end if;  
 aisLocked:= Shortcut_HCL (acursession,row_Shortcut.id);
 if aisLocked &gt;2 then
   close aCurs;
   return  aislocked;
 end if;
end loop;
close aCurs;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Folder_UNLOCK /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Folder_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Folder set LockUserID =null  where Folderid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Folder set LockSessionID =null  where Folderid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Folder_SINIT /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Folder_parent_T( aCURSESSION,aROWID);
 aParentID:= Folder_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Folder set securitystyleid =aStyleID where Folderid = aRowID;
else 
 update Folder set securitystyleid =aSecurityStyleID where Folderid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Folder_propagate /*Папка каталога*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Folder where Folderid=aRowid;
open aCurs for select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aRowid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  Shortcut_SINIT( acursession,aid,assid);
 PERFORM  Shortcut_propagate( acursession,aid);
END LOOP;
close aCurs;
end; $$ language 'plpgsql';
GO



 create or replace function  Shortcut_BRIEF  (
 aCURSESSION uuid,
 aShortcutid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aShortcutid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0
 then
  aBRIEF:= Shortcut_BRIEF_F(aShortcutid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  Shortcut_DELETE /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aShortcutid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  Shortcut_ISLOCKED( acursession,aShortcutid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Shortcut');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aShortcutid as varchar),   'Shortcut',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='Shortcut' and OwnerRowID=aShortcutid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  Shortcut 
  where  ShortcutID = aShortcutID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Документы*/
 create or replace function  Shortcut_SAVE /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aShortcutid uuid,
ainstanceid uuid 
, aParentStructRowID uuid 
,aDocItem
 uuid/* Документ *//* Документ */
,aStartMode
 VARCHAR/* Режим *//* Режим */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  Shortcut_ISLOCKED( acursession,aShortcutid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Shortcut');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aShortcutid as varchar),  'Shortcut',
 'EDITROW',  aInstanceID);
 update  Shortcut set ChangeStamp=localtimestamp
,
  DocItem=aDocItem
,
  StartMode=aStartMode
  where  ShortcutID = aShortcutID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 aaccess:= Folder_ISLOCKED (acursession,aParentStructRowID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Shortcut');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aShortcutid as varchar),  'Shortcut',
 'CREATEROW',  aInstanceID);
 insert into   Shortcut
 (  ShortcutID 
,ParentStructRowID
,DocItem

,StartMode

 ) values ( aShortcutID 
,aParentStructRowID
,aDocItem

,aStartMode

 ); 
 PERFORM Shortcut_SINIT( aCURSESSION,aShortcutid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  Shortcut_PARENT_T /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'Folder';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  Shortcut_PARENT_ID /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select ParentStructRowID into aParentID  from Shortcut where  Shortcutid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_ISLOCKED /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Shortcut where Shortcutid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_LOCK /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= Shortcut_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= Shortcut_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update Shortcut set LockUserID =auserID ,LockSessionID =null where Shortcutid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Shortcut set LockUserID =null,LockSessionID =aCURSESSION  where Shortcutid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_HCL /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  Shortcut_UNLOCK /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= Shortcut_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Shortcut set LockUserID =null  where Shortcutid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Shortcut set LockSessionID =null  where Shortcutid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_SINIT /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=Shortcut_parent_T( aCURSESSION,aROWID);
 aParentID:= Shortcut_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update Shortcut set securitystyleid =aStyleID where Shortcutid = aRowID;
else 
 update Shortcut set securitystyleid =aSecurityStyleID where Shortcutid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  Shortcut_propagate /*Ярлыки документов*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from Shortcut where Shortcutid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--MTZExt" BlockCode=" create or replace function  MTZExt_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZExt'
then
Open aCurs  for select MTZExt_def.MTZExt_defid ID from MTZExt_def where  MTZExt_def.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZExt_def_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
Open aCurs  for select MTZExtRel.MTZExtRelid ID from MTZExtRel where  MTZExtRel.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZExtRel_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExt_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZExt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select MTZExt_def.MTZExt_defid ID from MTZExt_def where  MTZExt_def.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZExt_def where MTZExt_defid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZExt_def_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
Open aCurs  for select MTZExtRel.MTZExtRelid ID from MTZExtRel where  MTZExtRel.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZExtRel where MTZExtRelid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= MTZExtRel_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  MTZExt_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZExt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select MTZExt_def.MTZExt_defid id from MTZExt_def where  MTZExt_def.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZExt_def_SINIT( acursession,aid,assid);
 PERFORM MTZExt_def_propagate( acursession,aid);
end loop;
close aCurs;
open aCurs for  select MTZExtRel.MTZExtRelid id from MTZExtRel where  MTZExtRel.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM MTZExtRel_SINIT( acursession,aid,assid);
 PERFORM MTZExtRel_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  MTZExt_def_BRIEF  (
 aCURSESSION uuid,
 aMTZExt_defid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZExt_defid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZExt_def_BRIEF_F(aMTZExt_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_DELETE /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aMTZExt_defid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZExt_def_ISLOCKED( acursession,aMTZExt_defid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZExt_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZExt_defid as varchar),   'MTZExt_def',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZExt_def' and OwnerRowID=aMTZExt_defid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZExt_def 
  where  MTZExt_defID = aMTZExt_defID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Описание*/
 create or replace function  MTZExt_def_SAVE /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aMTZExt_defid uuid,
ainstanceid uuid 
,aName
 VARCHAR/* Название *//* Название */
,aExtType
 INTEGER/* Тип расширения *//* Тип расширения */
,aTheDescription
 TEXT/* Описание *//* Описание */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZExt_def_ISLOCKED( acursession,aMTZExt_defid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExt_def');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZExt_defid as varchar),  'MTZExt_def',
 'EDITROW',  aInstanceID);
 update  MTZExt_def set ChangeStamp=localtimestamp
,
  Name=aName
,
  ExtType=aExtType
,
  TheDescription=aTheDescription
  where  MTZExt_defID = aMTZExt_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExt_def');
    return;
  end if;
select Count(*) into existsCnt from MTZExt_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;MTZExt_def&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZExt_defid as varchar),  'MTZExt_def',
 'CREATEROW',  aInstanceID);
 insert into   MTZExt_def
 (  MTZExt_defID 
,InstanceID
,Name

,ExtType

,TheDescription

 ) values ( aMTZExt_defID 
,aInstanceID
,aName

,aExtType

,aTheDescription

 ); 
 PERFORM MTZExt_def_SINIT( aCURSESSION,aMTZExt_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZExt_def_PARENT_T /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZExt_def_PARENT_ID /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZExt_def where  MTZExt_defid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_ISLOCKED /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZExt_def where MTZExt_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_LOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZExt_def_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZExt_def_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZExt_def set LockUserID =auserID ,LockSessionID =null where MTZExt_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZExt_def set LockUserID =null,LockSessionID =aCURSESSION  where MTZExt_defid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_HCL /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_UNLOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZExt_def_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZExt_def set LockUserID =null  where MTZExt_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZExt_def set LockSessionID =null  where MTZExt_defid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_SINIT /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZExt_def_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZExt_def_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZExt_def set securitystyleid =aStyleID where MTZExt_defid = aRowID;
else 
 update MTZExt_def set securitystyleid =aSecurityStyleID where MTZExt_defid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZExt_def_propagate /*Список зарегистрированных расширений*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZExt_def where MTZExt_defid=aRowid;
end; $$ language 'plpgsql';
GO



 create or replace function  MTZExtRel_BRIEF  (
 aCURSESSION uuid,
 aMTZExtRelid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aMTZExtRelid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0
 then
  aBRIEF:= MTZExtRel_BRIEF_F(aMTZExtRelid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_DELETE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aMTZExtRelid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  MTZExtRel_ISLOCKED( acursession,aMTZExtRelid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZExtRel');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aMTZExtRelid as varchar),   'MTZExtRel',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='MTZExtRel' and OwnerRowID=aMTZExtRelid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  MTZExtRel 
  where  MTZExtRelID = aMTZExtRelID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Реализации расширения*/
 create or replace function  MTZExtRel_SAVE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aMTZExtRelid uuid,
ainstanceid uuid 
,aThePlatform
 INTEGER/* Реализация *//* Реализация */
,aTheClassName
 VARCHAR/* Название класса *//* Название класса */
,aTheLibraryName
 VARCHAR/* Название библиотеки *//* Название библиотеки */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  MTZExtRel_ISLOCKED( acursession,aMTZExtRelid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExtRel');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aMTZExtRelid as varchar),  'MTZExtRel',
 'EDITROW',  aInstanceID);
 update  MTZExtRel set ChangeStamp=localtimestamp
,
  ThePlatform=aThePlatform
,
  TheClassName=aTheClassName
,
  TheLibraryName=aTheLibraryName
  where  MTZExtRelID = aMTZExtRelID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExtRel');
    return;
  end if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aMTZExtRelid as varchar),  'MTZExtRel',
 'CREATEROW',  aInstanceID);
 insert into   MTZExtRel
 (  MTZExtRelID 
,InstanceID
,ThePlatform

,TheClassName

,TheLibraryName

 ) values ( aMTZExtRelID 
,aInstanceID
,aThePlatform

,aTheClassName

,aTheLibraryName

 ); 
 PERFORM MTZExtRel_SINIT( aCURSESSION,aMTZExtRelid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  MTZExtRel_PARENT_T /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  MTZExtRel_PARENT_ID /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from MTZExtRel where  MTZExtRelid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_ISLOCKED /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZExtRel where MTZExtRelid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_LOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= MTZExtRel_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= MTZExtRel_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update MTZExtRel set LockUserID =auserID ,LockSessionID =null where MTZExtRelid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZExtRel set LockUserID =null,LockSessionID =aCURSESSION  where MTZExtRelid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_HCL /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_UNLOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= MTZExtRel_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZExtRel set LockUserID =null  where MTZExtRelid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZExtRel set LockSessionID =null  where MTZExtRelid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_SINIT /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=MTZExtRel_parent_T( aCURSESSION,aROWID);
 aParentID:= MTZExtRel_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update MTZExtRel set securitystyleid =aStyleID where MTZExtRelid = aRowID;
else 
 update MTZExtRel set securitystyleid =aSecurityStyleID where MTZExtRelid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  MTZExtRel_propagate /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from MTZExtRel where MTZExtRelid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder><BlockHolder BlockName="--INV_NUM" BlockCode=" create or replace function  INV_NUM_DELETE(aCURSESSION uuid, ainstanceid uuid) returns void as $$  
declare
aObjType  varchar(255);
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='INV_NUM'
then
Open aCurs  for select INVN_DEF.INVN_DEFid ID from INVN_DEF where  INVN_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVN_DEF_DELETE (acursession,aID,aInstanceID);
END LOOP;
close aCurs;
return;
end if;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_NUM_HCL(aCURSESSION uuid, aRowID uuid) returns integer as $$ 
declare
aObjType  varchar(255);
 aIsLocked integer;
atmpStr  varchar(255);
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
aCurs refcursor;
aID uuid;
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'INV_NUM'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
Open aCurs  for select INVN_DEF.INVN_DEFid ID from INVN_DEF where  INVN_DEF.InstanceID = ainstanceid;
loop
FETCH aCurs  INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from INVN_DEF where INVN_DEFid=aid;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close aCurs;
     return aislocked;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close aCurs;
     return aislocked;
   end if; 
 end if; 
 aisLocked:= INVN_DEF_HCL (acursession,aid);
 if aisLocked &gt;2 then
   close aCurs;
     return aislocked;
 end if;
END LOOP;
close aCurs;
 end if;
aIsLocked:=0;
     return aislocked;
end; $$ language 'plpgsql'; 
GO
 create or replace function  INV_NUM_propagate(aCURSESSION uuid, aRowID uuid) returns void as  $$ 
declare
aObjType  varchar(255);
atmpStr  varchar(255);
achildlistid uuid;
assid uuid;
aCurs refcursor;
aID uuid;
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'INV_NUM'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
open aCurs for  select INVN_DEF.INVN_DEFid id from INVN_DEF where  INVN_DEF.InstanceID = arowid;
loop
fetch aCurs into aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM INVN_DEF_SINIT( acursession,aid,assid);
 PERFORM INVN_DEF_propagate( acursession,aid);
end loop;
close aCurs;
 end if; 
end; $$ language 'plpgsql'; 
GO



 create or replace function  INVN_DEF_BRIEF  (
 aCURSESSION uuid,
 aINVN_DEFid uuid
) returns varchar as $$
declare
 aBRIEF varchar(255);
 aaccess integer;
 atmpStr varchar(255);
 atmpID uuid;
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
if aINVN_DEFid is null then aBRIEF:=''; return aBrief; end if;
 -- Brief body -- 
select count(*)into existsCnt from INVN_DEF where INVN_DEFID=aINVN_DEFID;
if existsCnt &gt;0
 then
  aBRIEF:= INVN_DEF_BRIEF_F(aINVN_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return aBrief;
end;  $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_DELETE /**/ (
 aCURSESSION uuid,
 aINVN_DEFid uuid,
 ainstanceid uuid
) returns void as $$ 
 declare 
 aCurs refcursor;
 aSysLogID uuid;
 aaccess integer;
 aSysInstID uuid;
 atmpID uuid;
 aID uuid;
 existsCnt integer;
 aChildListid uuid;
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSystem';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INVN_DEF where INVN_DEFID=aINVN_DEFID;
if existsCnt &gt;0 then
 --  verify lock  --
 aaccess:=  INVN_DEF_ISLOCKED( acursession,aINVN_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INVN_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid;
 PERFORM  SysLog_SAVE (acursession , aSysLogid, aSysInstID, acursession,cast( aINVN_DEFid as varchar),   'INVN_DEF',
  'DELETEROW', aInstanceID);
open aCurs for select  instanceid ID from instance where OwnerPartName ='INVN_DEF' and OwnerRowID=aINVN_DEFid;
loop
FETCH aCurs INTO aID;
If Not FOUND Then
    EXIT;  -- exit loop
 END IF;
 PERFORM  INSTANCE_OWNER (acursession,aid,null,null);
 PERFORM  INSTANCE_DELETE (acursession,aid);
END LOOP;
close aCurs;
  delete from  INVN_DEF 
  where  INVN_DEFID = aINVN_DEFID; 
 end if;
 -- close transaction --
 existsCnt:=0;
end; $$ language 'plpgsql';
GO


/*Нумерация материалов*/
 create or replace function  INVN_DEF_SAVE /**/ (
 aCURSESSION uuid,
 aINVN_DEFid uuid,
ainstanceid uuid 
,aTheNumber
 integer/* Следующий номер материала *//* Следующий номер материала */
,aTheOrg
 uuid/* Организация *//* Организация */
,aTheOSNumber
 integer/* Следующий номер ОС *//* Следующий номер ОС */
)  returns void as $$
 declare 
aSysLogid uuid;
 aUniqueRowCount integer;
 atmpStr varchar(255);
 atmpID uuid;
 aaccess int;
 aSysInstID uuid;
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSystem';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INVN_DEF where INVN_DEFID=aINVN_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify lock  --
 aaccess:=  INVN_DEF_ISLOCKED( acursession,aINVN_DEFid); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVN_DEF');
    return;
  end if;
 -- update row  --
select newid() into asyslogid;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID, acursession,cast(aINVN_DEFid as varchar),  'INVN_DEF',
 'EDITROW',  aInstanceID);
 update  INVN_DEF set ChangeStamp=localtimestamp
,
  TheNumber=aTheNumber
,
  TheOrg=aTheOrg
,
  TheOSNumber=aTheOSNumber
  where  INVN_DEFID = aINVN_DEFID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVN_DEF where 1=1  
 and TheOrg=aTheOrg;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVN_DEF');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
aaccess:= instance_ISLOCKED( acursession,aInstanceID); 
 if aaccess&gt;2 
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INVN_DEF');
    return;
  end if;
select Count(*) into existsCnt from INVN_DEF where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
     perform  raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;INVN_DEF&gt;');
    return;
 End if;
select newid() into aSysLogID;
 PERFORM SysLog_SAVE( acursession, aSysLogid, aSysInstID,acursession, cast(aINVN_DEFid as varchar),  'INVN_DEF',
 'CREATEROW',  aInstanceID);
 insert into   INVN_DEF
 (  INVN_DEFID 
,InstanceID
,TheNumber

,TheOrg

,TheOSNumber

 ) values ( aINVN_DEFID 
,aInstanceID
,aTheNumber

,aTheOrg

,aTheOSNumber

 ); 
 PERFORM INVN_DEF_SINIT( aCURSESSION,aINVN_DEFid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from INVN_DEF where 1=1  
 and TheOrg=aTheOrg;
if aUniqueRowCount&gt;=2
then
  perform  raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=INVN_DEF');
 return;
end if;

 end if;
 -- close transaction --
 end; $$ language 'plpgsql'; 
GO


 create or replace function  INVN_DEF_PARENT_T /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns varchar as $$
 declare 
existsCnt integer;
aParentTable varchar(255);
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return '';
  end if;
  aParentTable := 'INSTANCE';
    return aParentTable;
 end; $$ language 'plpgsql';
GO
 create or replace function  INVN_DEF_PARENT_ID /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns uuid as $$
 declare 
 aParentID  uuid ;
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return null;
  end if;
  select  INSTANCEID into aParentID from INVN_DEF where  INVN_DEFid=aRowID;
 return aParentID;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_ISLOCKED /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$ 
 declare 
 aIsLocked  integer;
 aParentID uuid;
 aUserID uuid;
 aLockUserID uuid;
 aLockSessionID uuid;
 aParentTable varchar(255); 
 existsCnt integer; 
  astr varchar(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return 0;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INVN_DEF where INVN_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return aisLocked;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return aisLocked;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return aisLocked;
   else 
     aisLocked := 1; /* Locked by caller */
     return aisLocked;
   end if;  
 end if;  
 aisLocked := 0; 
 return aisLocked; 
 end; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_LOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aLockMode integer 
) returns void as  $$
 declare 
 aParentID uuid;
 aUserID uuid;
 atmpID uuid;
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 aISLocked:= INVN_DEF_ISLOCKED (aCURSESSION,aROWID );
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  aisLocked:= INVN_DEF_HCL (acursession,aRowID);
  if aIsLocked &gt;=3  
  then
      perform  raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
   if  aLockMode =2  
   then   
    update INVN_DEF set LockUserID =auserID ,LockSessionID =null where INVN_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INVN_DEF set LockUserID =null,LockSessionID =aCURSESSION  where INVN_DEFid=aRowID;
     return;
   end if;
 end ; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_HCL /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns integer as $$
 declare 
 aIsLocked integer;
achildlistid uuid;
 aUserID uuid;
 aLockUserID uuid;
 aID uuid;
 aCurs refcursor;
 aLockSessionID uuid;
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
   return  aislocked;
end;$$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_UNLOCK /**/ (
 aCURSESSION uuid,
 aRowID uuid 
) returns void as $$ 
 declare
 aParentID uuid;
 aUserID uuid;
 aIsLocked integer;
 aParentTable varchar(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
     perform  raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 aISLocked:= INVN_DEF_ISLOCKED( aCURSESSION,aROWID);
 if aIsLocked &gt;=3  
  then
     perform  raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INVN_DEF set LockUserID =null  where INVN_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INVN_DEF set LockSessionID =null  where INVN_DEFid=aRowID;
     return;
   end if;
 end; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_SINIT /**/ (
 aCURSESSION uuid,
 aRowID uuid ,
 aSecurityStyleID uuid
) returns void as $$
 declare 
 aParentID uuid;
 aParentTable varchar(255); 
 aStr varchar(4000);
 aStyleID uuid;
 atmpID uuid;
 aaccess integer; 
begin
if aSecurityStyleID is null then
 aParentTable:=INVN_DEF_parent_T( aCURSESSION,aROWID);
 aParentID:= INVN_DEF_parent_ID( aCURSESSION,aROWID);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=$1' ;
  execute  astr into aStyleID using aParentid;
 update INVN_DEF set securitystyleid =aStyleID where INVN_DEFid = aRowID;
else 
 update INVN_DEF set securitystyleid =aSecurityStyleID where INVN_DEFid = aRowID;
end if; 
end ; $$ language 'plpgsql';
GO


 create or replace function  INVN_DEF_propagate /**/ (
 aCURSESSION uuid,
 aRowID uuid
) returns void as $$
 declare 
achildlistid uuid;
aSSID uuid;
aID uuid;
aCurs refcursor;
begin
select securityStyleid into aSSID from INVN_DEF where INVN_DEFid=aRowid;
end; $$ language 'plpgsql';
GO


;

"><FormData Name=""/></BlockHolder></ModuleHolder><ModuleHolder ModuleName="--Init" File=""><BlockHolder BlockName="--body" BlockCode=" 

create or replace function InitBase() returns integer as $$ 
declare
aid uuid;
ainstid uuid;
auid uuid;
aSESSION uuid;
acid uuid;
asecid uuid;
ahid uuid;
atmpstr varchar(255);
begin
ainstid := '{9A360531-D935-4676-952A-5BF35A5CFE80}';
auid := '{7C125A6E-C535-4714-A4A9-45683D1B677B}'; 
asecid := '{031DE1E0-2E67-4C2E-BB1C-AC5C67630AEA}'; --user security instance 
ahid := '{DA2E4091-08E3-453E-8693-E94CE77CED60}'; -- helper id
delete from typelist;
delete from sysoptions;
insert into instance(InstanceID,OBJTYPE,Name) values(ainstid, 'MTZSystem','Системная информация');
insert into instance(InstanceID,OBJTYPE,Name) values(asecid, 'MTZUsers', 'Пользователи и группы');
insert into users(usersid,instanceid,login,password,name) values('{759D392D-40BC-48E6-9260-A46241EDB1CA}',asecid,'supervisor','bami','Администратор');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZ2JOB', 'MTZ2JOB_DELETE', 'MTZ2JOB_HCL', 'MTZ2JOB_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZFltr', 'MTZFltr_DELETE', 'MTZFltr_HCL', 'MTZFltr_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZSrvMsg', 'MTZSrvMsg_DELETE', 'MTZSrvMsg_HCL', 'MTZSrvMsg_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZJrnl', 'MTZJrnl_DELETE', 'MTZJrnl_HCL', 'MTZJrnl_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZStateSrv', 'MTZStateSrv_DELETE', 'MTZStateSrv_HCL', 'MTZStateSrv_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'REPD', 'REPD_DELETE', 'REPD_HCL', 'REPD_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'INV_INV', 'INV_INV_DELETE', 'INV_INV_HCL', 'INV_INV_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'STDJournalExt', 'STDJournalExt_DELETE', 'STDJournalExt_HCL', 'STDJournalExt_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZMetaModel', 'MTZMetaModel_DELETE', 'MTZMetaModel_HCL', 'MTZMetaModel_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'STDNumerator', 'STDNumerator_DELETE', 'STDNumerator_HCL', 'STDNumerator_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'Ext_Photo_J', 'Ext_Photo_J_DELETE', 'Ext_Photo_J_HCL', 'Ext_Photo_J_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'INVF', 'INVF_DELETE', 'INVF_HCL', 'INVF_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZSecurity', 'MTZSecurity_DELETE', 'MTZSecurity_HCL', 'MTZSecurity_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'INV_OS', 'INV_OS_DELETE', 'INV_OS_HCL', 'INV_OS_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZRprt', 'MTZRprt_DELETE', 'MTZRprt_HCL', 'MTZRprt_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZUsers', 'MTZUsers_DELETE', 'MTZUsers_HCL', 'MTZUsers_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZSystem', 'MTZSystem_DELETE', 'MTZSystem_HCL', 'MTZSystem_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'ROLES', 'ROLES_DELETE', 'ROLES_HCL', 'ROLES_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZwp', 'MTZwp_DELETE', 'MTZwp_HCL', 'MTZwp_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'INV_DIC', 'INV_DIC_DELETE', 'INV_DIC_HCL', 'INV_DIC_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZ_Install', 'MTZ_Install_DELETE', 'MTZ_Install_HCL', 'MTZ_Install_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'STDInfoStore', 'STDInfoStore_DELETE', 'STDInfoStore_HCL', 'STDInfoStore_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZExt', 'MTZExt_DELETE', 'MTZExt_HCL', 'MTZExt_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'INV_NUM', 'INV_NUM_DELETE', 'INV_NUM_HCL', 'INV_NUM_propagate');

PERFORM SysOptions_SAVE  ('{F7DB9F90-D1B1-4A39-9795-ED740243B261}', 'MTZ2JOB_DEF', 'MTZ2JOB', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{9CD58EA8-7C89-4625-893D-A22C8326451D}', 'FilterFieldGroup', 'MTZFltr', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{2901D359-2A75-4C02-9414-27ADA29EC38D}', 'FileterField', 'MTZFltr', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{E6B3974A-AA1C-42EA-805C-3C1CE5B83359}', 'FileterField', 'FilterFieldGroup', 'PARENT');



PERFORM SysOptions_SAVE  ('{80987FFD-178C-4C1D-A168-D6DBD0C805C1}', 'Filters', 'MTZFltr', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{D5BF7A5E-6789-487A-BAA8-7082A6441AC4}', 'Filters', 'viewMTZFltr_Filters', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{B4F40080-02C2-4EB9-A666-C529198D3F11}', 'SrvMessageInfo', 'MTZSrvMsg', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{E35EFC7D-6D2A-4578-9C3F-F24CF069322C}', 'MTZJrnl', 'viewMTZJrnl_Jo', 'TDEFVIEW');

PERFORM SysOptions_SAVE  ('{69096DF4-F5E9-4E9D-BA26-8D8824115A9F}', 'JournalColumn', 'MTZJrnl', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{A0FBEDCA-4537-4085-B3E1-6A76CE479B84}', 'JColumnSource', 'MTZJrnl', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{5ACD97A4-2A55-4DC7-BE83-74C86D573087}', 'JColumnSource', 'JournalColumn', 'PARENT');



PERFORM SysOptions_SAVE  ('{B294B193-64AD-4466-A650-7FE1FF8E25D7}', 'Journal', 'MTZJrnl', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{79E6513F-51F3-433C-A9D2-9228D388A434}', 'Journal', 'viewMTZJrnl_Jo', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{359F2F9E-714B-4CAA-963F-554831A7B552}', 'JournalSrc', 'MTZJrnl', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{CA372916-E2D4-4469-BEFE-6C9F3CFD5CDC}', 'StateAction', 'MTZStateSrv', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{8D46309C-E4C0-47AA-9032-7E2BFC14CE63}', 'REPD_LOCKED', 'REPD', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{47317212-EFAF-4411-948E-64143075BECC}', 'REPD_RequestQuery', 'REPD', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{9741799C-F254-41BC-9B2B-FD8D740BF2BC}', 'REPD_ResQueryRcv', 'REPD', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{7E5A1986-82A7-4EEE-A07C-D79DF7FD535D}', 'REPD_ResQueryRcv', 'REPD_RequestQuery', 'PARENT');



PERFORM SysOptions_SAVE  ('{3A14CC65-1993-4C9E-83D2-5579198E1CFA}', 'REPD_PROV', 'REPD', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{BA03A24C-E8B5-4FFB-8013-7FD5F364FD87}', 'REPD_SRV', 'REPD', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{1CA01A0A-B7DF-4F46-8EE1-2130E9FF94A9}', 'REPD_SNDTO', 'REPD', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{7A75BBCC-1BDE-4EE0-94B2-EF97F1641E66}', 'REPD_SNDTO', 'REPD_SRV', 'PARENT');

PERFORM SysOptions_SAVE  ('{D85E07E4-6974-4534-8765-B2406704D68C}', 'REPD_CONST', 'REPD', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{45EC82C5-B197-4E8B-8242-27CC7FAF6CE2}', 'REPD_CONST', 'REPD_SNDTO', 'PARENT');

PERFORM SysOptions_SAVE  ('{567D90B2-44DA-436F-B627-C01B2B4FD0CD}', 'REPD_REPTYPE', 'REPD', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{EF756920-5824-47FE-B126-256F0FDE55C2}', 'REPD_REPTYPE', 'REPD_SNDTO', 'PARENT');





PERFORM SysOptions_SAVE  ('{CC407313-83F8-4AEC-BEAE-CF2F9D83AAFC}', 'REPD_SendQ', 'REPD', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{B389DE75-E3BD-4355-8DC6-4BE889C2D288}', 'REPD_RecvQ', 'REPD', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{748975BE-6C17-4D30-8FDD-458BF236471D}', 'INV_INV', 'AUTOinvi_DEF', 'TDEFVIEW');

PERFORM SysOptions_SAVE  ('{D685EB18-76E9-4635-B6AC-9125D138CAC4}', 'invi_DEF', 'INV_INV', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{9A3A8731-D100-495B-A7C7-E82D34F25168}', 'invi_DEF', 'AUTOinvi_DEF', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{F49976A9-492F-47E0-B510-7592DB39C49F}', 'INVI_PERSONS', 'INV_INV', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{C8BF49AB-A3D5-4FDD-B40A-B4AE0AB156C1}', 'INVI_PERSONS', 'AUTOINVI_PERSONS', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{34B3A26B-EFA2-4E2A-8790-FCABF66407BB}', 'INVI_BAD', 'INV_INV', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{27A958A8-883B-43B5-869D-72C971B57FBC}', 'INVI_CHNG', 'INV_INV', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{4FAC38A8-216F-49F8-9ED6-FDEB5C22254C}', 'INVI_OBJ', 'INV_INV', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{4B0016FC-FFBD-4D15-BAD7-21DEC2E39C0F}', 'INVI_OBJ', 'AUTOINVI_OBJ', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{E75CA872-A3D9-4583-9351-0EDBC2674D84}', 'INVI_DONE', 'INV_INV', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{68033A6B-59CA-4CD8-83AC-03A978448AAC}', 'INVI_DONE', 'AUTOINVI_DONE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{7CF202FE-C751-42A5-AD86-E47EDA049E26}', 'INVI_UNK', 'INV_INV', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{EBD06CBC-7BC4-491F-9106-7054DCE914BB}', 'STDJournlaExtInfo', 'STDJournalExt', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{8C0FB06B-2125-45AC-B961-C2CC0A847408}', 'STDJournalExtParam', 'STDJournalExt', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{E3349038-227B-4D6D-AEDA-B355FECDC13C}', 'STDJournalExtFlt', 'STDJournalExt', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{6F172A5F-2C11-45F0-92CF-DF1104FD459E}', 'STDJournalExtField', 'STDJournalExt', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{676BFE7B-227C-4CEB-B26B-52E4DEFA2C43}', 'STDJournalExtField', 'STDJournalExtFlt', 'PARENT');



PERFORM SysOptions_SAVE  ('{E6D65808-C5F5-4245-865C-596365CB97FE}', 'FIELDTYPE', 'MTZMetaModel', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{AF7832B5-B59C-4162-988D-BED88093E3A1}', 'FIELDTYPEMAP', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{59886108-FA8C-4A6F-9A1B-ABE5AB748D14}', 'FIELDTYPEMAP', 'FIELDTYPE', 'PARENT');

PERFORM SysOptions_SAVE  ('{C215BF34-216A-4609-8677-BB29055FF203}', 'ENUMITEM', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{499C7266-2579-4514-8D5B-2E8B15132073}', 'ENUMITEM', 'FIELDTYPE', 'PARENT');

PERFORM SysOptions_SAVE ( '{F115D679-A635-4689-8FF9-F1AB2CF03338}', 'FIELDTYPE', 'FindFieldType', 'DEFVIEW');



PERFORM SysOptions_SAVE  ('{04ABA237-A872-4B7E-8C29-BF85B28EB642}', 'SHAREDMETHOD', 'MTZMetaModel', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{2D28487A-95F6-471D-AE6E-8DBAABD3C7A0}', 'SCRIPT', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{F5149E09-DD4D-424A-99F8-037766451DF1}', 'SCRIPT', 'SHAREDMETHOD', 'PARENT');

PERFORM SysOptions_SAVE  ('{C9575697-A2BA-4BB5-95DD-42AAFB1D6343}', 'PARAMETERS', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{B9B8010F-F754-479F-9FFD-ACDDDBBAB4FD}', 'PARAMETERS', 'SCRIPT', 'PARENT');

PERFORM SysOptions_SAVE ( '{9A0BB248-868A-4A0F-9D87-0D19DB7D5620}', 'SHAREDMETHOD', 'FindMethod', 'DEFVIEW');



PERFORM SysOptions_SAVE  ('{213C5B25-4A43-4400-BFA9-FAEAF4AFBF19}', 'OBJECTTYPE', 'MTZMetaModel', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{E71ECA11-16B9-42DB-A548-1CE39DAE5570}', 'PART', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{BBFE91EC-4B25-4212-95D8-DB61C1F1CBB1}', 'PART', 'OBJECTTYPE', 'PARENT');

PERFORM SysOptions_SAVE  ('{52D0C22D-6A61-4744-BABF-AC72FCA4E44D}', 'PARTMENU', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{1B965C9F-7833-4D52-981E-A3AB36EA6F99}', 'PARTMENU', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{C7163368-9282-458D-A162-552416526D01}', 'PARTPARAMMAP', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{FE4B74B6-0995-435F-9C0A-D84D56165096}', 'PARTPARAMMAP', 'PARTMENU', 'PARENT');

PERFORM SysOptions_SAVE  ('{405135D2-4745-4603-9C0A-E055FFA66F00}', 'FIELD', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{CC1540D7-8324-4298-9811-DEF01AECA2ED}', 'FIELD', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{8A295FA0-A8D3-4816-8BFA-591AE81F870B}', 'FIELDVALIDATOR', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{9F06AB11-2AE3-45D3-8C7D-BFFA2E54E6F7}', 'FIELDVALIDATOR', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{0013AB1D-BC3C-410E-B37E-6958C394EFB3}', 'FIELDMENU', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{2B9519F5-685F-42E3-80F3-DB5FBC6A3F92}', 'FIELDMENU', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{C6A9A731-5EE3-4AD3-BC69-30A4959082FE}', 'FIELDPARAMMAP', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{180B7762-5574-47AF-9E5D-F6D01137AED9}', 'FIELDPARAMMAP', 'FIELDMENU', 'PARENT');

PERFORM SysOptions_SAVE  ('{4EC8B958-D0E5-49F9-B4A4-2815A6B3C78B}', 'FldExtenders', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{FB85F65C-B348-4F75-BA2C-34D119080C4F}', 'FldExtenders', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{377677D4-CB99-4259-9CB5-256CBD156423}', 'FIELDEXPRESSION', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{FC72CBB8-F2B4-4F4C-91CF-BF793D0237B2}', 'FIELDEXPRESSION', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{1FE2BA17-F319-4570-9500-8F9517DB8334}', 'DINAMICFILTERSCRIPT', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{60F604E5-6C31-45E1-881B-DCDE7DCB7815}', 'DINAMICFILTERSCRIPT', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{E75737BC-74ED-47BF-80C9-28B5D09996BF}', 'FIELDSRCDEF', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{5B759E0E-8A1C-4A07-B905-8253B2AF345A}', 'FIELDSRCDEF', 'FIELD', 'PARENT');

PERFORM SysOptions_SAVE  ('{EFD257DD-B643-48D0-A27F-DBD980E287B7}', 'PARTVIEW', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{C7CC2C3F-D753-41DC-BA23-4C1E4F23D4E2}', 'PARTVIEW', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{FE1CFDFF-89B1-4EB5-A003-25C97086A426}', 'ViewColumn', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{4C10AA15-7921-45A9-9C96-B05F198CED18}', 'ViewColumn', 'PARTVIEW', 'PARENT');

PERFORM SysOptions_SAVE  ('{B4F54DD1-C416-465D-836D-9474C80F835B}', 'PARTVIEW_LNK', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{A475819A-0A64-49DA-BFAA-D7E4848DC07F}', 'PARTVIEW_LNK', 'PARTVIEW', 'PARENT');

PERFORM SysOptions_SAVE  ('{F98FC24E-2F1E-4340-929C-9B457FB24302}', 'ExtenderInterface', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{55B79931-DCEF-4C6F-B552-702EF3DB0241}', 'ExtenderInterface', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{E79E7737-D131-4853-A904-B7D6F69D0B58}', 'VALIDATOR', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{D018209B-BADC-4442-B604-5A3837FC643B}', 'VALIDATOR', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{A455E566-8F01-489D-BD63-FBB22BD14226}', 'UNIQUECONSTRAINT', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{0ED04AA5-F3D4-4CE8-AFD5-173F9FCDF0CC}', 'UNIQUECONSTRAINT', 'PART', 'PARENT');

PERFORM SysOptions_SAVE  ('{7FF42D09-5117-486A-8475-A630A647DE21}', 'CONSTRAINTFIELD', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{A89DEB77-3902-4C60-9050-D614D6D9E317}', 'CONSTRAINTFIELD', 'UNIQUECONSTRAINT', 'PARENT');

PERFORM SysOptions_SAVE  ('{D599EE35-DE38-41F6-BECB-4D9AD5DC52FE}', 'INSTANCEVALIDATOR', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{85788D27-B576-4D70-AF4A-B1AAAB61FC57}', 'INSTANCEVALIDATOR', 'OBJECTTYPE', 'PARENT');

PERFORM SysOptions_SAVE  ('{FA51E182-F804-4921-BAC1-578EAA43F7C9}', 'OBJSTATUS', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{099B6249-E9F2-4529-88F6-AEFB7AD74173}', 'OBJSTATUS', 'OBJECTTYPE', 'PARENT');

PERFORM SysOptions_SAVE  ('{D4A97082-3157-45B4-A0D6-6E99524CEDDD}', 'NEXTSTATE', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{0A0AC5F5-1B0E-4A11-948C-BEF7BB054C4F}', 'NEXTSTATE', 'OBJSTATUS', 'PARENT');

PERFORM SysOptions_SAVE  ('{6BBC1498-9528-4D06-ADBC-42BDBE59F51A}', 'OBJECTMODE', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{2532A4E7-D500-45B6-945E-A15686D5A61D}', 'OBJECTMODE', 'OBJECTTYPE', 'PARENT');

PERFORM SysOptions_SAVE  ('{C6A9EE7A-AFA4-49F8-BEEF-FC110A342031}', 'STRUCTRESTRICTION', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{D10F4832-A812-4DB9-A0D2-62382927D1BF}', 'STRUCTRESTRICTION', 'OBJECTMODE', 'PARENT');

PERFORM SysOptions_SAVE  ('{A7D789DC-945E-458C-8838-4A9FDFD0D834}', 'FIELDRESTRICTION', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{74B049C0-2F19-43D2-BAF8-F696D2BC95E8}', 'FIELDRESTRICTION', 'OBJECTMODE', 'PARENT');

PERFORM SysOptions_SAVE  ('{26B47145-AD21-43E8-9231-00CD2945AE95}', 'METHODRESTRICTION', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{2C75EF6E-D830-47D8-A985-1CFBC4D47AE0}', 'METHODRESTRICTION', 'OBJECTMODE', 'PARENT');

PERFORM SysOptions_SAVE  ('{FB0C51DE-6FFE-4865-9C69-F1B8391282A5}', 'TYPEMENU', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{4F6335A8-4569-43A5-96DA-3ED4196D0001}', 'TYPEMENU', 'OBJECTTYPE', 'PARENT');

PERFORM SysOptions_SAVE ( '{ADCF0962-B557-4857-85C3-E3F533085DBF}', 'OBJECTTYPE', 'FindOBJECTTYPE', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{945ED0DE-22AB-4EE7-AFDB-AE1FC2021B3F}', 'PART', 'FindPart', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{9DE94637-1460-45C8-8CE7-CEBCBE508779}', 'PARTMENU', 'FindPARTMENU', 'DEFVIEW');


PERFORM SysOptions_SAVE ( '{CD656C25-E6E3-414F-8E32-736B1819D5C6}', 'FIELD', 'FindField', 'DEFVIEW');


















PERFORM SysOptions_SAVE ( '{5842A042-4EEA-43AB-A18D-3DA29FFE469F}', 'OBJECTMODE', 'viewMTZMetaModel_OBJECTMODE', 'DEFVIEW');




PERFORM SysOptions_SAVE ( '{F98DB1DA-D20B-4EC8-9D0A-1E0EFDFF5A73}', 'TYPEMENU', 'FindTYPEMENU', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{3093B87B-4BFB-4429-BEED-54B03884E368}', 'MTZAPP', 'MTZMetaModel', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{9FCDABE5-64EF-4971-9E5B-3C83FA0920B2}', 'ParentPackage', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{6309EECB-7395-4DA9-8AF8-0CEDE5E46380}', 'ParentPackage', 'MTZAPP', 'PARENT');

PERFORM SysOptions_SAVE ( '{0B67EA70-C345-4245-AC0B-2BAA5CD3403D}', 'MTZAPP', 'FindMTZAPP', 'DEFVIEW');


PERFORM SysOptions_SAVE  ('{F4C799CB-4783-48D1-938A-653712592F42}', 'GENPACKAGE', 'MTZMetaModel', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{6810B6DA-47B1-42D4-86FF-F0CED5188172}', 'GENERATOR_TARGET', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{0EE784FB-1A6C-4BEC-BBFB-8F97BC456F42}', 'GENERATOR_TARGET', 'GENPACKAGE', 'PARENT');

PERFORM SysOptions_SAVE  ('{37263F66-8B34-4FB0-8971-541A783989D2}', 'GENMANUALCODE', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{88A498E5-5E60-4EBA-8718-F75501485913}', 'GENMANUALCODE', 'GENERATOR_TARGET', 'PARENT');

PERFORM SysOptions_SAVE  ('{5B5431CB-D004-4D4C-8AA2-21E2F616C385}', 'GENCONTROLS', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{C5FF9FF9-A851-4DB5-AD38-F538CE940B33}', 'GENCONTROLS', 'GENERATOR_TARGET', 'PARENT');

PERFORM SysOptions_SAVE  ('{5E4E949F-58DE-46A9-BA6F-3F17979FA800}', 'GENREFERENCE', 'MTZMetaModel', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{3CFF0639-B1B0-46ED-BC5F-A7E6CA311404}', 'GENREFERENCE', 'GENERATOR_TARGET', 'PARENT');

PERFORM SysOptions_SAVE ( '{F99A80AF-B1A0-41F0-B77D-0ACCD6252903}', 'GENPACKAGE', 'FindGENPACKAGE', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{BEE7744C-B8C3-49B8-9CDA-24946D3612C7}', 'GENERATOR_TARGET', 'FindGENERATOR_TARGET', 'DEFVIEW');




PERFORM SysOptions_SAVE  ('{7C3528FF-500D-4623-AE09-71DED6437E2A}', 'LocalizeInfo', 'MTZMetaModel', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{6585B3D1-F25A-410E-A0E7-51054E135E52}', 'Num_zones', 'STDNumerator', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{30D02C74-B742-43E0-B543-2386BC0C2DB4}', 'Num_Values', 'STDNumerator', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{06FEB1FC-1CEA-4DF1-B928-251AAFE0BDC3}', 'Num_Values', 'Num_zones', 'PARENT');


PERFORM SysOptions_SAVE ( '{70293748-AD85-4219-A819-D3E6C49695A8}', 'Num_Values', 'viewSTDNumerator_Num_Values', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{0359A65E-B57F-4800-B893-0D7CDB97E219}', 'Num_head', 'STDNumerator', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{3B9740B9-5302-4ED4-8C4D-ACAACD03E3A0}', 'Num_head', 'viewSTDNumerator_Num_head', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{8AB24BF1-7807-4A98-9FD4-B6A7A7846225}', 'Ext_Photos', 'Ext_Photo_J', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{9A3F1309-2842-401D-B8B9-1FD9EC417DDD}', 'Ext_Photo_Call', 'Ext_Photo_J', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{4C8847BE-CE55-4704-A743-0B2235E881F0}', 'Ext_Photo_Call', 'Ext_Photos', 'PARENT');



PERFORM SysOptions_SAVE  ('{2CED96CC-4F34-40B0-8CCC-7EA3DA3984F4}', 'INVF_DEF', 'INVF', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{F226F1BB-2F2F-4A3C-9737-6B367130721E}', 'INVF_DEF', 'AUTOINVF_DEF', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{C84A6034-86A9-4922-970E-EB866F8A64C1}', 'MTZSEC_RIGHT', 'MTZSecurity', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{52C85B21-AAF3-458A-BEEC-C00D839A9A04}', 'MTZSEC_RIGHT', 'FindMTZSEC_RIGHT', 'DEFVIEW');
PERFORM SysOptions_SAVE ( '{856338C1-102B-43A5-AA71-1C43DEF3B633}', 'INV_OS', 'AUTOINVOS_INFO', 'TDEFVIEW');

PERFORM SysOptions_SAVE  ('{DD9E92DF-A2D7-40B9-8182-920B53D7EE1A}', 'INVOS_RENT', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{D2F113FC-BC2A-4164-B276-18353AFC9AAC}', 'INVOS_RENT', 'AUTOINVOS_RENT', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{666E6296-B5CE-46BD-BD69-6113EDCF512A}', 'INVOS_HIST', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{4E11CEDB-7D5E-4D8C-BA61-96944E4C75AB}', 'INVOS_HIST', 'AUTOINVOS_HIST', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{03B3CCA0-9BB8-4325-8F3D-F9AA5A721913}', 'INVOS_OFFRULE', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{3215F70F-821F-4D34-8EAA-8B93EFA869B4}', 'INVOS_OFFRULE', 'AUTOINVOS_OFFRULE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{0FC010F9-CBF2-4271-8729-4CF5C1F1540D}', 'INVOS_SROK', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{8B14D85A-AED2-4612-8663-0F964BA9D7E5}', 'INVOS_SROK', 'AUTOINVOS_SROK', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{81B5AE71-A605-42F5-956C-261AF6590B38}', 'INVOS_TECH', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{81D866F0-CE9A-4F0B-B1B7-ED6AB0B1433A}', 'INVOS_WINSOFT', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{45442615-F527-49FF-8E4B-C68CE754A577}', 'INVOS_WINSOFT', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE  ('{580A447F-E581-46CF-9690-3C6C242BE2E3}', 'INVOS_COMP', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{0A7FE432-7128-4E16-A0CC-8E4C7659552B}', 'INVOS_COMP', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE  ('{83026AE8-D9F7-4A38-AD53-C80767948460}', 'INVOS_HARD', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{437FCCF4-2719-4F8A-8429-3B99C53258C9}', 'INVOS_HARD', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE  ('{35586C4A-CA3B-4ED4-972C-4217AA4A4C41}', 'INVOS_CURCFG', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{95E09189-CEDA-49CD-B44C-6DB6ECBEEFD3}', 'INVOS_CURCFG', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE  ('{B2667A98-F786-4C1B-A014-281C69D71C34}', 'INVOS_CFGCH', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{A723F997-A392-44A2-A1E0-C32E0499461F}', 'INVOS_CFGCH', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE  ('{66D798A2-54E2-4FA5-9810-BED513022673}', 'INVOS_DEVICES', 'INV_OS', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{52FF1884-84C0-48F3-91F8-05AFE3776EF8}', 'INVOS_DEVICES', 'INVOS_TECH', 'PARENT');

PERFORM SysOptions_SAVE ( '{4E676808-1EF4-4EBF-B23F-493AACD95271}', 'INVOS_TECH', 'AUTOINVOS_TECH', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{0557F2FF-633F-475E-A79D-BDF53504F837}', 'INVOS_WINSOFT', 'AUTOINVOS_WINSOFT', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{5D6472BD-7A63-47D8-9C85-F2400B1236C8}', 'INVOS_COMP', 'AUTOINVOS_COMP', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{90E7BBFC-9484-4A5B-93F3-5587918F6E70}', 'INVOS_HARD', 'AUTOINVOS_HARD', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{5FE756D4-4947-45F8-81CE-38ED9AE1B7DC}', 'INVOS_CURCFG', 'AUTOINVOS_CURCFG', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{16045250-CC18-494A-AB9F-F3B4A609C7A6}', 'INVOS_CFGCH', 'AUTOINVOS_CFGCH', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{172806CF-B44A-46A4-8822-AE554BA24101}', 'INVOS_DEVICES', 'AUTOINVOS_DEVICES', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{12491ABD-532F-4CE7-B2A1-4B68A74FF3A9}', 'INVOS_DRAG', 'INV_OS', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{29A4D59F-824B-429B-A770-F4E2447561F8}', 'INVOS_DOCS', 'INV_OS', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{875FC027-AC31-4690-B97A-41C3DD1D70D3}', 'INVOS_INV', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{0AB18629-DA3E-4603-AE7D-0684CA310606}', 'INVOS_INV', 'AUTOINVOS_INV', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{3575A76D-D671-4F14-94D0-2E464BC9C4FD}', 'INVOS_LIZING', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{9584DE95-25CE-4298-B16C-AE14BFF644D6}', 'INVOS_LIZING', 'AUTOINVOS_LIZING', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{8AB25A3B-57C0-4A2C-8589-4D229183F0B5}', 'INVOS_CNSRV', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{16B2D5D6-C3C5-41AE-96C4-901254253640}', 'INVOS_CNSRV', 'AUTOINVOS_CNSRV', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{86C13769-7F86-4249-B235-952ACFB55C97}', 'INVOS_INFO', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{6B766470-8B7E-44D5-BD72-5DC115AD8647}', 'INVOS_INFO', 'AUTOINVOS_INFO', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{42587AD0-10BE-43A2-8350-04CE745AA276}', 'INVOS_MOD', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{DF2F6363-085C-44C8-9EE0-8AC4FB3198B4}', 'INVOS_MOD', 'AUTOINVOS_MOD', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{805E6F31-7144-4A55-93E0-E977E7DDCD54}', 'INVOS_CMNT', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{C4A767DC-9DCC-49D0-AC86-B68DB3373DDF}', 'INVOS_CMNT', 'AUTOINVOS_CMNT', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{D118D6A2-04D7-4CB5-9D5A-D412283DFFA1}', 'INVOS_CODE', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{B17A1C22-9612-4E23-95F9-B41A5BA81FCA}', 'INVOS_CODE', 'AUTOINVOS_CODE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{5CC2F979-0E01-40EB-BDB8-CDD12A703EE3}', 'INVOS_REPAIR', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{AFBB350C-434D-4A8B-A8C5-33CE34539CE7}', 'INVOS_REPAIR', 'AUTOINVOS_REPAIR', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{3F83D0B2-DE8C-48E3-B449-06DEA0C58F3A}', 'INVOS_PLACE', 'INV_OS', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{48FA979C-5746-4984-82A2-4AF47651F16E}', 'INVOS_PLACE', 'AUTOINVOS_PLACE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{D384A613-B059-4B61-9ACD-00CD7E4C9568}', 'Reports', 'MTZRprt', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{932878B8-6228-4887-9C83-9726770BCA9C}', 'Reports', 'FindReports', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{4141DB52-4BF6-44E7-885A-3A12065D86FC}', 'RPTStruct', 'MTZRprt', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{8A35256D-29DF-4922-92B5-F0BECA7E604D}', 'RPTFields', 'MTZRprt', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{852DEFA4-9423-45EF-A3E5-4BCBA01B3EAB}', 'RPTFields', 'RPTStruct', 'PARENT');



PERFORM SysOptions_SAVE  ('{85CE7998-730F-4B30-BA4D-26FB7357D74C}', 'RPTFormula', 'MTZRprt', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{AF673F51-B4D5-448E-9BBE-43909CE63918}', 'Users', 'MTZUsers', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{E7990635-6509-4F1D-BD55-916BB32BDEA6}', 'Users', 'FindUsers', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{86E86375-2FDA-4DB9-B0C0-2BF1EFF9E07B}', 'Groups', 'MTZUsers', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{BDE9AB07-6B00-4507-B02D-51FB6264C2B8}', 'GroupUser', 'MTZUsers', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{DDCA568D-0547-4DC7-A6F4-9EA77A02F4DC}', 'GroupUser', 'Groups', 'PARENT');

PERFORM SysOptions_SAVE ( '{206A258E-B02D-43AC-8A8B-507EF30B0647}', 'Groups', 'FindGroups', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{28678C00-F046-4956-8809-6C55A2BF4059}', 'GroupUser', 'AUTOGroupUser', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{FD0B6BAB-77CD-402B-BD02-5F1BBCFA1C64}', 'SysLog', 'MTZSystem', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{9811117B-BD24-43E2-8289-9C4314BD7AD3}', 'the_Session', 'MTZSystem', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{331197D5-ACC4-44BF-8645-E6807CE19F1F}', 'LogReader', 'MTZSystem', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{BB0D5F2C-E62C-4B62-90A7-CE269B6B7941}', 'Verb', 'MTZSystem', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{63EEDC6B-0442-4037-8D80-D8D8FEE5A91D}', 'ROLES_USER', 'ROLES', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{33CDEE4C-F433-4EC4-BD72-E82871B5B0DB}', 'ROLES_USER', 'AUTOROLES_USER', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{D46FC886-238B-4C7B-B10E-31EC629B18B2}', 'ROLES_MAP', 'ROLES', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{BB0A836A-29E3-4009-8431-F2444092FE30}', 'ROLES_MAP', 'AUTOROLES_MAP', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{264E655D-BCFF-4462-BB8A-B82B74CB6AF0}', 'ROLES_DOC', 'ROLES', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{14C51AF8-C7CF-4757-AEFC-D4C1ECD00539}', 'ROLES_DOC_STATE', 'ROLES', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{A4961265-14C0-49A1-A651-B311AB363C79}', 'ROLES_DOC_STATE', 'ROLES_DOC', 'PARENT');

PERFORM SysOptions_SAVE ( '{78E63F9F-0578-4A5D-BF7A-17C1DF9351A1}', 'ROLES_DOC', 'AUTOROLES_DOC', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{2F00160D-D913-4693-9E16-F206A2BA9720}', 'ROLES_DOC_STATE', 'AUTOROLES_DOC_STATE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{5878B1CA-AA86-465F-95A9-07EFE003ADD2}', 'ROLES_DEF', 'ROLES', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{879E0847-0962-4137-B4A5-EF0CF67FF8AC}', 'ROLES_DEF', 'viewROLES_ROLES_DEF', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{967ECC08-DED9-4F88-9A4C-9BE4E4F67102}', 'ROLES_REPORTS', 'ROLES', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{B8D82631-39F6-4756-A54D-DE97A9FC4A9A}', 'ROLES_WP', 'ROLES', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{17EDEC41-B0DA-45B4-A919-566D4E132A07}', 'ROLES_ACT', 'ROLES', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{22517B20-A243-4A92-9B09-CD6715A3553F}', 'ROLES_ACT', 'ROLES_WP', 'PARENT');



PERFORM SysOptions_SAVE  ('{26A685CD-EC11-4788-A76D-F85978E21020}', 'WorkPlace', 'MTZwp', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{0D76B73A-E123-49AF-9656-6AD78B6F3091}', 'WorkPlace', 'viewMTZwp_WorkPlace', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{FC6B75D0-9D3B-4D43-ABB3-0DB87381EBF2}', 'EntryPoints', 'MTZwp', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{F9D2ECC7-4707-4AA8-A475-954BC51CD3A2}', 'EPFilterLink', 'MTZwp', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{8AF50EA0-219F-44A0-B48E-3D1F7F83BC03}', 'EPFilterLink', 'EntryPoints', 'PARENT');



PERFORM SysOptions_SAVE  ('{0DDCE151-43DD-4EAC-860B-4A68FCF37CD7}', 'ARMTypes', 'MTZwp', 'STRUCT_TYPE');


PERFORM SysOptions_SAVE  ('{000941EF-88A4-4E75-8C0F-1B560CB53D37}', 'ARMJournal', 'MTZwp', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{18013900-4D82-45F3-9CFE-A09D7170AA14}', 'ARMJRNLADD', 'MTZwp', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{61F6A507-44F1-474E-8982-F226279DED53}', 'ARMJRNLADD', 'ARMJournal', 'PARENT');

PERFORM SysOptions_SAVE  ('{99B9BC0B-EDC5-4AEB-845B-9791BFF8B603}', 'ARMJRNLREP', 'MTZwp', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{D22C4138-420A-42CC-845C-89D6D6A14AF3}', 'ARMJRNLREP', 'ARMJournal', 'PARENT');

PERFORM SysOptions_SAVE  ('{104743F5-C2DE-48A6-AE4A-9711CA0B6A54}', 'ARMJRNLRUN', 'MTZwp', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{0E9DF61E-9387-4D48-9835-CAD5F9C39801}', 'ARMJRNLRUN', 'ARMJournal', 'PARENT');





PERFORM SysOptions_SAVE  ('{EDB2A8BE-DE4A-4875-88E4-31B322C226FF}', 'INVD_UPR', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{0C7EC92C-864E-462C-BBFF-4B8721276B3F}', 'INVD_UPR', 'AUTOINVD_UPR', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{A1E6028A-EA40-4333-AB73-60EA2A132D3E}', 'INVD_OTDEL', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{FC7E26CF-99CA-4951-85EE-76B1CF7E2746}', 'INVD_OTDEL', 'AUTOINVD_OTDEL', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{4CA55BF8-ABFD-45BB-BF29-6C928D8CBB3B}', 'INVD_BLD', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{4B1EEA32-2C19-4EA2-A0AF-F72DBE1EAD6A}', 'INVD_BLD', 'AUTOINVD_BLD', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{3F2E7193-499E-4EFC-8389-EC43EAC4D063}', 'INVD_DRAG', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{5C841D4A-ECF6-492B-BC53-EF71C9E7A1CD}', 'INVD_DRAG', 'AUTOINVD_DRAG', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{1D2BEB8B-AC72-49A1-8003-54DE9D859A3E}', 'INVD_ORG', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{74E063B8-0557-457D-B5D3-B71207F8D400}', 'INVD_ORG', 'AUTOINVD_ORG', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{E07814CE-5BDB-411F-9BAC-6BAC52496FBC}', 'INVD_OSSTATUS', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{40A8CB83-CE2B-45DF-9C14-56480F2E33A9}', 'INVD_OSSTATUS', 'AUTOINVD_OSSTATUS', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{2B06D038-F24C-4A95-BDBF-69D808605F7A}', 'INVD_OWNER', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{AC49627E-F1AD-4748-BFE4-5C181BADDBC3}', 'INVD_OWNER', 'AUTOINVD_OWNER', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{72B7FB8F-ECA8-4DEC-BA72-1173673A07AF}', 'INVD_UR', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{538D99E8-2E47-4F32-9585-6A4593C57822}', 'INVD_UR', 'AUTOINVD_UR', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{06429713-729F-4D4F-AA2B-75ECBA60F8B6}', 'INVD_OSTYPE', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{F97F1232-C81B-47CB-8D62-DA1AD11FAF3C}', 'INVD_OSTYPE', 'viewINV_DIC_INVD_OSTYPE', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{4ECA40CF-D4B0-4EFC-897F-9218DDDD8270}', 'INVD_DIR', 'INV_DIC', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{0BC228D0-2EAC-422F-A6D7-F6D35637DDA7}', 'INVD_DIR', 'AUTOINVD_DIR', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{2275690C-9484-4A79-8AD5-B76B44277237}', 'MTZ_Inst_Build', 'MTZ_Install', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{E4B7E351-AFFE-46E2-B125-8EAE9739B6E4}', 'MTZ_Inst_Build_Sec', 'MTZ_Install', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{E4FC96A6-7DC1-48B5-8431-8C914C9F7C78}', 'MTZ_Inst_Build_Sec', 'MTZ_Inst_Build', 'PARENT');

PERFORM SysOptions_SAVE ( '{92FD5B93-665B-4359-8BEB-34E27FA1A074}', 'MTZ_Inst_Build', 'viewMTZ_Install_MTZ_Inst_Build', 'DEFVIEW');


PERFORM SysOptions_SAVE  ('{E49786C5-DF34-4420-BFE8-C7CD2D187520}', 'MTZ_Inst_Section', 'MTZ_Install', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{5BAC8BF0-A858-4EF8-A74D-94BE8360F14E}', 'MTZ_Inst_Sec_Files', 'MTZ_Install', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{F69A1609-771A-41C2-869E-06A8C6CBB241}', 'MTZ_Inst_Sec_Files', 'MTZ_Inst_Section', 'PARENT');



PERFORM SysOptions_SAVE  ('{60280ADF-7E7C-45CC-A4DF-944FFE469056}', 'MTZ_Inst_Common', 'MTZ_Install', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{45790A56-2F39-4086-8E28-935E78079504}', 'MTZ_Inst_Common', 'viewMTZ_Install_MTZ_Inst_Common', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{3F068890-15EC-4CB6-BDF6-8D6423FD2613}', 'InfoStoreDef', 'STDInfoStore', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{67B8944D-11A6-45C5-BDAC-AB5B10DB1B99}', 'InfoStoreDef', 'AUTOInfoStoreDef', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{595F1866-3846-421C-9E4F-1D474C21A403}', 'Folder', 'STDInfoStore', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE  ('{3479D295-542A-4FA5-B340-9463119FDA38}', 'Shortcut', 'STDInfoStore', 'STRUCT_TYPE');
PERFORM SysOptions_SAVE ( '{E571C0D8-FACA-4A4A-A068-974D70FD10A6}', 'Shortcut', 'Folder', 'PARENT');

PERFORM SysOptions_SAVE ( '{CD9E56F9-6E99-43BC-9150-48A3221C959D}', 'Folder', 'viewSTDInfoStore_Folder', 'DEFVIEW');

PERFORM SysOptions_SAVE ( '{A0B8FD41-9CD3-44E6-B20F-27FA4CC39FD6}', 'Shortcut', 'AUTOShortcut', 'DEFVIEW');
PERFORM SysOptions_SAVE ( '{43E88667-7427-462A-98C7-583E9480FB60}', 'MTZExt', 'viewMTZExt_MTZExt_def', 'TDEFVIEW');

PERFORM SysOptions_SAVE  ('{603FDE67-877E-41C4-A5A7-2A8C1FCFE95C}', 'MTZExt_def', 'MTZExt', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{131A2854-706A-4E29-A4A8-BB3A110713CC}', 'MTZExt_def', 'viewMTZExt_MTZExt_def', 'DEFVIEW');

PERFORM SysOptions_SAVE  ('{A901642C-29E9-4F01-B5A2-BAEAB51D1B5E}', 'MTZExtRel', 'MTZExt', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{055903EA-49A1-41DF-8D41-CEB27EBC9928}', 'INV_NUM', 'AUTOINVN_DEF', 'TDEFVIEW');

PERFORM SysOptions_SAVE  ('{C44534D0-4B56-4628-8A06-923EF509742E}', 'INVN_DEF', 'INV_NUM', 'STRUCT_TYPE');

PERFORM SysOptions_SAVE ( '{6735C37E-EDF7-435A-AE35-1181B4FC8BAA}', 'INVN_DEF', 'AUTOINVN_DEF', 'DEFVIEW');
PERFORM SysOptions_SAVE ( '{E556241D-D25C-4EC3-A2A1-5F2BC42EF669}', '', 'VBMigrateRight', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{16112BF1-A986-41D5-A021-EC9D617255AB}', '', 'VBCheckDescrs', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{0EEDF95B-327F-4817-BF21-40708F955908}', '', 'VBApplySecurity', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{7994A135-2471-482C-A379-AA56CBF54FD0}', '', 'AdminUnlockAll', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{46727E2E-D46B-4AE7-9ABA-218E70FF1E9E}', '', 'GetNewNumber', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{78CA0D3F-4B68-4E8D-9FBA-17C2EC04811C}', '', 'VBMakeReport', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{DF1C32BC-986C-4038-8230-20A9434A8E8A}', '', 'TestNumber', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{E01FAC21-4D18-483E-8D20-BDB292F9AF43}', '', 'SessionVerify', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{F4AEBB2B-1A86-4E1C-92ED-5C3E6663F537}', '', 'VBRemoveSymmetricObjRef', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{4FE9AC1B-EEC5-4B6F-BF07-54AD1342DBBE}', '', 'VBSaveHistory', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{07CDC8B6-F714-45E7-90B4-EDE0F7B32B1B}', '', 'GetFreeNumber', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{B3F687C0-48B3-40B8-AA53-5D1689ADCCBF}', '', 'VBAddObjByRef', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{45570BEB-A942-4BB0-B65D-26DAF78442DE}', '', 'VBUpdateSymmetricObjRef', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{B4621E4B-AB19-41F0-ACF2-156CB7B7B78C}', '', 'ClearNumerators', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{126A962F-9FDC-46CB-881A-2E2E25FF5F8E}', '', 'VBNewPayOut', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{0440303B-BAEA-4C4E-8882-F15C98C9B523}', '', 'SessionCheckPoint', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{34A5FC3A-DC85-476E-8B79-5D03EC5F6B50}', '', 'VBOpenRef', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{5BC6D007-AF70-4F39-919E-FD79D8912867}', '', 'WFDefName', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{890898A3-ACF7-4EC3-8079-6021650D2974}', '', 'RowsToInstances', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{767BB70C-884F-4CC2-8599-8BAB09F2E3F9}', '', 'WFFuncName', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{65A3B2B8-D560-47B6-B847-9E63F7F0A117}', '', 'VBUpdateObjName', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{2C81B268-70D8-4C19-BB43-B510FDE52343}', '', 'GetServerTime', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{05D40EA0-847E-43D6-A7A1-5CB79BFDBC13}', '', 'SessionTouch', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{7FB361F5-336F-400E-B269-493D21B062B5}', '', 'MTZLogin', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{58E70C5D-8ECC-48F3-8DE7-547B37DCB91E}', '', 'RowToInstance', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{5C9C224D-1D94-48A3-99E0-66242E257689}', '', 'EraseNumber', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{8BD09B76-0916-40DA-A473-9AAF74A77F72}', '', 'AdminUnlock', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{8FC3616A-B23E-4494-AED7-D8747CA65512}', '', 'CheckVerbRight', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{6E3C6F3E-F9DA-41A9-A69B-3C1C0B25B2F0}', '', 'Logout', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{B73C40AE-CAAB-4045-A0CD-65CE8A86E36C}', '', 'AutoCloseSession', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{9284F29B-D265-4EB3-9006-BCEB80152C13}', '', 'MakeNewFolderEC', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{5012ADF8-E564-4D03-B535-17D06240D266}', '', 'VBUpdateItemName', 'METHODNAME');
PERFORM SysOptions_SAVE ( '{FE989DC3-2425-45A1-AE2D-8C71D5054241}', '', 'Login', 'METHODNAME');
return 1;
end;
$$ language 'plpgsql'; 
GO


"><FormData Name=""/></BlockHolder></ModuleHolder></root>
